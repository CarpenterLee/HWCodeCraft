/* 
 * Command line: opannotate --source ./main 
 * 
 * Interpretation of command line:
 * Output annotated source file with samples
 * Output all files
 * 
 * CPU: Intel Westmere microarchitecture, speed 2.399e+06 MHz (estimated)
 * Counted CPU_CLK_UNHALTED events (Clock cycles when not halted) with a unit mask of 0x00 (No unit mask) count 60000
 * Counted LLC_MISSES events (Last level cache demand requests from this core that missed the LLC) with a unit mask of 0x41 (No unit mask) count 6000
 */
/* 
 * Total samples for file : "/home/lh/Desktop/codecraft/profile/./future_net/bitset.h"
 * 
 *  52576 44.7311   305 18.0154
 */


                               :#ifndef __BITSET_H__
                               :#define __BITSET_H__
                               :#include <string.h>
                               :#include <stdio.h>
                               :
                               :#define __BITSET_SIZE 2048 //必须是64的整数倍
                               :typedef unsigned int ATOMTYPE;
                               :
                               :/**
                               : * 自定义的bitset类，实现了& | == 操作。不进行下标越界检查。
                               : * 用int数组做buf
                               : * v2.0
                               : */
                               :class bitset{
                               :private:
                               :	ATOMTYPE buf[(__BITSET_SIZE>>3)/sizeof(ATOMTYPE)];
                               :	int buf_size;
                               :	int atom_sizeB;//1, 4 or 8 byte
                               :	int move;// 3, 5 or 6
                               :	int mod;// 8, 32 or 64
                               :	int mod_minus_1;
                               :public:
                               :	bitset(){
     2  0.0017     0       0   :		atom_sizeB = sizeof(ATOMTYPE);
    10  0.0085     0       0   :		buf_size = (__BITSET_SIZE>>3)/atom_sizeB;
                               :		memset(buf, 0, __BITSET_SIZE>>3);
    12  0.0102     0       0   :		if(atom_sizeB == 1){
                               :			move = 3;
                               :			mod = 8;
    11  0.0094     0       0   :		}else if(atom_sizeB == 4){
    11  0.0094     0       0   :			move = 5;
    26  0.0221     0       0   :			mod = 32;
                               :		}else{//atom_size == 8
                               :			move = 6;
                               :			mod = 64;
                               :		}
    16  0.0136     0       0   :		mod_minus_1 = mod-1;
                               ://		printf("atom_sizeB=%d, move=%d, mod=%d\n", atom_sizeB, move, mod);
                               :	}
                               :	/*返回1的个数，测试时使用，效率很低*/
                               :	int count(){
                               :		int count = 0;
                               :		for(int i = 0; i < __BITSET_SIZE; ++i)
                               :			if(get(i))
                               :				++count;
                               :		return count;
                               :	}
                               :	/*得到position这一位是0还是1*/
                               :	inline int get(int position){
                               ://		return (buf[position>>move]&(1<<(position%mod))) ? 1 : 0;
                               :		return (buf[position>>move]&(1<<(position&mod_minus_1)));
                               :	}
                               :	/*将position指定的位置1*/
                               :	inline void set(int position){
                               ://		buf[position>>move] |= (1<<(position%mod));
    82  0.0698     0       0   :		buf[position>>move] |= (1<<(position&mod_minus_1));
                               :	}
                               :	/*将position指定的位置0*/
                               :	void reset(int position){
                               ://		buf[position>>move] &= ~(1<<(position%mod));
     2  0.0017     0       0   :		buf[position>>move] &= ~(1<<(position&mod_minus_1));
                               :	}
                               :	/*bitset按位与操作，返回与之后的结果，不修改原来的值*/
                               :	inline bitset operator& (const bitset& other){
                               :		bitset rs = other;
                               :		for(int i=0; i<buf_size; ++i)
                               :			rs.buf[i] &= this->buf[i];
                               :		return rs;
                               :	}
                               :	/*判断other跟this是否有重复置1的位，如果有就返回false*/
                               :	inline bool isLoopless(const bitset& other){
                               :		register int i;
 35117 29.8771    79  4.6663   :		for(i = 0; i < buf_size; ++i){
  8121  6.9093    91  5.3751   :			if(buf[i]&other.buf[i])
                               :				return false;
                               :		}
                               :		return true;
                               :	}
                               :	/*bitset按位或操作，返回或之后的结果，不修改原来的值*/
                               :	inline bitset operator| (const bitset& other){
  2856  2.4299   118  6.9699   :		bitset rs = other;
   939  0.7989     1  0.0591   :		for(int i=0; i<buf_size; ++i)
   711  0.6049     1  0.0591   :			rs.buf[i] |= this->buf[i];
                               :		return rs;
                               :	}
                               :	bool operator== (const bitset& other){
                               :		for(int i=0; i<buf_size; ++i)
                               :			if(this->buf[i] != other.buf[i])
                               :				return false;
                               :		return true;
                               :	}
                               :	inline int operator[] (const int position){
                               ://		return (buf[position>>move]&(1<<(position%mod))) ? 1 : 0;
  4660  3.9647    15  0.8860   :		return (buf[position>>move]&(1<<(position&mod_minus_1)));
                               :	}
                               :};
                               :
                               :#endif
/* 
 * Total samples for file : "/home/lh/Desktop/codecraft/profile/./future_net/route.cpp"
 * 
 *  26836 22.8318   637 37.6255
 */


                               :/**
                               : * 功能: 解决寻路问题, 自实现GLG算法
                               : * 作者: GuoJiaLiang, LiHao, GuoZhenXing
                               : * 时间: 2016-4-10
                               : * 版本: v1.0
                               : */
                               :#include "route.h"
                               :#include "lib_record.h"
                               :#include "bitset.h"
                               :#include "vector_int.h"
                               :#include "Path.h"
                               :#include "priority_queue_path.h"
                               :#include <string.h>
                               :#include <stdio.h>
                               :#include <string.h>
                               :#include <stdlib.h>
                               :#include <unordered_map>
                               :#include <unordered_set>
                               :#include <set>
                               :#include <vector>
                               :#include <queue>
                               :#include <algorithm>
                               :#include <bitset>
                               :
                               :#define MAX_TABLE 5000
                               :#define MAX_VERTEX 2000
                               :#define INT_MAX 0xffffff
                               :
                               ://--------------------------------------------------------------------------------------------------------类型定义
                               :struct pair_hash {
                               :public:
                               :    template <typename T, typename U>
                               :    std::size_t operator()(const std::pair<T, U> &x) const {
                               :        //return std::hash<T>()(x.first) ^ std::hash<U>()(x.second);
    21  0.0179     0       0   :        return (x.first << 11) + x.second;
                               :    }
                               :};
                               :struct pair_cmp{
                               :	bool operator()(std::pair<int, int> a, std::pair<int, int> b){
                               :		return a.second > b.second;
                               :	}
                               :};
                               :typedef std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int> >, pair_cmp> PairQueue;
                               :typedef std::pair<int, int>             Edge;           // 有向边的定义, first代表边的起点， second代表边的终点
                               :typedef std::pair<int, int>             EdgeInfo;       // 有向边的附加信息的定义, first代表边的编号， second代表边的权重
                               :typedef std::unordered_map<Edge, PairQueue, pair_hash>        EdgeInfoDict;   // 有向边附加信息字典的定义
                               :typedef std::vector<std::set<int> >   Graph;          // 图的定义
                               :typedef std::vector<std::pair<int, int> > Previous;  // 保存路径前向信息, <父节点编号，边的编号>
                               :typedef std::set<int>                   Conditions;     // 必须经过的结点集合
                               :typedef std::vector<Path*> PathQueue;                // 保存访问路径的优先队列
                               :typedef std::unordered_map<int, std::unordered_map<int, PathQueue> > DpTable;
                               :typedef std::unordered_map<int, PathQueue> DistanceTable;
                               :typedef std::vector<std::vector<bool> > DirectArrive;
                               :typedef std::unordered_map<int, std::vector<int> > ObstructTable;
                               :typedef std::vector<std::unordered_map<int, std::vector<bitset> > > BitpathTable;
                               :
                               :typedef struct CSR {
                               :    std::vector<PairQueue> edgeinfos;
                               :    std::vector<int> columns;
                               :    std::vector<int> rowIndex;
                               :    CSR(void):rowIndex(MAX_VERTEX + 1){}
                               :} CSR;
                               ://--------------------------------------------------------------------------------------------------------全局变量定义
                               :bool forward = true;
                               :int search_index;
                               :int source, dest;
                               :Conditions conditions[2];
                               :bitset conditions_bits[2];     // 必经点的bitset表示
                               :Graph graph(MAX_VERTEX), tr_graph(MAX_VERTEX);
                               :EdgeInfoDict edgeInfoDict, tr_edgeInfoDict;
                               :CSR csr[2], tr_csr[2]; /* __tcf_1      5  0.0043     0       0, __tcf_2      5  0.0043     0       0, total:     10  0.0085     0       0 */
                               :std::vector<Path *> routes[2];
                               :std::vector<Path *> result;
                               :
                               :unsigned int F_K_PATH = 3;  // 填动态规划表的路径数
                               :const bitset zero_bitset;   // 用于清空bitset
                               :bitset available;           // 有效点(从源点可以到，且可以到目的点)的bitset表示
                               :BitpathTable bitpath_table(100);
                               ://--------------------------------------------------------------------------------------------------------输入输出函数
                               :int ReadANumberFromStr(char *, unsigned int &);                                          // 从字符流中读取一个数字
                               :void ReadGraphData(char **);  // 读取图信息
                               :void ReadConditionsData(char *);                    // 读取约束条件信息
                               :void PrintPath(void);
                               ://--------------------------------------------------------------------------------------------------------复赛策略函数
                               :void get_disjoint_paths(char *[MAX_EDGE_NUM], char *[MAX_DEMAND_NUM], int);
                               :void CleanGraphData(void);                            // 清理图数据，获得源可达且可达目的的顶点，更新全局变量available
                               :void DFS(CSR &, int, bitset &);
                               :void generate_first_csr(Graph &, EdgeInfoDict &, CSR &, bitset &);
                               :void generate_second_csr(Graph &, EdgeInfoDict &, CSR &);
                               :void update_edgeinfo(std::vector<Path*> &);
                               :void get_optimum_paths(void);
                               :int get_conflict(Path *, Path *);
                               ://--------------------------------------------------------------------------------------------------------算法函数
                               :void get_shortest_path(int, DistanceTable &);      // 使用Dijkstra求权值最短路径
                               :void Dijkstra(int, Previous &, std::vector<int> &, bitset &);  // Dijkstra算法
                               :Path* search_path(int, int, Previous &, std::vector<int> &);    // 辅助Dijkstra生成反向路径
                               :void get_second_path(int, int, Previous &, std::vector<int> &, DistanceTable &);      // 求近似第二短路径
                               :void get_BFS_path(int, DistanceTable &, DistanceTable &);           // 使用广度优先搜索求长度最短路径
                               :int get_arrive_info(int, DirectArrive &, ObstructTable &);   //构造直接到达矩阵的一行，返回一行中1的个数
                               :void fill_dp(int, int, DpTable &, DistanceTable &, DirectArrive &, ObstructTable &);  // 填动态规划表
                               :void get_result(DpTable & dp);  // 获取最小结果
                               :Path* connect_path(Path*, Path*);               // 连接两条路径
                               :bool isValid(Path*, ObstructTable &);    //判断路径合法性
                               :bool isDuplicate(Path*, std::vector<Path*> &);  // 判断路径是否重复
                               ://bool isLoopless(Path*, Path* );                 // 判断两条路径是否构成环
                               :
                               :void GLG(void);   // GLG算法
                               ://--------------------------------------------------------------------------------------------------------赛题入口
                               :void search_route(char *topo[MAX_EDGE_NUM], int edge_num, char *demand[MAX_DEMAND_NUM], int demand_num) {
                               :    get_disjoint_paths(topo, demand, demand_num);
                               :    PrintPath();
                               :}
                               ://--------------------------------------------------------------------------------------------------------输入输出函数实现
                               :int ReadANumberFromStr(char * str, unsigned int & index) {
                               :    int res = str[index] - '0';
   176  0.1497    11  0.6497   :    while(str[++index] >= '0' && str[index] <= '9') {
     1 8.5e-04     0       0   :        res *= 10;
                               :        res += str[index] - '0';
                               :    }
     3  0.0026     1  0.0591   :    while(index < strlen(str) && !(str[index] >= '0' && str[index] <= '9')){index++;}
                               :    return res;
                               :}
                               :
                               :void ReadGraphData(char *graphStream[MAX_EDGE_NUM]) { /* ReadGraphData(char**) total:    220  0.1872    13  0.7679 */
    12  0.0102     0       0   :    for(unsigned int i = 0; graphStream[i] != 0x0 && i < MAX_EDGE_NUM; ++i) {
                               :        unsigned int j = 0;
                               :        int edgeNo = ReadANumberFromStr(graphStream[i], j);
                               :        int edgeFrom = ReadANumberFromStr(graphStream[i], j);
     0       0     1  0.0591   :        int edgeTo = ReadANumberFromStr(graphStream[i], j);
                               :        int edgeCost = ReadANumberFromStr(graphStream[i], j);
                               :
                               :        graph[edgeFrom].insert(edgeTo);
                               :        tr_graph[edgeTo].insert(edgeFrom);
                               :
                               :        Edge edge(edgeFrom, edgeTo);
                               :        Edge tr_edge(edgeTo, edgeFrom);
                               :        EdgeInfo edgeInfo(edgeNo, edgeCost);
                               :
                               :        // 如果边信息字典中已经有了这条边且当前权大于字典中的权， 则不更新字典
                               :        // 否则就要更新字典（可能是插入新边， 也可能是更新旧边）
                               :        edgeInfoDict[edge].push(edgeInfo);
                               :        tr_edgeInfoDict[tr_edge].push(edgeInfo);
                               :    }
                               :}
                               :
                               :void ReadConditionsData(char *conditionsStream) { /* ReadConditionsData(char*) total:      1 8.5e-04     0       0 */
                               :    unsigned int i = 0;
                               :    ReadANumberFromStr(conditionsStream, i);
                               :    source = ReadANumberFromStr(conditionsStream, i);
                               :    dest = ReadANumberFromStr(conditionsStream, i);
                               :    while(i < strlen(conditionsStream)) {
                               :        int number = ReadANumberFromStr(conditionsStream, i);
                               :        conditions[search_index].insert(number);
                               :        conditions_bits[search_index].set(number);
                               :    }
                               :}
                               :
                               :void PrintPath() {
                               :    if(result.size() < 2) {
                               :        return;
                               :    }
                               :    if(forward) {
                               :        for (int i = 0; i < result[0]->edgePath.size(); i++) {
                               :            record_result(WORK_PATH, result[0]->edgePath[i]);
                               :        }
                               :        for (int i = 0; i < result[1]->edgePath.size(); i++) {
                               :            record_result(BACK_PATH, result[1]->edgePath[i]);
                               :        }
                               :    } else {
                               :        for (int i = result[0]->edgePath.size() - 1; i >= 0; i--) {
                               :            record_result(WORK_PATH, result[0]->edgePath[i]);
                               :        }
                               :        for (int i = result[1]->edgePath.size() - 1; i >= 0; i--) {
                               :            record_result(BACK_PATH, result[1]->edgePath[i]);
                               :        }
                               :    }
                               :}
                               ://--------------------------------------------------------------------------------------------------------复赛策略函数
                               :void get_disjoint_paths(char *topo[MAX_EDGE_NUM], char *demand[MAX_DEMAND_NUM], int demand_num) {
                               :    ReadGraphData(topo);
                               :    for(int i = 0; i < demand_num; i++) {
                               :        search_index = i;
                               :        ReadConditionsData(demand[i]);
                               :    }
                               :
                               :    forward = false;
                               :    std::swap(source, dest);
                               :    swap(graph, tr_graph);
                               :    swap(edgeInfoDict, tr_edgeInfoDict);
                               :
                               :    //搜索第一条路径
                               :    search_index = 0;
                               :    generate_first_csr(graph, edgeInfoDict, csr[0], conditions_bits[1]);
                               :    generate_first_csr(tr_graph, tr_edgeInfoDict, tr_csr[0], conditions_bits[1]);
                               :    CleanGraphData();
                               :    GLG();
                               :    //printf("%d\n", routes[0].size());
                               :    //搜索第二条路径
                               :    search_index = 1;
                               :    update_edgeinfo(routes[0]);
                               :    generate_second_csr(graph, edgeInfoDict, csr[1]);
                               :    generate_second_csr(tr_graph, tr_edgeInfoDict, tr_csr[1]);
                               :    GLG();
                               :    //printf("%d\n", routes[1].size());
                               :    //得到最优结果
                               :    get_optimum_paths();
                               :}
                               :
                               :void CleanGraphData() {
                               :    bitset source_can_arrive;
                               :    bitset dest_can_arrive;
                               :    DFS(csr[search_index], source, source_can_arrive);
                               :    DFS(tr_csr[search_index], dest, dest_can_arrive);
                               :    available = source_can_arrive & dest_can_arrive;
                               :}
                               :
                               :void DFS(CSR & csr, int link_from, bitset & arrive) { /* DFS(CSR&, int, bitset&) total:     26  0.0221     0       0 */
                               :    arrive.set(link_from);
     2  0.0017     0       0   :    if(csr.rowIndex[link_from] == csr.rowIndex[link_from + 1]) {
                               :        return;
                               :    }
     3  0.0026     0       0   :    for(int i = csr.rowIndex[link_from]; i < csr.rowIndex[link_from + 1]; i++) {
     1 8.5e-04     0       0   :        if(!arrive[csr.columns[i]]) {
     1 8.5e-04     0       0   :            DFS(csr, csr.columns[i], arrive);
                               :        }
                               :    }
                               :}
                               :
     5  0.0043     0       0   :void generate_first_csr(Graph & graph, EdgeInfoDict & edgeInfoDict, CSR & csr, bitset & conditions_bits) { /* generate_first_csr(std::vector<std::set<int, std::less<int>, std::allocator<int> >, std::allocator<std::set<int, std::less<int>, std::allocator<int> > > >&, std::unordered_map<std::pair<int, int>, std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>, std::allocator<std::pair<int, int> > >, pair_cmp>, pair_hash, std::equal_to<std::pair<int, int> >, std::allocator<std::pair<std::pair<int, int> const, std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>, std::allocator<std::pair<int, int> > >, pair_cmp> > > >&, CSR&, bitset&) total:     98  0.0834     2  0.1181 */
                               :    csr.rowIndex[0] = 0;
                               :    for(int i = 0; i < MAX_VERTEX; i++) {
                               :        if(graph[i].size()) {
     1 8.5e-04     0       0   :            csr.rowIndex[i + 1] = csr.rowIndex[i] + graph[i].size();
                               :            for(std::set<int>::const_iterator iter = graph[i].begin(); iter != graph[i].end(); ++iter) {
     9  0.0077     0       0   :                if(conditions_bits[i] || conditions_bits[*iter]) {
                               :                    PairQueue temp = edgeInfoDict[Edge(i, *iter)];
                               :                    PairQueue change;
                               :                    while(!temp.empty()) {
                               :                        EdgeInfo edgeinfo = temp.top();
                               :                        temp.pop();
                               :                        edgeinfo.second += 500;
                               :                        change.push(edgeinfo);
                               :                    }
                               :                    csr.edgeinfos.push_back(change);
                               :                    csr.columns.push_back(*iter);
                               :                } else {
                               :                    csr.edgeinfos.push_back(edgeInfoDict[Edge(i, *iter)]);
                               :                    csr.columns.push_back(*iter);
                               :                }
                               :            }
                               :        } else {
                               :            csr.rowIndex[i + 1] = csr.rowIndex[i];
                               :        }
                               :    }
                               :}
                               :
     2  0.0017     0       0   :void generate_second_csr(Graph & graph, EdgeInfoDict & edgeInfoDict, CSR & csr) { /* generate_second_csr(std::vector<std::set<int, std::less<int>, std::allocator<int> >, std::allocator<std::set<int, std::less<int>, std::allocator<int> > > >&, std::unordered_map<std::pair<int, int>, std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>, std::allocator<std::pair<int, int> > >, pair_cmp>, pair_hash, std::equal_to<std::pair<int, int> >, std::allocator<std::pair<std::pair<int, int> const, std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>, std::allocator<std::pair<int, int> > >, pair_cmp> > > >&, CSR&) total:     81  0.0689     1  0.0591 */
                               :    csr.rowIndex[0] = 0;
     1 8.5e-04     0       0   :    for(int i = 0; i < MAX_VERTEX; i++) {
                               :        if(graph[i].size()) {
     2  0.0017     0       0   :            csr.rowIndex[i + 1] = csr.rowIndex[i] + graph[i].size();
                               :            for(std::set<int>::const_iterator iter = graph[i].begin(); iter != graph[i].end(); ++iter) {
                               :                csr.edgeinfos.push_back(edgeInfoDict[Edge(i, *iter)]);
                               :                csr.columns.push_back(*iter);
                               :            }
                               :        } else {
                               :            csr.rowIndex[i + 1] = csr.rowIndex[i];
                               :        }
                               :    }
                               :}
                               :
                               :void update_edgeinfo(std::vector<Path*> & paths) { /* update_edgeinfo(std::vector<Path*, std::allocator<Path*> >&) total:    288  0.2450     0       0 */
                               :    std::set<int> visit;
                               :    for(unsigned int i = 0; i < paths.size(); i++) {
     1 8.5e-04     0       0   :        Path *path = paths[i];
                               :        for(unsigned j = 0; j < path->nodePath.size(); j++) {
     3  0.0026     0       0   :            Edge edge, tr_edge;
     6  0.0051     0       0   :            if(j == path->nodePath.size() - 1) {
                               :                edge = Edge(path->nodePath[j], path->endPoint);
                               :                tr_edge = Edge(path->endPoint, path->nodePath[j]);
                               :            } else {
     1 8.5e-04     0       0   :                edge = Edge(path->nodePath[j], path->nodePath[j + 1]);
     1 8.5e-04     0       0   :                tr_edge = Edge(path->nodePath[j + 1], path->nodePath[j]);
                               :            }
     7  0.0060     0       0   :            EdgeInfo edgeinfo = edgeInfoDict[edge].top();
     8  0.0068     0       0   :            EdgeInfo tr_edgeinfo = tr_edgeInfoDict[tr_edge].top();
                               :            if(visit.find(edgeinfo.first) == visit.end()) {
                               :                visit.insert(edgeinfo.first);
                               :                edgeinfo.second += 500;
     1 8.5e-04     0       0   :                tr_edgeinfo.second += 500;
                               :                edgeInfoDict[edge].pop();
                               :                edgeInfoDict[edge].push(edgeinfo);
                               :                tr_edgeInfoDict[tr_edge].pop();
                               :                tr_edgeInfoDict[tr_edge].push(tr_edgeinfo);
                               :            }
                               :        }
                               :    }
                               :}
                               :
                               :void get_optimum_paths() { /* get_optimum_paths() total:     15  0.0128     0       0 */
                               :    Path *work_path = NULL, *back_path = NULL;
                               :    int min_conflict = INT_MAX;
                               :    int min_cost = INT_MAX;
                               :    for(unsigned int i = 0; i < routes[0].size(); i++) {
     1 8.5e-04     0       0   :        for(unsigned int j = 0; j < routes[1].size(); j++) {
                               :            int conflict = get_conflict(routes[0][i], routes[1][j]);
     3  0.0026     0       0   :            if(conflict < min_conflict) {
                               :                work_path = routes[0][i];
                               :                back_path = routes[1][j];
                               :                min_conflict = conflict;
                               :                min_cost = work_path->pathCost + back_path->pathCost;
    10  0.0085     0       0   :            } else if(conflict == min_conflict && work_path->pathCost + back_path->pathCost < min_cost) {
                               :                work_path = routes[0][i];
                               :                back_path = routes[1][j];
                               :                min_cost = work_path->pathCost + back_path->pathCost;
                               :            }
                               :        }
                               :    }
                               :    result.push_back(work_path);
                               :    result.push_back(back_path);
                               :    //printf("min_conflict = %d, min_cost = %d\n", min_conflict, min_cost);
                               :}
                               :
     1 8.5e-04     0       0   :int get_conflict(Path* path1, Path* path2) { /* get_conflict(Path*, Path*) total:   6560  5.5812     0       0 */
   485  0.4126     0       0   :    std::bitset<40000> link1, link2;
   283  0.2408     0       0   :    for(unsigned int i = 0; i < path1->edgePath.size(); i++) {
   172  0.1463     0       0   :        link1.set(path1->edgePath[i]);
                               :    }
   250  0.2127     0       0   :    for(unsigned int j = 0; j < path2->edgePath.size(); j++) {
   193  0.1642     0       0   :        link2.set(path2->edgePath[j]);
                               :    }
                               :    std::bitset<40000> conflict = link1 & link2;
                               :    return conflict.count();
     6  0.0051     0       0   :}
                               ://--------------------------------------------------------------------------------------------------------算法函数实现
                               :void get_shortest_path(int link_from, DistanceTable & distance)
                               :{ /* get_shortest_path(int, std::unordered_map<int, std::vector<Path*, std::allocator<Path*> >, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<int const, std::vector<Path*, std::allocator<Path*> > > > >&) total:     50  0.0425     0       0 */
                               :    Previous prev(MAX_VERTEX, std::pair<int, int>(-1, -1));
                               :    std::vector<int> dis(MAX_VERTEX, INT_MAX);
                               :	bitset without;
                               :    without.set(source);
                               :    without.set(dest);
                               :    Dijkstra(link_from, prev, dis, without);
                               :    //求V‘中的点之间的最短路经
     4  0.0034     0       0   :    for(Conditions::iterator iter = conditions[search_index].begin(); iter != conditions[search_index].end(); iter++) {
     4  0.0034     0       0   :        if(link_from == *iter) {
                               :            continue;
                               :        } else {
     1 8.5e-04     0       0   :            if(dis[*iter] != INT_MAX){
     1 8.5e-04     0       0   :                Path* temp = search_path(link_from, *iter, prev, dis);
     1 8.5e-04     0       0   :                distance[*iter].push_back(temp);
     2  0.0017     0       0   :                get_second_path(link_from, *iter, prev, dis, distance);
                               :            }
                               :        }
                               :    }
                               :}
                               :
   654  0.5564    10  0.5907   :void Dijkstra(int link_from, Previous & prev, std::vector<int> & dis, bitset & without_bits) { /* Dijkstra(int, std::vector<std::pair<int, int>, std::allocator<std::pair<int, int> > >&, std::vector<int, std::allocator<int> >&, bitset&) total:  13761 11.7077    41  2.4217 */
                               :	bitset processed;   // 已处理过的结点
                               :    PairQueue candidates;   // 待处理的结点， 配合上Path的定义， 这便是一个小顶堆
                               :    // 算法初始化， 起点加入processed集合， 起点的邻接点加入candidates集合
                               :    processed.set(link_from);
                               :    dis[link_from] = 0;
                               :    prev[link_from].first = link_from;
                               :
   124  0.1055     0       0   :    for(int i = tr_csr[search_index].rowIndex[link_from]; i < tr_csr[search_index].rowIndex[link_from + 1]; i++) {
                               :        // 排除必须要排除的点
                               :        int link_to = tr_csr[search_index].columns[i];
                               :        if(without_bits[link_to]) {
                               :            continue;
                               :        }
     1 8.5e-04     0       0   :        dis[link_to] = tr_csr[search_index].edgeinfos[i].top().second;
                               :        prev[link_to].first = link_from;
                               :        prev[link_to].second = tr_csr[search_index].edgeinfos[i].top().first;
                               :        candidates.push(std::pair<int, int> (link_to, dis[link_to]));
                               :    }
                               :    // 算法主体开始
                               :    // 第一步： 从候选区挑一个最佳结点， 加入processed集合中去
                               :    // 第二步： 访问最佳结点的所有邻接点， 刷新或扩充候选人集合
    12  0.0102     0       0   :    while(!candidates.empty()) {
                               :        // 取出候选区最近的结点, 加入已处理集合中， 并将该结点当前的路径存储到最短路径字典中
     1 8.5e-04     0       0   :        std::pair<int, int> best = candidates.top();
                               :        candidates.pop();
    28  0.0238     0       0   :        if(processed[best.first]) {
                               :            continue;
                               :        }
                               :        processed.set(best.first);
                               :
                               :        // 访问最佳候选人的所有邻接点， 以刷新或扩充候选结点
                               :        // 如果最佳候选人没有邻接点， 直接开始下一轮循环
   296  0.2518     0       0   :        if(tr_csr[search_index].rowIndex[best.first] == tr_csr[search_index].rowIndex[best.first + 1]) {
                               :            continue;
                               :        }
  1482  1.2609     2  0.1181   :        for(int i = tr_csr[search_index].rowIndex[best.first]; i < tr_csr[search_index].rowIndex[best.first + 1]; i++) {
   252  0.2144     0       0   :            int link_to = tr_csr[search_index].columns[i];
   539  0.4586     1  0.0591   :            if(processed[link_to] || without_bits[link_to]) {
                               :                continue;
                               :            }
    57  0.0485     0       0   :            int edgeCost = tr_csr[search_index].edgeinfos[i].top().second;
                               :
  3126  2.6596    12  0.7088   :            if(dis[link_to] > dis[best.first] + edgeCost) {
   131  0.1115     0       0   :                dis[link_to] = dis[best.first] + edgeCost;
    30  0.0255     0       0   :                prev[link_to].first = best.first;
   332  0.2825     3  0.1772   :                prev[link_to].second = tr_csr[search_index].edgeinfos[i].top().first;
                               :                candidates.push(std::pair<int, int> (link_to, dis[link_to]));
                               :            }
                               :        }
                               :    }
                               :}
                               :
     5  0.0043     0       0   :Path* search_path(int link_from, int link_to, Previous & prev, std::vector<int> & dis) { /* search_path(int, int, std::vector<std::pair<int, int>, std::allocator<std::pair<int, int> > >&, std::vector<int, std::allocator<int> >&) total:    310  0.2637     0       0 */
                               :    Path* path = new Path;
                               :    path->endPoint = link_from;
     1 8.5e-04     0       0   :    path->pathCost = dis[link_to];
                               :    path->bitPath.set(link_to);
                               :    path->nodePath.push_back(link_to);
                               :    path->edgePath.push_back(prev[link_to].second);
     1 8.5e-04     0       0   :    int temp = prev[link_to].first;
                               :    while(temp != link_from) {
                               :        path->bitPath.set(temp);
                               :        path->nodePath.push_back(temp);
                               :        path->edgePath.push_back(prev[temp].second);
     4  0.0034     0       0   :        if(conditions_bits[search_index][temp]) {
     5  0.0043     0       0   :            path->passed++;
                               :        }
    22  0.0187     0       0   :        temp = prev[temp].first;
                               :    }
                               :    return path;
     6  0.0051     0       0   :}
                               :
                               :void get_second_path(int link_from, int link_to, Previous & prev, std::vector<int> & dis, DistanceTable & distance) { /* get_second_path(int, int, std::vector<std::pair<int, int>, std::allocator<std::pair<int, int> > >&, std::vector<int, std::allocator<int> >&, std::unordered_map<int, std::vector<Path*, std::allocator<Path*> >, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<int const, std::vector<Path*, std::allocator<Path*> > > > >&) total:    429  0.3650     3  0.1772 */
                               :    int minCost = 0xfffff, pre_vertex = -1, pre_edge = -1;
     1 8.5e-04     0       0   :	int cannot_pass = prev[link_to].first;
    19  0.0162     0       0   :    for(int i = csr[search_index].rowIndex[link_to]; i < csr[search_index].rowIndex[link_to + 1]; i++) {
     3  0.0026     0       0   :        int adjoint = csr[search_index].columns[i];
    13  0.0111     0       0   :        if(adjoint == cannot_pass || adjoint == link_from) {
                               :            continue;
                               :        }
    45  0.0383     0       0   :        if(dis[adjoint] != INT_MAX) {
                               :            int temp = adjoint;
                               :            bool loopless = true;
    89  0.0757     1  0.0591   :            while(prev[temp].first != temp) {
                               :                if(temp == link_to) {
    48  0.0408     0       0   :                    loopless = false;
                               :                }
                               :                temp = prev[temp].first;
                               :            }
    49  0.0417     1  0.0591   :            if(!loopless) {
                               :                continue;
                               :            }
    37  0.0315     0       0   :            int cur_cost = dis[adjoint] + csr[search_index].edgeinfos[i].top().second;
    78  0.0664     1  0.0591   :            if(cur_cost < minCost) {
                               :                minCost = cur_cost;
                               :                pre_vertex = adjoint;
    20  0.0170     0       0   :                pre_edge = csr[search_index].edgeinfos[i].top().first;
                               :            }
                               :        }
                               :    }
     1 8.5e-04     0       0   :    if(pre_vertex != -1) {
                               :        Path* second_path = search_path(link_from, pre_vertex, prev, dis);
                               :        second_path->pathCost = minCost;
                               :        second_path->bitPath.set(link_to);
                               :        second_path->nodePath.insert(second_path->nodePath.begin(), link_to);
     1 8.5e-04     0       0   :        second_path->edgePath.insert(second_path->edgePath.begin(), pre_edge);
     1 8.5e-04     0       0   :        if(conditions_bits[search_index][pre_vertex]) {
                               :            second_path->passed++;
                               :        }
                               :        distance[link_to].push_back(second_path);
                               :    }
                               :}
                               :
                               :void get_BFS_path(int link_from, DistanceTable & distance, DistanceTable & ToDest) { /* get_BFS_path(int, std::unordered_map<int, std::vector<Path*, std::allocator<Path*> >, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<int const, std::vector<Path*, std::allocator<Path*> > > > >&, std::unordered_map<int, std::vector<Path*, std::allocator<Path*> >, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<int const, std::vector<Path*, std::allocator<Path*> > > > >&) total:   2553  2.1721    46  2.7171 */
                               :    Previous prev(MAX_VERTEX, std::pair<int, int>(-1, -1));
                               :    std::vector<int> dis(MAX_VERTEX, INT_MAX);
                               :    dis[link_from] = 0;
                               :    prev[link_from].first = link_from;
                               :    bitset visit;
                               :    visit.set(link_from);
                               :    visit.set(source);
                               :    std::deque<int> paths_dequeue;
                               :    paths_dequeue.push_back(link_from);
                               :
     6  0.0051     0       0   :    while(!paths_dequeue.empty()) {
    17  0.0145     0       0   :        int cur_point = paths_dequeue.front();
                               :        paths_dequeue.pop_front();
   268  0.2280     1  0.0591   :        for(int i = csr[search_index].rowIndex[cur_point]; i < csr[search_index].rowIndex[cur_point + 1]; i++) {
   156  0.1327     1  0.0591   :            int link_to = csr[search_index].columns[i];
   117  0.0995     0       0   :            if(visit[link_to] || !available[link_to]) {
                               :                continue;
                               :            }
   245  0.2084     8  0.4725   :            dis[link_to] = dis[cur_point] + csr[search_index].edgeinfos[i].top().second;
     9  0.0077     0       0   :            prev[link_to].first = cur_point;
     8  0.0068     0       0   :            prev[link_to].second = csr[search_index].edgeinfos[i].top().first;
    17  0.0145     1  0.0591   :            if(conditions_bits[search_index][link_to] || link_to == dest) {
     5  0.0043     1  0.0591   :                Path* temp = search_path(link_from, link_to, prev, dis);
                               :                temp->reverse(link_to, link_from);
                               :                PathQueue paths = (link_to == dest) ? ToDest[link_from] : distance[link_from];
                               :                unsigned int index = 0;
    50  0.0425     0       0   :                while(index < paths.size() && !(*paths[index] == *temp)){index++;}
                               :                if(index < paths.size()) {
                               :                    dis[link_to] = -1;
                               :                    prev[link_to] = std::pair<int, int> (-1, -1);
                               :                    continue;
                               :                }
     6  0.0051     0       0   :                if(link_to == dest) {
                               :                    ToDest[link_from].push_back(temp);
                               :                } else {
                               :                    distance[link_from].push_back(temp);
                               :                }
                               :            }
                               :            visit.set(link_to);
                               :            paths_dequeue.push_back(link_to);
                               :        }
                               :    }
                               :}
                               :
                               :int get_arrive_info(int link_from, DirectArrive & direct_arrive, ObstructTable & obstruct){ /* get_arrive_info(int, std::vector<std::vector<bool, std::allocator<bool> >, std::allocator<std::vector<bool, std::allocator<bool> > > >&, std::unordered_map<int, std::vector<int, std::allocator<int> >, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<int const, std::vector<int, std::allocator<int> > > > >&) total:   1445  1.2294     0       0 */
                               :    bitset visit;
                               :    visit.set(link_from);
                               :    visit.set(source);
                               :    std::deque<int> paths_dequeue;
                               :    paths_dequeue.push_back(link_from);
                               :    std::vector<int> can_direct_arrive;
                               :    int count_of_true = 0;
                               :
    41  0.0349     0       0   :    while(!paths_dequeue.empty()) {
     5  0.0043     0       0   :        int cur_point = paths_dequeue.front();
                               :        paths_dequeue.pop_front();
    38  0.0323     0       0   :        if(cur_point != link_from && (conditions_bits[search_index][cur_point] || cur_point == dest)) {
     5  0.0043     0       0   :            direct_arrive[link_from][cur_point] = true;
                               :            can_direct_arrive.push_back(cur_point);
                               :            count_of_true++;
                               :            continue;
                               :        }
   240  0.2042     0       0   :        for(int i = csr[search_index].rowIndex[cur_point]; i < csr[search_index].rowIndex[cur_point + 1]; i++) {
    71  0.0604     0       0   :            int link_to = csr[search_index].columns[i];
   100  0.0851     0       0   :            if(visit[link_to] || !available[link_to]) {
                               :                continue;
                               :            }
                               :            visit.set(link_to);
                               :            paths_dequeue.push_back(link_to);
                               :        }
                               :    }
                               :    if(count_of_true * 1.0 / conditions[search_index].size() < 0.2) {
                               :        obstruct[link_from] = can_direct_arrive;
                               :    }
                               :    return count_of_true;
                               :}
                               :
                               :void fill_dp(int iter_count, int link_from, DpTable & dp, DistanceTable & distance,
     2  0.0017     0       0   :             DirectArrive & direct_arrive, ObstructTable & obstruct) { /* fill_dp(int, int, std::unordered_map<int, std::unordered_map<int, std::vector<Path*, std::allocator<Path*> >, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<int const, std::vector<Path*, std::allocator<Path*> > > > >, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<int const, std::unordered_map<int, std::vector<Path*, std::allocator<Path*> >, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<int const, std::vector<Path*, std::allocator<Path*> > > > > > > >&, std::unordered_map<int, std::vector<Path*, std::allocator<Path*> >, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<int const, std::vector<Path*, std::allocator<Path*> > > > >&, std::vector<std::vector<bool, std::allocator<bool> >, std::allocator<std::vector<bool, std::allocator<bool> > > >&, std::unordered_map<int, std::vector<int, std::allocator<int> >, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<int const, std::vector<int, std::allocator<int> > > > >&) total:  62576 53.2390   791 46.7218 */
                               :    std::vector<Path*> selected_paths;
                               :    //将dp[iter_count - 1][link_from]中经过节个数大于等于iter_count的路径加入dp[iter_count][link_from]中
                               :    PathQueue upper_queue = dp[iter_count - 1][link_from];
    29  0.0247     1  0.0591   :    for(unsigned int i = 0; i < upper_queue.size(); i++) {
   663  0.5641    70  4.1347   :        Path* temp = upper_queue[i];
    10  0.0085     2  0.1181   :        if(temp->passed >= iter_count) {
                               :            dp[iter_count][link_from].push_back(temp);
                               :            selected_paths.push_back(temp);
                               :        }
                               :    }
                               :
                               :    // 通过链接D(vi, vj)中的K条路和fn-1(vj)中的路生成备选路
     3  0.0026     1  0.0591   :    PathQueue & shortest_paths = distance[link_from];
   103  0.0876     0       0   :    for(unsigned int shortest_index = 0; shortest_index < shortest_paths.size() && dp[iter_count][link_from].size() < MAX_TABLE / conditions[search_index].size(); shortest_index++) {
    23  0.0196     0       0   :        Path* shortest_path = shortest_paths[shortest_index];
  5906  5.0248   361 21.3231   :        if(!direct_arrive[link_from][shortest_path->endPoint]) {
                               :            continue;
                               :        }
   540  0.4594    12  0.7088   :        PathQueue & candidate_paths = dp[iter_count - 1][shortest_path->endPoint];
     9  0.0077     0       0   :        std::vector<bitset> & a = bitpath_table[iter_count - 1][shortest_path->endPoint];
                               :        unsigned int has_connect = 0;
  2431  2.0683    19  1.1223   :        for(unsigned int candidate_index = 0; candidate_index < candidate_paths.size() && has_connect < F_K_PATH; candidate_index++) {
  3894  3.3130   111  6.5564   :            Path* candidate_path = candidate_paths[candidate_index];
                               :            //if(shortest_path->bitPath.isLoopless(candidate_path->bitPath)) {
                               :            if(shortest_path->bitPath.isLoopless(a[candidate_index])) {
    94  0.0800     0       0   :                Path* temp = connect_path(shortest_path, candidate_path);
                               :                if(isDuplicate(temp, selected_paths)) {
                               :                    continue;
                               :                }
                               :                //每隔一定迭代次数进行一次减枝
                               :                /*if(!(iter_count % 10)) {
                               :                    if(!isValid(temp, obstruct)) {
                               :                        continue;
                               :                    }
                               :                }*/
                               :                dp[iter_count][link_from].push_back(temp);
                               :                selected_paths.push_back(temp);
    15  0.0128     0       0   :                has_connect++;
                               :            }
                               :        }
                               :    }
     1 8.5e-04     0       0   :}
                               :
                               :void get_result(DpTable & dp) { /* get_result(std::unordered_map<int, std::unordered_map<int, std::vector<Path*, std::allocator<Path*> >, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<int const, std::vector<Path*, std::allocator<Path*> > > > >, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<int const, std::unordered_map<int, std::vector<Path*, std::allocator<Path*> >, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<int const, std::vector<Path*, std::allocator<Path*> > > > > > > >&) total:     52  0.0442     0       0 */
                               :    for(Conditions::iterator iter = conditions[search_index].begin(); iter != conditions[search_index].end(); iter++) {
                               :        PathQueue & shortest_paths = dp[conditions[search_index].size() - 1][*iter];
                               :        for(unsigned int shortest_index = 0; shortest_index < shortest_paths.size(); shortest_index++) {
                               :            Path* shortest_path = shortest_paths[shortest_index];
     4  0.0034     0       0   :            bitset without = shortest_path->bitPath;
                               :            without.set(dest);
                               :
                               :            Previous prev(MAX_VERTEX, std::pair<int, int>(-1, -1));
                               :            std::vector<int> dis(MAX_VERTEX, INT_MAX);
                               :            Dijkstra(*iter, prev, dis, without);
                               :            if(dis[source] != INT_MAX) {
                               :            	Path *left_path = search_path(*iter, source, prev, dis);
                               :            	Path *temp = connect_path(left_path, shortest_path);
                               :            	routes[search_index].push_back(temp);
                               :            }
                               :        }
                               :    }
                               :}
                               :
    32  0.0272     1  0.0591   :Path* connect_path(Path* left_path, Path* right_path) { /* connect_path(Path*, Path*) total:   8149  6.9331   127  7.5015 */
    16  0.0136     0       0   :    Path* temp = new Path;
    29  0.0247     0       0   :    temp->endPoint = right_path->endPoint;
   126  0.1072     1  0.0591   :    temp->passed = left_path->passed + right_path->passed + 1;
    30  0.0255     0       0   :    temp->pathCost = left_path->pathCost + right_path->pathCost;
   947  0.8057     1  0.0591   :    temp->bitPath = left_path->bitPath | right_path->bitPath;
                               :    temp->nodePath.insert(temp->nodePath.end(), left_path->nodePath.begin(), left_path->nodePath.end());
                               :    temp->nodePath.insert(temp->nodePath.end(), right_path->nodePath.begin(), right_path->nodePath.end());
                               :    temp->edgePath.insert(temp->edgePath.end(), left_path->edgePath.begin(), left_path->edgePath.end());
                               :    temp->edgePath.insert(temp->edgePath.end(), right_path->edgePath.begin(), right_path->edgePath.end());
                               :    return temp;
    23  0.0196     0       0   :}
                               :
                               :bool isValid(Path* path, ObstructTable & obstruct) {
                               :    std::unordered_map<int, int> arrive;
                               :    int link_from = path->nodePath[0];
                               :    arrive[-1] = conditions_bits[search_index][link_from] ? link_from : -1;
                               :    for(unsigned int i = 1; i < path->nodePath.size(); i++) {
                               :        int link_to = path->nodePath[i];
                               :        if(conditions_bits[search_index][link_to]) {
                               :            if(arrive[-1] != -1) {
                               :                arrive[link_to] = arrive[-1];
                               :            }
                               :            arrive[-1] = link_to;
                               :        }
                               :    }
                               :    /*if(arrive[-1] != -1) {
                               :        arrive[path->endPoint] = arrive[-1];
                               :    }*/
                               :    for(ObstructTable::iterator iter = obstruct.begin(); iter != obstruct.end(); iter++) {
                               :        unsigned int index;
                               :        for(index = 0; index < iter->second.size(); index++) {
                               :            std::unordered_map<int, int>::iterator arrive_iter = arrive.find(iter->second[index]);
                               :            if(arrive_iter == arrive.end() || arrive_iter->second == iter->first) {
                               :                break;
                               :            }
                               :        }
                               :        if(index >= iter->second.size()) {
                               :            return false;
                               :        }
                               :    }
                               :    return true;
                               :}
                               :
    19  0.0162     0       0   :bool isDuplicate(Path* path, std::vector<Path*> & paths) {
  1137  0.9673     0       0   :    for(unsigned int path_index = 0; path_index < paths.size(); path_index++) {
   108  0.0919     0       0   :        if(path->pathCost != paths[path_index]->pathCost) {
                               :            continue;
                               :        }
                               :    	if(*path == *paths[path_index]) {
                               :    		return true;
                               :    	}
                               :    }
                               :    return false;
                               :}
                               :
                               :/*bool isLoopless(Path* path_1, Path* path_2) {
                               :    if((path_1->bitPath & path_2->bitPath) == zero_bitset)
                               :    	return true;
                               :    return false;
                               :}*/
                               :
                               :void GLG() { /* GLG() total:   4228  3.5971   401 23.6858 */
                               :    DpTable dp; // 动态规划表   <迭代次数，<起始点，路径的优先队列（权重从小到大）>>
                               :    DistanceTable distance, ToDest;  //s到V‘中所有点，V‘中所有点间，V‘中所有点到t的K条路(权重从小到大)
                               :    DirectArrive direct_arrive(MAX_VERTEX, std::vector<bool>(MAX_VERTEX, false));
                               :    ObstructTable obstruct;
                               :
                               :    //求每个点间的K条路径
                               :    get_shortest_path(dest, ToDest);
                               :    for(Conditions::iterator iter = conditions[search_index].begin(); iter != conditions[search_index].end(); iter++) {
                               :        get_shortest_path(*iter, distance);
                               :        get_BFS_path(*iter, distance, ToDest);
                               :        get_arrive_info(*iter, direct_arrive, obstruct);
                               :    }
                               :    for(Conditions::iterator iter = conditions[search_index].begin(); iter != conditions[search_index].end(); iter++) {
                               :        stable_sort(distance[*iter].begin(), distance[*iter].end(), path_cmp);
                               :    }
                               :
                               :    //Path empty;
                               :    //return empty;
                               :
                               :    //填动态规划表
                               :    for(unsigned int iter_count = 0; iter_count < conditions[search_index].size(); iter_count++) {
     1 8.5e-04     0       0   :        for(Conditions::iterator iter_src = conditions[search_index].begin(); iter_src != conditions[search_index].end(); iter_src++) {
                               :            if(!iter_count && direct_arrive[*iter_src][dest]) {
     2  0.0017     0       0   :                dp[0][*iter_src] = ToDest[*iter_src];
                               :                stable_sort(dp[0][*iter_src].begin(), dp[0][*iter_src].end(), path_cmp);
                               :            }
                               :            if(iter_count > 0) {
     6  0.0051     1  0.0591   :                fill_dp(iter_count, *iter_src, dp, distance, direct_arrive, obstruct);
    10  0.0085     0       0   :                stable_sort(dp[iter_count][*iter_src].begin(), dp[iter_count][*iter_src].end(), path_cmp);
                               :            }
                               :        }
     1 8.5e-04     0       0   :        for(Conditions::iterator iter_src = conditions[search_index].begin(); iter_src != conditions[search_index].end(); iter_src++) {
     1 8.5e-04     0       0   :            PathQueue path_queue = dp[iter_count][*iter_src];
     7  0.0060     0       0   :            for(unsigned int i = 0; i < path_queue.size(); i++) {
    11  0.0094     0       0   :                bitpath_table[iter_count][*iter_src].push_back(path_queue[i]->bitPath);
                               :            }
                               :        }
                               :    }
                               :
                               :    /*FILE *fp = fopen("./dp.txt", "w+");
                               :    for(unsigned int iter_count = 0; iter_count < conditions.size(); iter_count++) {
                               :        int sum = 0;
                               :        for(Conditions::iterator iter_src = conditions.begin(); iter_src != conditions.end(); iter_src++) {
                               :            sum += dp[iter_count][*iter_src].size();
                               :        }
                               :        fprintf(fp, "iter_count = %d, size = %d\n", iter_count, sum);
                               :    }
                               :    fclose(fp);
                               :
                               :    fp = fopen("./distance.txt", "w+");
                               :    for(Conditions::iterator iter = conditions.begin(); iter != conditions.end(); iter++) {
                               :        fprintf(fp, "%d %d\n", *iter, distance[*iter].size());
                               :    }
                               :    fclose(fp);*/
                               :
                               :    //求取最小结果
                               :    get_result(dp);
                               :}
/* 
 * Total samples for file : "/usr/include/c++/4.8/bits/hashtable.h"
 * 
 *   5984  5.0911   164  9.6869
 */


                               :// hashtable.h header -*- C++ -*-
                               :
                               :// Copyright (C) 2007-2013 Free Software Foundation, Inc.
                               ://
                               :// This file is part of the GNU ISO C++ Library.  This library is free
                               :// software; you can redistribute it and/or modify it under the
                               :// terms of the GNU General Public License as published by the
                               :// Free Software Foundation; either version 3, or (at your option)
                               :// any later version.
                               :
                               :// This library is distributed in the hope that it will be useful,
                               :// but WITHOUT ANY WARRANTY; without even the implied warranty of
                               :// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                               :// GNU General Public License for more details.
                               :
                               :// Under Section 7 of GPL version 3, you are granted additional
                               :// permissions described in the GCC Runtime Library Exception, version
                               :// 3.1, as published by the Free Software Foundation.
                               :
                               :// You should have received a copy of the GNU General Public License and
                               :// a copy of the GCC Runtime Library Exception along with this program;
                               :// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                               :// <http://www.gnu.org/licenses/>.
                               :
                               :/** @file bits/hashtable.h
                               : *  This is an internal header file, included by other library headers.
                               : *  Do not attempt to use it directly. @headername{unordered_map, unordered_set}
                               : */
                               :
                               :#ifndef _HASHTABLE_H
                               :#define _HASHTABLE_H 1
                               :
                               :#pragma GCC system_header
                               :
                               :#include <bits/hashtable_policy.h>
                               :
                               :namespace std _GLIBCXX_VISIBILITY(default)
                               :{
                               :_GLIBCXX_BEGIN_NAMESPACE_VERSION
                               :
                               :  template<typename _Tp, typename _Hash>
                               :    using __cache_default
                               :      =  __not_<__and_<// Do not cache for fast hasher.
                               :		       __is_fast_hash<_Hash>,
                               :		       // Mandatory to make local_iterator default
                               :		       // constructible and assignable.
                               :		       is_default_constructible<_Hash>,
                               :		       is_copy_assignable<_Hash>,
                               :		       // Mandatory to have erase not throwing.
                               :		       __detail::__is_noexcept_hash<_Tp, _Hash>>>;
                               :
                               :  /**
                               :   *  Primary class template _Hashtable.
                               :   *
                               :   *  @ingroup hashtable-detail
                               :   *
                               :   *  @tparam _Value  CopyConstructible type.
                               :   *
                               :   *  @tparam _Key    CopyConstructible type.
                               :   *
                               :   *  @tparam _Alloc  An allocator type
                               :   *  ([lib.allocator.requirements]) whose _Alloc::value_type is
                               :   *  _Value.  As a conforming extension, we allow for
                               :   *  _Alloc::value_type != _Value.
                               :   *
                               :   *  @tparam _ExtractKey  Function object that takes an object of type
                               :   *  _Value and returns a value of type _Key.
                               :   *
                               :   *  @tparam _Equal  Function object that takes two objects of type k
                               :   *  and returns a bool-like value that is true if the two objects
                               :   *  are considered equal.
                               :   *
                               :   *  @tparam _H1  The hash function. A unary function object with
                               :   *  argument type _Key and result type size_t. Return values should
                               :   *  be distributed over the entire range [0, numeric_limits<size_t>:::max()].
                               :   *
                               :   *  @tparam _H2  The range-hashing function (in the terminology of
                               :   *  Tavori and Dreizin).  A binary function object whose argument
                               :   *  types and result type are all size_t.  Given arguments r and N,
                               :   *  the return value is in the range [0, N).
                               :   *
                               :   *  @tparam _Hash  The ranged hash function (Tavori and Dreizin). A
                               :   *  binary function whose argument types are _Key and size_t and
                               :   *  whose result type is size_t.  Given arguments k and N, the
                               :   *  return value is in the range [0, N).  Default: hash(k, N) =
                               :   *  h2(h1(k), N).  If _Hash is anything other than the default, _H1
                               :   *  and _H2 are ignored.
                               :   *
                               :   *  @tparam _RehashPolicy  Policy class with three members, all of
                               :   *  which govern the bucket count. _M_next_bkt(n) returns a bucket
                               :   *  count no smaller than n.  _M_bkt_for_elements(n) returns a
                               :   *  bucket count appropriate for an element count of n.
                               :   *  _M_need_rehash(n_bkt, n_elt, n_ins) determines whether, if the
                               :   *  current bucket count is n_bkt and the current element count is
                               :   *  n_elt, we need to increase the bucket count.  If so, returns
                               :   *  make_pair(true, n), where n is the new bucket count.  If not,
                               :   *  returns make_pair(false, <anything>)
                               :   *
                               :   *  @tparam _Traits  Compile-time class with three boolean
                               :   *  std::integral_constant members:  __cache_hash_code, __constant_iterators,
                               :   *   __unique_keys.
                               :   *
                               :   *  Each _Hashtable data structure has:
                               :   *
                               :   *  - _Bucket[]       _M_buckets
                               :   *  - _Hash_node_base _M_bbegin
                               :   *  - size_type       _M_bucket_count
                               :   *  - size_type       _M_element_count
                               :   *
                               :   *  with _Bucket being _Hash_node* and _Hash_node containing:
                               :   *
                               :   *  - _Hash_node*   _M_next
                               :   *  - Tp            _M_value
                               :   *  - size_t        _M_hash_code if cache_hash_code is true
                               :   *
                               :   *  In terms of Standard containers the hashtable is like the aggregation of:
                               :   *
                               :   *  - std::forward_list<_Node> containing the elements
                               :   *  - std::vector<std::forward_list<_Node>::iterator> representing the buckets
                               :   *
                               :   *  The non-empty buckets contain the node before the first node in the
                               :   *  bucket. This design makes it possible to implement something like a
                               :   *  std::forward_list::insert_after on container insertion and
                               :   *  std::forward_list::erase_after on container erase
                               :   *  calls. _M_before_begin is equivalent to
                               :   *  std::forward_list::before_begin. Empty buckets contain
                               :   *  nullptr.  Note that one of the non-empty buckets contains
                               :   *  &_M_before_begin which is not a dereferenceable node so the
                               :   *  node pointer in a bucket shall never be dereferenced, only its
                               :   *  next node can be.
                               :   *
                               :   *  Walking through a bucket's nodes requires a check on the hash code to
                               :   *  see if each node is still in the bucket. Such a design assumes a
                               :   *  quite efficient hash functor and is one of the reasons it is
                               :   *  highly advisable to set __cache_hash_code to true.
                               :   *
                               :   *  The container iterators are simply built from nodes. This way
                               :   *  incrementing the iterator is perfectly efficient independent of
                               :   *  how many empty buckets there are in the container.
                               :   *
                               :   *  On insert we compute the element's hash code and use it to find the
                               :   *  bucket index. If the element must be inserted in an empty bucket
                               :   *  we add it at the beginning of the singly linked list and make the
                               :   *  bucket point to _M_before_begin. The bucket that used to point to
                               :   *  _M_before_begin, if any, is updated to point to its new before
                               :   *  begin node.
                               :   *
                               :   *  On erase, the simple iterator design requires using the hash
                               :   *  functor to get the index of the bucket to update. For this
                               :   *  reason, when __cache_hash_code is set to false the hash functor must
                               :   *  not throw and this is enforced by a static assertion.
                               :   *
                               :   *  Functionality is implemented by decomposition into base classes,
                               :   *  where the derived _Hashtable class is used in _Map_base,
                               :   *  _Insert, _Rehash_base, and _Equality base classes to access the
                               :   *  "this" pointer. _Hashtable_base is used in the base classes as a
                               :   *  non-recursive, fully-completed-type so that detailed nested type
                               :   *  information, such as iterator type and node type, can be
                               :   *  used. This is similar to the "Curiously Recurring Template
                               :   *  Pattern" (CRTP) technique, but uses a reconstructed, not
                               :   *  explicitly passed, template pattern.
                               :   *
                               :   *  Base class templates are: 
                               :   *    - __detail::_Hashtable_base
                               :   *    - __detail::_Map_base
                               :   *    - __detail::_Insert
                               :   *    - __detail::_Rehash_base
                               :   *    - __detail::_Equality
                               :   */
                               :  template<typename _Key, typename _Value, typename _Alloc,
                               :	   typename _ExtractKey, typename _Equal,
                               :	   typename _H1, typename _H2, typename _Hash,
                               :	   typename _RehashPolicy, typename _Traits>
                               :    class _Hashtable
                               :    : public __detail::_Hashtable_base<_Key, _Value, _ExtractKey, _Equal,
                               :				       _H1, _H2, _Hash, _Traits>,
                               :      public __detail::_Map_base<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                               :				 _H1, _H2, _Hash, _RehashPolicy, _Traits>,
                               :      public __detail::_Insert<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                               :			       _H1, _H2, _Hash, _RehashPolicy, _Traits>,
                               :      public __detail::_Rehash_base<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                               :				    _H1, _H2, _Hash, _RehashPolicy, _Traits>,
                               :      public __detail::_Equality<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                               :				 _H1, _H2, _Hash, _RehashPolicy, _Traits>
                               :    {
                               :    public:
                               :      typedef _Key                                    key_type;
                               :      typedef _Value                                  value_type;
                               :      typedef _Alloc                                  allocator_type;
                               :      typedef _Equal                                  key_equal;
                               :
                               :      // mapped_type, if present, comes from _Map_base.
                               :      // hasher, if present, comes from _Hash_code_base/_Hashtable_base.
                               :      typedef typename _Alloc::pointer		      pointer;
                               :      typedef typename _Alloc::const_pointer          const_pointer;
                               :      typedef typename _Alloc::reference              reference;
                               :      typedef typename _Alloc::const_reference        const_reference;
                               :
                               :    private:
                               :      using __rehash_type = _RehashPolicy;
                               :      using __rehash_state = typename __rehash_type::_State;
                               :
                               :      using __traits_type = _Traits;
                               :      using __hash_cached = typename __traits_type::__hash_cached;
                               :      using __constant_iterators = typename __traits_type::__constant_iterators;
                               :      using __unique_keys = typename __traits_type::__unique_keys;
                               :
                               :      using __key_extract = typename std::conditional<
                               :					     __constant_iterators::value,
                               :				       	     __detail::_Identity,
                               :					     __detail::_Select1st>::type;
                               :
                               :      using __hashtable_base = __detail::
                               :			       _Hashtable_base<_Key, _Value, _ExtractKey,
                               :					      _Equal, _H1, _H2, _Hash, _Traits>;
                               :
                               :      using __hash_code_base =  typename __hashtable_base::__hash_code_base;
                               :      using __hash_code =  typename __hashtable_base::__hash_code;
                               :      using __node_type = typename __hashtable_base::__node_type;
                               :      using __node_base = typename __hashtable_base::__node_base;
                               :      using __bucket_type = typename __hashtable_base::__bucket_type;
                               :      using __ireturn_type = typename __hashtable_base::__ireturn_type;
                               :      using __iconv_type = typename __hashtable_base::__iconv_type;
                               :
                               :      using __map_base = __detail::_Map_base<_Key, _Value, _Alloc, _ExtractKey,
                               :					     _Equal, _H1, _H2, _Hash,
                               :					     _RehashPolicy, _Traits>;
                               :
                               :      using __rehash_base = __detail::_Rehash_base<_Key, _Value, _Alloc,
                               :						   _ExtractKey, _Equal,
                               :						   _H1, _H2, _Hash,
                               :						   _RehashPolicy, _Traits>;
                               :
                               :      using __eq_base = __detail::_Equality<_Key, _Value, _Alloc, _ExtractKey,
                               :					    _Equal, _H1, _H2, _Hash,
                               :					    _RehashPolicy, _Traits>;
                               :
                               :      // Metaprogramming for picking apart hash caching.
                               :      using __hash_noexcept = __detail::__is_noexcept_hash<_Key, _H1>;
                               :
                               :      template<typename _Cond>
                               :	using __if_hash_cached = __or_<__not_<__hash_cached>, _Cond>;
                               :
                               :      template<typename _Cond>
                               :	using __if_hash_not_cached = __or_<__hash_cached, _Cond>;
                               :
                               :      // Compile-time diagnostics.
                               :
                               :      // When hash codes are not cached the hash functor shall not
                               :      // throw because it is used in methods (erase, swap...) that
                               :      // shall not throw.
                               :      static_assert(__if_hash_not_cached<__hash_noexcept>::value,
                               :		    "Cache the hash code"
                               :		    " or qualify your hash functor with noexcept");
                               :
                               :      // Following two static assertions are necessary to guarantee
                               :      // that local_iterator will be default constructible.
                               :
                               :      // When hash codes are cached local iterator inherits from H2 functor
                               :      // which must then be default constructible.
                               :      static_assert(__if_hash_cached<is_default_constructible<_H2>>::value,
                               :		    "Functor used to map hash code to bucket index"
                               :		    " must be default constructible");
                               :
                               :      // When hash codes are not cached local iterator inherits from
                               :      // __hash_code_base above to compute node bucket index so it has to be
                               :      // default constructible.
                               :      static_assert(__if_hash_not_cached<
                               :		    is_default_constructible<
                               :		      // We use _Hashtable_ebo_helper to access the protected
                               :		      // default constructor.
                               :		      __detail::_Hashtable_ebo_helper<0, __hash_code_base>>>::value,
                               :		    "Cache the hash code or make functors involved in hash code"
                               :		    " and bucket index computation default constructible");
                               :
                               :      // When hash codes are not cached local iterator inherits from
                               :      // __hash_code_base above to compute node bucket index so it has to be
                               :      // assignable.
                               :      static_assert(__if_hash_not_cached<
                               :		      is_copy_assignable<__hash_code_base>>::value,
                               :		    "Cache the hash code or make functors involved in hash code"
                               :		    " and bucket index computation copy assignable");
                               :
                               :    public:
                               :      template<typename _Keya, typename _Valuea, typename _Alloca,
                               :	       typename _ExtractKeya, typename _Equala,
                               :	       typename _H1a, typename _H2a, typename _Hasha,
                               :	       typename _RehashPolicya, typename _Traitsa,
                               :	       bool _Unique_keysa>
                               :	friend struct __detail::_Map_base;
                               :
                               :      template<typename _Keya, typename _Valuea, typename _Alloca,
                               :	       typename _ExtractKeya, typename _Equala,
                               :	       typename _H1a, typename _H2a, typename _Hasha,
                               :	       typename _RehashPolicya, typename _Traitsa>
                               :	friend struct __detail::_Insert_base;
                               :
                               :      template<typename _Keya, typename _Valuea, typename _Alloca,
                               :	       typename _ExtractKeya, typename _Equala,
                               :	       typename _H1a, typename _H2a, typename _Hasha,
                               :	       typename _RehashPolicya, typename _Traitsa,
                               :	       bool _Constant_iteratorsa, bool _Unique_keysa>
                               :	friend struct __detail::_Insert;
                               :
                               :      using size_type = typename __hashtable_base::size_type;
                               :      using difference_type = typename __hashtable_base::difference_type;
                               :
                               :      using iterator = typename __hashtable_base::iterator;
                               :      using const_iterator = typename __hashtable_base::const_iterator;
                               :
                               :      using local_iterator = typename __hashtable_base::local_iterator;
                               :      using const_local_iterator = typename __hashtable_base::
                               :				   const_local_iterator;
                               :
                               :    private:
                               :      typedef typename _Alloc::template rebind<__node_type>::other
                               :							_Node_allocator_type;
                               :      typedef typename _Alloc::template rebind<__bucket_type>::other
                               :							_Bucket_allocator_type;
                               :
                               :      using __before_begin = __detail::_Before_begin<_Node_allocator_type>;
                               :
                               :      __bucket_type*		_M_buckets;
                               :      size_type			_M_bucket_count;
                               :      __before_begin		_M_bbegin;
                               :      size_type			_M_element_count;
                               :      _RehashPolicy		_M_rehash_policy;
                               :
                               :      _Node_allocator_type&
                               :      _M_node_allocator()
                               :      { return _M_bbegin; }
                               :
                               :      const _Node_allocator_type&
                               :      _M_node_allocator() const
                               :      { return _M_bbegin; }
                               :
                               :      __node_base&
                               :      _M_before_begin()
                               :      { return _M_bbegin._M_node; }
                               :
                               :      const __node_base&
                               :      _M_before_begin() const
                               :      { return _M_bbegin._M_node; }
                               :
                               :      template<typename... _Args>
                               :	__node_type*
                               :	_M_allocate_node(_Args&&... __args);
                               :
                               :      void
                               :      _M_deallocate_node(__node_type* __n);
                               :
                               :      // Deallocate the linked list of nodes pointed to by __n
                               :      void
                               :      _M_deallocate_nodes(__node_type* __n);
                               :
                               :      __bucket_type*
                               :      _M_allocate_buckets(size_type __n);
                               :
                               :      void
                               :      _M_deallocate_buckets(__bucket_type*, size_type __n);
                               :
                               :      // Gets bucket begin, deals with the fact that non-empty buckets contain
                               :      // their before begin node.
                               :      __node_type*
                               :      _M_bucket_begin(size_type __bkt) const;
                               :
                               :      __node_type*
                               :      _M_begin() const
     1 8.5e-04     0       0   :      { return static_cast<__node_type*>(_M_before_begin()._M_nxt); }
                               :
                               :    public:
                               :      // Constructor, destructor, assignment, swap
                               :      _Hashtable(size_type __bucket_hint,
                               :		 const _H1&, const _H2&, const _Hash&,
                               :		 const _Equal&, const _ExtractKey&,
                               :		 const allocator_type&);
                               :
                               :      template<typename _InputIterator>
                               :	_Hashtable(_InputIterator __first, _InputIterator __last,
                               :		   size_type __bucket_hint,
                               :		   const _H1&, const _H2&, const _Hash&,
                               :		   const _Equal&, const _ExtractKey&,
                               :		   const allocator_type&);
                               :
                               :      _Hashtable(const _Hashtable&);
                               :
                               :      _Hashtable(_Hashtable&&);
                               :
                               :      // Use delegating constructors.
                               :      explicit
                               :      _Hashtable(size_type __n = 10,
                               :		 const _H1& __hf = _H1(),
                               :		 const key_equal& __eql = key_equal(),
                               :		 const allocator_type& __a = allocator_type())
                               :      : _Hashtable(__n, __hf, __detail::_Mod_range_hashing(),
                               :		   __detail::_Default_ranged_hash(), __eql,
                               :		   __key_extract(), __a)
                               :      { }
                               :
                               :      template<typename _InputIterator>
                               :	_Hashtable(_InputIterator __f, _InputIterator __l,
                               :		   size_type __n = 0,
                               :		   const _H1& __hf = _H1(),
                               :		   const key_equal& __eql = key_equal(),
                               :		   const allocator_type& __a = allocator_type())
                               :	: _Hashtable(__f, __l, __n, __hf, __detail::_Mod_range_hashing(),
                               :		     __detail::_Default_ranged_hash(), __eql,
                               :		     __key_extract(), __a)
                               :	{ }
                               :
                               :      _Hashtable(initializer_list<value_type> __l,
                               :		 size_type __n = 0,
                               :		 const _H1& __hf = _H1(),
                               :		 const key_equal& __eql = key_equal(),
                               :		 const allocator_type& __a = allocator_type())
                               :      : _Hashtable(__l.begin(), __l.end(), __n, __hf,
                               :		   __detail::_Mod_range_hashing(),
                               :		   __detail::_Default_ranged_hash(), __eql,
                               :		   __key_extract(), __a)
                               :      { }
                               :
                               :      _Hashtable&
                               :      operator=(const _Hashtable& __ht)
                               :      {
                               :	_Hashtable __tmp(__ht);
                               :	this->swap(__tmp);
                               :	return *this;
                               :      }
                               :
                               :      _Hashtable&
                               :      operator=(_Hashtable&& __ht)
                               :      {
                               :	// NB: DR 1204.
                               :	// NB: DR 675.
                               :	this->clear();
                               :	this->swap(__ht);
                               :	return *this;
                               :      }
                               :
                               :      _Hashtable&
                               :      operator=(initializer_list<value_type> __l)
                               :      {
                               :	this->clear();
                               :	this->insert(__l.begin(), __l.end());
                               :	return *this;
                               :      }
                               :
                               :      ~_Hashtable() noexcept;
                               :
                               :      void swap(_Hashtable&);
                               :
                               :      // Basic container operations
                               :      iterator
                               :      begin() noexcept
                               :      { return iterator(_M_begin()); }
                               :
                               :      const_iterator
                               :      begin() const noexcept
                               :      { return const_iterator(_M_begin()); }
                               :
                               :      iterator
                               :      end() noexcept
                               :      { return iterator(nullptr); }
                               :
                               :      const_iterator
                               :      end() const noexcept
                               :      { return const_iterator(nullptr); }
                               :
                               :      const_iterator
                               :      cbegin() const noexcept
                               :      { return const_iterator(_M_begin()); }
                               :
                               :      const_iterator
                               :      cend() const noexcept
                               :      { return const_iterator(nullptr); }
                               :
                               :      size_type
                               :      size() const noexcept
                               :      { return _M_element_count; }
                               :
                               :      bool
                               :      empty() const noexcept
                               :      { return size() == 0; }
                               :
                               :      allocator_type
                               :      get_allocator() const noexcept
                               :      { return allocator_type(_M_node_allocator()); }
                               :
                               :      size_type
                               :      max_size() const noexcept
                               :      { return _M_node_allocator().max_size(); }
                               :
                               :      // Observers
                               :      key_equal
                               :      key_eq() const
                               :      { return this->_M_eq(); }
                               :
                               :      // hash_function, if present, comes from _Hash_code_base.
                               :
                               :      // Bucket operations
                               :      size_type
                               :      bucket_count() const noexcept
                               :      { return _M_bucket_count; }
                               :
                               :      size_type
                               :      max_bucket_count() const noexcept
                               :      { return max_size(); }
                               :
                               :      size_type
                               :      bucket_size(size_type __n) const
                               :      { return std::distance(begin(__n), end(__n)); }
                               :
                               :      size_type
                               :      bucket(const key_type& __k) const
                               :      { return _M_bucket_index(__k, this->_M_hash_code(__k)); }
                               :
                               :      local_iterator
                               :      begin(size_type __n)
                               :      {
                               :	return local_iterator(*this, _M_bucket_begin(__n),
                               :			      __n, _M_bucket_count);
                               :      }
                               :
                               :      local_iterator
                               :      end(size_type __n)
                               :      { return local_iterator(*this, nullptr, __n, _M_bucket_count); }
                               :
                               :      const_local_iterator
                               :      begin(size_type __n) const
                               :      {
                               :	return const_local_iterator(*this, _M_bucket_begin(__n),
                               :				    __n, _M_bucket_count);
                               :      }
                               :
                               :      const_local_iterator
                               :      end(size_type __n) const
                               :      { return const_local_iterator(*this, nullptr, __n, _M_bucket_count); }
                               :
                               :      // DR 691.
                               :      const_local_iterator
                               :      cbegin(size_type __n) const
                               :      {
                               :	return const_local_iterator(*this, _M_bucket_begin(__n),
                               :				    __n, _M_bucket_count);
                               :      }
                               :
                               :      const_local_iterator
                               :      cend(size_type __n) const
                               :      { return const_local_iterator(*this, nullptr, __n, _M_bucket_count); }
                               :
                               :      float
                               :      load_factor() const noexcept
                               :      {
                               :	return static_cast<float>(size()) / static_cast<float>(bucket_count());
                               :      }
                               :
                               :      // max_load_factor, if present, comes from _Rehash_base.
                               :
                               :      // Generalization of max_load_factor.  Extension, not found in
                               :      // TR1.  Only useful if _RehashPolicy is something other than
                               :      // the default.
                               :      const _RehashPolicy&
                               :      __rehash_policy() const
                               :      { return _M_rehash_policy; }
                               :
                               :      void
                               :      __rehash_policy(const _RehashPolicy&);
                               :
                               :      // Lookup.
                               :      iterator
                               :      find(const key_type& __k);
                               :
                               :      const_iterator
                               :      find(const key_type& __k) const;
                               :
                               :      size_type
                               :      count(const key_type& __k) const;
                               :
                               :      std::pair<iterator, iterator>
                               :      equal_range(const key_type& __k);
                               :
                               :      std::pair<const_iterator, const_iterator>
                               :      equal_range(const key_type& __k) const;
                               :
                               :    protected:
                               :      // Bucket index computation helpers.
                               :      size_type
     3  0.0026     0       0   :      _M_bucket_index(__node_type* __n) const
                               :      { return __hash_code_base::_M_bucket_index(__n, _M_bucket_count); }
                               :
                               :      size_type
                               :      _M_bucket_index(const key_type& __k, __hash_code __c) const
                               :      { return __hash_code_base::_M_bucket_index(__k, __c, _M_bucket_count); }
                               :
                               :      // Find and insert helper functions and types
                               :      // Find the node before the one matching the criteria.
                               :      __node_base*
                               :      _M_find_before_node(size_type, const key_type&, __hash_code) const;
                               :
                               :      __node_type*
                               :      _M_find_node(size_type __bkt, const key_type& __key,
                               :		   __hash_code __c) const
                               :      {
                               :	__node_base* __before_n = _M_find_before_node(__bkt, __key, __c);
                               :	if (__before_n)
    14  0.0119     0       0   :	  return static_cast<__node_type*>(__before_n->_M_nxt);
                               :	return nullptr;
                               :      }
                               :
                               :      // Insert a node at the beginning of a bucket.
                               :      void
                               :      _M_insert_bucket_begin(size_type, __node_type*);
                               :
                               :      // Remove the bucket first node
                               :      void
                               :      _M_remove_bucket_begin(size_type __bkt, __node_type* __next_n,
                               :			     size_type __next_bkt);
                               :
                               :      // Get the node before __n in the bucket __bkt
                               :      __node_base*
                               :      _M_get_previous_node(size_type __bkt, __node_base* __n);
                               :
                               :      // Insert node with hash code __code, in bucket bkt if no rehash (assumes
                               :      // no element with its key already present). Take ownership of the node,
                               :      // deallocate it on exception.
                               :      iterator
                               :      _M_insert_unique_node(size_type __bkt, __hash_code __code,
                               :			    __node_type* __n);
                               :
                               :      // Insert node with hash code __code. Take ownership of the node,
                               :      // deallocate it on exception.
                               :      iterator
                               :      _M_insert_multi_node(__hash_code __code, __node_type* __n);
                               :
                               :      template<typename... _Args>
                               :	std::pair<iterator, bool>
                               :	_M_emplace(std::true_type, _Args&&... __args);
                               :
                               :      template<typename... _Args>
                               :	iterator
                               :	_M_emplace(std::false_type, _Args&&... __args);
                               :
                               :      template<typename _Arg>
                               :	std::pair<iterator, bool>
                               :	_M_insert(_Arg&&, std::true_type);
                               :
                               :      template<typename _Arg>
                               :	iterator
                               :	_M_insert(_Arg&&, std::false_type);
                               :
                               :      size_type
                               :      _M_erase(std::true_type, const key_type&);
                               :
                               :      size_type
                               :      _M_erase(std::false_type, const key_type&);
                               :
                               :      iterator
                               :      _M_erase(size_type __bkt, __node_base* __prev_n, __node_type* __n);
                               :
                               :    public:
                               :      // Emplace
                               :      template<typename... _Args>
                               :	__ireturn_type
                               :	emplace(_Args&&... __args)
                               :	{ return _M_emplace(__unique_keys(), std::forward<_Args>(__args)...); }
                               :
                               :      template<typename... _Args>
                               :	iterator
                               :	emplace_hint(const_iterator, _Args&&... __args)
                               :	{ return __iconv_type()(emplace(std::forward<_Args>(__args)...)); }
                               :
                               :      // Insert member functions via inheritance.
                               :
                               :      // Erase
                               :      iterator
                               :      erase(const_iterator);
                               :
                               :      // LWG 2059.
                               :      iterator
                               :      erase(iterator __it)
                               :      { return erase(const_iterator(__it)); }
                               :
                               :      size_type
                               :      erase(const key_type& __k)
                               :      { return _M_erase(__unique_keys(), __k); }
                               :
                               :      iterator
                               :      erase(const_iterator, const_iterator);
                               :
                               :      void
                               :      clear() noexcept;
                               :
                               :      // Set number of buckets to be appropriate for container of n element.
                               :      void rehash(size_type __n);
                               :
                               :      // DR 1189.
                               :      // reserve, if present, comes from _Rehash_base.
                               :
                               :    private:
                               :      // Helper rehash method used when keys are unique.
                               :      void _M_rehash_aux(size_type __n, std::true_type);
                               :
                               :      // Helper rehash method used when keys can be non-unique.
                               :      void _M_rehash_aux(size_type __n, std::false_type);
                               :
                               :      // Unconditionally change size of bucket array to n, restore
                               :      // hash policy state to __state on exception.
                               :      void _M_rehash(size_type __n, const __rehash_state& __state);
                               :    };
                               :
                               :
                               :  // Definitions of class template _Hashtable's out-of-line member functions.
                               :  template<typename _Key, typename _Value,
                               :	   typename _Alloc, typename _ExtractKey, typename _Equal,
                               :	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
                               :	   typename _Traits>
                               :    template<typename... _Args>
                               :      typename _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                               :			  _H1, _H2, _Hash, _RehashPolicy, _Traits>::__node_type*
     2  0.0017     0       0   :      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, /* std::__detail::_Hash_node<std::pair<int const, std::unordered_map<int, std::vector<Path*, std::allocator<Path*> >, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<int const, std::vector<Path*, std::allocator<Path*> > > > > >, false>* std::_Hashtable<int, std::pair<int const, std::unordered_map<int, std::vector<Path*, std::allocator<Path*> >, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<int const, std::vector<Path*, std::allocator<Path*> > > > > >, std::allocator<std::pair<int const, std::unordered_map<int, std::vector<Path*, std::allocator<Path*> >, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<int const, std::vector<Path*, std::allocator<Path*> > > > > > >, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true> >::_M_allocate_node<std::piecewise_construct_t const&, std::tuple<int const&>, std::tuple<> >(std::piecewise_construct_t const&, std::tuple<int const&>&&, std::tuple<>&&) total:      2  0.0017     0       0 */
                               :		 _H1, _H2, _Hash, _RehashPolicy, _Traits>::
                               :      _M_allocate_node(_Args&&... __args)
                               :      {
                               :	__node_type* __n = _M_node_allocator().allocate(1);
                               :	__try
                               :	  {
                               :	    _M_node_allocator().construct(__n, std::forward<_Args>(__args)...);
                               :	    return __n;
                               :	  }
                               :	__catch(...)
                               :	  {
                               :	    _M_node_allocator().deallocate(__n, 1);
                               :	    __throw_exception_again;
                               :	  }
                               :      }
                               :
                               :  template<typename _Key, typename _Value,
                               :	   typename _Alloc, typename _ExtractKey, typename _Equal,
                               :	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
                               :	   typename _Traits>
                               :    void
                               :    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                               :	       _H1, _H2, _Hash, _RehashPolicy, _Traits>::
                               :    _M_deallocate_node(__node_type* __n)
                               :    {
                               :      _M_node_allocator().destroy(__n);
                               :      _M_node_allocator().deallocate(__n, 1);
                               :    }
                               :
                               :  template<typename _Key, typename _Value,
                               :	   typename _Alloc, typename _ExtractKey, typename _Equal,
                               :	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
                               :	   typename _Traits>
                               :    void
                               :    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                               :	       _H1, _H2, _Hash, _RehashPolicy, _Traits>::
   225  0.1914     9  0.5316   :    _M_deallocate_nodes(__node_type* __n)
                               :    {
     3  0.0026     0       0   :      while (__n)
                               :	{
                               :	  __node_type* __tmp = __n;
     2  0.0017     1  0.0591   :	  __n = __n->_M_next();
                               :	  _M_deallocate_node(__tmp);
                               :	}
                               :    }
                               :
                               :  template<typename _Key, typename _Value,
                               :	   typename _Alloc, typename _ExtractKey, typename _Equal,
                               :	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
                               :	   typename _Traits>
                               :    typename _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                               :			_H1, _H2, _Hash, _RehashPolicy, _Traits>::__bucket_type*
                               :    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                               :	       _H1, _H2, _Hash, _RehashPolicy, _Traits>::
                               :    _M_allocate_buckets(size_type __n)
                               :    {
                               :      _Bucket_allocator_type __alloc(_M_node_allocator());
                               :
                               :      __bucket_type* __p = __alloc.allocate(__n);
                               :      __builtin_memset(__p, 0, __n * sizeof(__bucket_type));
                               :      return __p;
                               :    }
                               :
                               :  template<typename _Key, typename _Value,
                               :	   typename _Alloc, typename _ExtractKey, typename _Equal,
                               :	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
                               :	   typename _Traits>
                               :    void
                               :    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                               :	       _H1, _H2, _Hash, _RehashPolicy, _Traits>::
                               :    _M_deallocate_buckets(__bucket_type* __p, size_type __n)
                               :    {
                               :      _Bucket_allocator_type __alloc(_M_node_allocator());
                               :      __alloc.deallocate(__p, __n);
                               :    }
                               :
                               :  template<typename _Key, typename _Value,
                               :	   typename _Alloc, typename _ExtractKey, typename _Equal,
                               :	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
                               :	   typename _Traits>
                               :    typename _Hashtable<_Key, _Value, _Alloc, _ExtractKey,
                               :			_Equal, _H1, _H2, _Hash, _RehashPolicy,
                               :			_Traits>::__node_type*
                               :    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                               :	       _H1, _H2, _Hash, _RehashPolicy, _Traits>::
                               :    _M_bucket_begin(size_type __bkt) const
                               :    {
                               :      __node_base* __n = _M_buckets[__bkt];
                               :      return __n ? static_cast<__node_type*>(__n->_M_nxt) : nullptr;
                               :    }
                               :
                               :  template<typename _Key, typename _Value,
                               :	   typename _Alloc, typename _ExtractKey, typename _Equal,
                               :	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
                               :	   typename _Traits>
                               :    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                               :	       _H1, _H2, _Hash, _RehashPolicy, _Traits>::
                               :    _Hashtable(size_type __bucket_hint,
                               :	       const _H1& __h1, const _H2& __h2, const _Hash& __h,
                               :	       const _Equal& __eq, const _ExtractKey& __exk,
                               :	       const allocator_type& __a)
                               :    : __hashtable_base(__exk, __h1, __h2, __h, __eq),
                               :      __map_base(),
                               :      __rehash_base(),
                               :      _M_bucket_count(0),
                               :      _M_bbegin(__a),
                               :      _M_element_count(0),
                               :      _M_rehash_policy()
                               :    {
                               :      _M_bucket_count = _M_rehash_policy._M_next_bkt(__bucket_hint);
                               :      _M_buckets = _M_allocate_buckets(_M_bucket_count);
                               :    }
                               :
                               :  template<typename _Key, typename _Value,
                               :	   typename _Alloc, typename _ExtractKey, typename _Equal,
                               :	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
                               :	   typename _Traits>
                               :    template<typename _InputIterator>
                               :      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                               :		 _H1, _H2, _Hash, _RehashPolicy, _Traits>::
                               :      _Hashtable(_InputIterator __f, _InputIterator __l,
                               :		 size_type __bucket_hint,
                               :		 const _H1& __h1, const _H2& __h2, const _Hash& __h,
                               :		 const _Equal& __eq, const _ExtractKey& __exk,
                               :		 const allocator_type& __a)
                               :      : __hashtable_base(__exk, __h1, __h2, __h, __eq),
                               :	__map_base(),
                               :	__rehash_base(),
                               :	_M_bucket_count(0),
                               :	_M_bbegin(__a),
                               :	_M_element_count(0),
                               :	_M_rehash_policy()
                               :      {
                               :	auto __nb_elems = __detail::__distance_fw(__f, __l);
                               :	_M_bucket_count =
                               :	  _M_rehash_policy._M_next_bkt(
                               :	    std::max(_M_rehash_policy._M_bkt_for_elements(__nb_elems),
                               :		     __bucket_hint));
                               :
                               :	_M_buckets = _M_allocate_buckets(_M_bucket_count);
                               :	__try
                               :	  {
                               :	    for (; __f != __l; ++__f)
                               :	      this->insert(*__f);
                               :	  }
                               :	__catch(...)
                               :	  {
                               :	    clear();
                               :	    _M_deallocate_buckets(_M_buckets, _M_bucket_count);
                               :	    __throw_exception_again;
                               :	  }
                               :      }
                               :
                               :  template<typename _Key, typename _Value,
                               :	   typename _Alloc, typename _ExtractKey, typename _Equal,
                               :	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
                               :	   typename _Traits>
                               :    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                               :	       _H1, _H2, _Hash, _RehashPolicy, _Traits>::
                               :    _Hashtable(const _Hashtable& __ht)
                               :    : __hashtable_base(__ht),
                               :      __map_base(__ht),
                               :      __rehash_base(__ht),
                               :      _M_bucket_count(__ht._M_bucket_count),
                               :      _M_bbegin(__ht._M_bbegin),
                               :      _M_element_count(__ht._M_element_count),
                               :      _M_rehash_policy(__ht._M_rehash_policy)
                               :    {
                               :      _M_buckets = _M_allocate_buckets(_M_bucket_count);
                               :      __try
                               :	{
                               :	  if (!__ht._M_before_begin()._M_nxt)
                               :	    return;
                               :
                               :	  // First deal with the special first node pointed to by
                               :	  // _M_before_begin.
                               :	  const __node_type* __ht_n = __ht._M_begin();
                               :	  __node_type* __this_n = _M_allocate_node(__ht_n->_M_v);
                               :	  this->_M_copy_code(__this_n, __ht_n);
                               :	  _M_before_begin()._M_nxt = __this_n;
                               :	  _M_buckets[_M_bucket_index(__this_n)] = &_M_before_begin();
                               :
                               :	  // Then deal with other nodes.
                               :	  __node_base* __prev_n = __this_n;
                               :	  for (__ht_n = __ht_n->_M_next(); __ht_n; __ht_n = __ht_n->_M_next())
                               :	    {
                               :	      __this_n = _M_allocate_node(__ht_n->_M_v);
                               :	      __prev_n->_M_nxt = __this_n;
                               :	      this->_M_copy_code(__this_n, __ht_n);
                               :	      size_type __bkt = _M_bucket_index(__this_n);
                               :	      if (!_M_buckets[__bkt])
                               :		_M_buckets[__bkt] = __prev_n;
                               :	      __prev_n = __this_n;
                               :	    }
                               :	}
                               :      __catch(...)
                               :	{
                               :	  clear();
                               :	  _M_deallocate_buckets(_M_buckets, _M_bucket_count);
                               :	  __throw_exception_again;
                               :	}
                               :    }
                               :
                               :  template<typename _Key, typename _Value,
                               :	   typename _Alloc, typename _ExtractKey, typename _Equal,
                               :	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
                               :	   typename _Traits>
                               :    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                               :	       _H1, _H2, _Hash, _RehashPolicy, _Traits>::
                               :    _Hashtable(_Hashtable&& __ht)
                               :    : __hashtable_base(__ht),
                               :      __map_base(__ht),
                               :      __rehash_base(__ht),
                               :      _M_buckets(__ht._M_buckets),
                               :      _M_bucket_count(__ht._M_bucket_count),
                               :      _M_bbegin(std::move(__ht._M_bbegin)),
                               :      _M_element_count(__ht._M_element_count),
                               :      _M_rehash_policy(__ht._M_rehash_policy)
                               :    {
                               :      // Update, if necessary, bucket pointing to before begin that hasn't moved.
                               :      if (_M_begin())
                               :	_M_buckets[_M_bucket_index(_M_begin())] = &_M_before_begin();
                               :      __ht._M_rehash_policy = _RehashPolicy();
                               :      __ht._M_bucket_count = __ht._M_rehash_policy._M_next_bkt(0);
                               :      __ht._M_buckets = __ht._M_allocate_buckets(__ht._M_bucket_count);
                               :      __ht._M_before_begin()._M_nxt = nullptr;
                               :      __ht._M_element_count = 0;
                               :    }
                               :
                               :  template<typename _Key, typename _Value,
                               :	   typename _Alloc, typename _ExtractKey, typename _Equal,
                               :	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
                               :	   typename _Traits>
                               :    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                               :	       _H1, _H2, _Hash, _RehashPolicy, _Traits>::
                               :    ~_Hashtable() noexcept
                               :    {
                               :      clear();
                               :      _M_deallocate_buckets(_M_buckets, _M_bucket_count);
                               :    }
                               :
                               :  template<typename _Key, typename _Value,
                               :	   typename _Alloc, typename _ExtractKey, typename _Equal,
                               :	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
                               :	   typename _Traits>
                               :    void
                               :    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                               :	       _H1, _H2, _Hash, _RehashPolicy, _Traits>::
                               :    swap(_Hashtable& __x)
                               :    {
                               :      // The only base class with member variables is hash_code_base.
                               :      // We define _Hash_code_base::_M_swap because different
                               :      // specializations have different members.
                               :      this->_M_swap(__x);
                               :
                               :      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                               :      // 431. Swapping containers with unequal allocators.
                               :      std::__alloc_swap<_Node_allocator_type>::_S_do_it(_M_node_allocator(),
                               :							__x._M_node_allocator());
                               :
                               :      std::swap(_M_rehash_policy, __x._M_rehash_policy);
                               :      std::swap(_M_buckets, __x._M_buckets);
                               :      std::swap(_M_bucket_count, __x._M_bucket_count);
                               :      std::swap(_M_before_begin()._M_nxt, __x._M_before_begin()._M_nxt);
                               :      std::swap(_M_element_count, __x._M_element_count);
                               :
                               :      // Fix buckets containing the _M_before_begin pointers that
                               :      // can't be swapped.
                               :      if (_M_begin())
                               :	_M_buckets[_M_bucket_index(_M_begin())] = &_M_before_begin();
                               :      if (__x._M_begin())
                               :	__x._M_buckets[__x._M_bucket_index(__x._M_begin())]
                               :	  = &(__x._M_before_begin());
                               :    }
                               :
                               :  template<typename _Key, typename _Value,
                               :	   typename _Alloc, typename _ExtractKey, typename _Equal,
                               :	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
                               :	   typename _Traits>
                               :    void
                               :    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                               :	       _H1, _H2, _Hash, _RehashPolicy, _Traits>::
                               :    __rehash_policy(const _RehashPolicy& __pol)
                               :    {
                               :      size_type __n_bkt = __pol._M_bkt_for_elements(_M_element_count);
                               :      __n_bkt = __pol._M_next_bkt(__n_bkt);
                               :      if (__n_bkt != _M_bucket_count)
                               :	_M_rehash(__n_bkt, _M_rehash_policy._M_state());
                               :      _M_rehash_policy = __pol;
                               :    }
                               :
                               :  template<typename _Key, typename _Value,
                               :	   typename _Alloc, typename _ExtractKey, typename _Equal,
                               :	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
                               :	   typename _Traits>
                               :    typename _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                               :			_H1, _H2, _Hash, _RehashPolicy,
                               :			_Traits>::iterator
                               :    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                               :	       _H1, _H2, _Hash, _RehashPolicy, _Traits>::
                               :    find(const key_type& __k)
                               :    {
                               :      __hash_code __code = this->_M_hash_code(__k);
                               :      std::size_t __n = _M_bucket_index(__k, __code);
                               :      __node_type* __p = _M_find_node(__n, __k, __code);
                               :      return __p ? iterator(__p) : this->end();
                               :    }
                               :
                               :  template<typename _Key, typename _Value,
                               :	   typename _Alloc, typename _ExtractKey, typename _Equal,
                               :	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
                               :	   typename _Traits>
                               :    typename _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                               :			_H1, _H2, _Hash, _RehashPolicy,
                               :			_Traits>::const_iterator
                               :    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                               :	       _H1, _H2, _Hash, _RehashPolicy, _Traits>::
                               :    find(const key_type& __k) const
                               :    {
                               :      __hash_code __code = this->_M_hash_code(__k);
                               :      std::size_t __n = _M_bucket_index(__k, __code);
                               :      __node_type* __p = _M_find_node(__n, __k, __code);
                               :      return __p ? const_iterator(__p) : this->end();
                               :    }
                               :
                               :  template<typename _Key, typename _Value,
                               :	   typename _Alloc, typename _ExtractKey, typename _Equal,
                               :	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
                               :	   typename _Traits>
                               :    typename _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                               :			_H1, _H2, _Hash, _RehashPolicy,
                               :			_Traits>::size_type
                               :    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                               :	       _H1, _H2, _Hash, _RehashPolicy, _Traits>::
                               :    count(const key_type& __k) const
                               :    {
                               :      __hash_code __code = this->_M_hash_code(__k);
                               :      std::size_t __n = _M_bucket_index(__k, __code);
                               :      __node_type* __p = _M_bucket_begin(__n);
                               :      if (!__p)
                               :	return 0;
                               :
                               :      std::size_t __result = 0;
                               :      for (;; __p = __p->_M_next())
                               :	{
                               :	  if (this->_M_equals(__k, __code, __p))
                               :	    ++__result;
                               :	  else if (__result)
                               :	    // All equivalent values are next to each other, if we
                               :	    // found a non-equivalent value after an equivalent one it
                               :	    // means that we won't find any more equivalent values.
                               :	    break;
                               :	  if (!__p->_M_nxt || _M_bucket_index(__p->_M_next()) != __n)
                               :	    break;
                               :	}
                               :      return __result;
                               :    }
                               :
                               :  template<typename _Key, typename _Value,
                               :	   typename _Alloc, typename _ExtractKey, typename _Equal,
                               :	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
                               :	   typename _Traits>
                               :    std::pair<typename _Hashtable<_Key, _Value, _Alloc,
                               :				  _ExtractKey, _Equal, _H1,
                               :				  _H2, _Hash, _RehashPolicy,
                               :				  _Traits>::iterator,
                               :	      typename _Hashtable<_Key, _Value, _Alloc,
                               :				  _ExtractKey, _Equal, _H1,
                               :				  _H2, _Hash, _RehashPolicy,
                               :				  _Traits>::iterator>
                               :    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                               :	       _H1, _H2, _Hash, _RehashPolicy, _Traits>::
                               :    equal_range(const key_type& __k)
                               :    {
                               :      __hash_code __code = this->_M_hash_code(__k);
                               :      std::size_t __n = _M_bucket_index(__k, __code);
                               :      __node_type* __p = _M_find_node(__n, __k, __code);
                               :
                               :      if (__p)
                               :	{
                               :	  __node_type* __p1 = __p->_M_next();
                               :	  while (__p1 && _M_bucket_index(__p1) == __n
                               :		 && this->_M_equals(__k, __code, __p1))
                               :	    __p1 = __p1->_M_next();
                               :
                               :	  return std::make_pair(iterator(__p), iterator(__p1));
                               :	}
                               :      else
                               :	return std::make_pair(this->end(), this->end());
                               :    }
                               :
                               :  template<typename _Key, typename _Value,
                               :	   typename _Alloc, typename _ExtractKey, typename _Equal,
                               :	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
                               :	   typename _Traits>
                               :    std::pair<typename _Hashtable<_Key, _Value, _Alloc,
                               :				  _ExtractKey, _Equal, _H1,
                               :				  _H2, _Hash, _RehashPolicy,
                               :				  _Traits>::const_iterator,
                               :	      typename _Hashtable<_Key, _Value, _Alloc,
                               :				  _ExtractKey, _Equal, _H1,
                               :				  _H2, _Hash, _RehashPolicy,
                               :				  _Traits>::const_iterator>
                               :    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                               :	       _H1, _H2, _Hash, _RehashPolicy, _Traits>::
                               :    equal_range(const key_type& __k) const
                               :    {
                               :      __hash_code __code = this->_M_hash_code(__k);
                               :      std::size_t __n = _M_bucket_index(__k, __code);
                               :      __node_type* __p = _M_find_node(__n, __k, __code);
                               :
                               :      if (__p)
                               :	{
                               :	  __node_type* __p1 = __p->_M_next();
                               :	  while (__p1 && _M_bucket_index(__p1) == __n
                               :		 && this->_M_equals(__k, __code, __p1))
                               :	    __p1 = __p1->_M_next();
                               :
                               :	  return std::make_pair(const_iterator(__p), const_iterator(__p1));
                               :	}
                               :      else
                               :	return std::make_pair(this->end(), this->end());
                               :    }
                               :
                               :  // Find the node whose key compares equal to k in the bucket n.
                               :  // Return nullptr if no node is found.
                               :  template<typename _Key, typename _Value,
                               :	   typename _Alloc, typename _ExtractKey, typename _Equal,
                               :	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
                               :	   typename _Traits>
                               :    typename _Hashtable<_Key, _Value, _Alloc, _ExtractKey,
                               :			_Equal, _H1, _H2, _Hash, _RehashPolicy,
                               :			_Traits>::__node_base*
                               :    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                               :	       _H1, _H2, _Hash, _RehashPolicy, _Traits>::
                               :    _M_find_before_node(size_type __n, const key_type& __k,
                               :			__hash_code __code) const
                               :    {
  1797  1.5289    21  1.2404   :      __node_base* __prev_p = _M_buckets[__n];
    28  0.0238     1  0.0591   :      if (!__prev_p)
                               :	return nullptr;
  2952  2.5115   102  6.0248   :      __node_type* __p = static_cast<__node_type*>(__prev_p->_M_nxt);
                               :      for (;; __p = __p->_M_next())
                               :	{
   156  0.1327     3  0.1772   :	  if (this->_M_equals(__k, __code, __p))
                               :	    return __prev_p;
   645  0.5488    26  1.5357   :	  if (!__p->_M_nxt || _M_bucket_index(__p->_M_next()) != __n)
                               :	    break;
                               :	  __prev_p = __p;
                               :	}
                               :      return nullptr;
                               :    }
                               :
                               :  template<typename _Key, typename _Value,
                               :	   typename _Alloc, typename _ExtractKey, typename _Equal,
                               :	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
                               :	   typename _Traits>
                               :    void
                               :    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                               :	       _H1, _H2, _Hash, _RehashPolicy, _Traits>::
                               :    _M_insert_bucket_begin(size_type __bkt, __node_type* __node)
                               :    {
     8  0.0068     0       0   :      if (_M_buckets[__bkt])
                               :	{
                               :	  // Bucket is not empty, we just need to insert the new node
                               :	  // after the bucket before begin.
    10  0.0085     0       0   :	  __node->_M_nxt = _M_buckets[__bkt]->_M_nxt;
     2  0.0017     0       0   :	  _M_buckets[__bkt]->_M_nxt = __node;
                               :	}
                               :      else
                               :	{
                               :	  // The bucket is empty, the new node is inserted at the
                               :	  // beginning of the singly-linked list and the bucket will
                               :	  // contain _M_before_begin pointer.
     5  0.0043     0       0   :	  __node->_M_nxt = _M_before_begin()._M_nxt;
     1 8.5e-04     0       0   :	  _M_before_begin()._M_nxt = __node;
     1 8.5e-04     0       0   :	  if (__node->_M_nxt)
                               :	    // We must update former begin bucket that is pointing to
                               :	    // _M_before_begin.
    22  0.0187     0       0   :	    _M_buckets[_M_bucket_index(__node->_M_next())] = __node;
                               :	  _M_buckets[__bkt] = &_M_before_begin();
                               :	}
                               :    }
                               :
                               :  template<typename _Key, typename _Value,
                               :	   typename _Alloc, typename _ExtractKey, typename _Equal,
                               :	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
                               :	   typename _Traits>
                               :    void
                               :    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                               :	       _H1, _H2, _Hash, _RehashPolicy, _Traits>::
                               :    _M_remove_bucket_begin(size_type __bkt, __node_type* __next,
                               :			   size_type __next_bkt)
                               :    {
                               :      if (!__next || __next_bkt != __bkt)
                               :	{
                               :	  // Bucket is now empty
                               :	  // First update next bucket if any
                               :	  if (__next)
                               :	    _M_buckets[__next_bkt] = _M_buckets[__bkt];
                               :
                               :	  // Second update before begin node if necessary
                               :	  if (&_M_before_begin() == _M_buckets[__bkt])
                               :	    _M_before_begin()._M_nxt = __next;
                               :	  _M_buckets[__bkt] = nullptr;
                               :	}
                               :    }
                               :
                               :  template<typename _Key, typename _Value,
                               :	   typename _Alloc, typename _ExtractKey, typename _Equal,
                               :	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
                               :	   typename _Traits>
                               :    typename _Hashtable<_Key, _Value, _Alloc, _ExtractKey,
                               :			_Equal, _H1, _H2, _Hash, _RehashPolicy,
                               :			_Traits>::__node_base*
                               :    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                               :	       _H1, _H2, _Hash, _RehashPolicy, _Traits>::
                               :    _M_get_previous_node(size_type __bkt, __node_base* __n)
                               :    {
                               :      __node_base* __prev_n = _M_buckets[__bkt];
                               :      while (__prev_n->_M_nxt != __n)
                               :	__prev_n = __prev_n->_M_nxt;
                               :      return __prev_n;
                               :    }
                               :
                               :  template<typename _Key, typename _Value,
                               :	   typename _Alloc, typename _ExtractKey, typename _Equal,
                               :	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
                               :	   typename _Traits>
                               :    template<typename... _Args>
                               :      std::pair<typename _Hashtable<_Key, _Value, _Alloc,
                               :				    _ExtractKey, _Equal, _H1,
                               :				    _H2, _Hash, _RehashPolicy,
                               :				    _Traits>::iterator, bool>
                               :      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                               :		 _H1, _H2, _Hash, _RehashPolicy, _Traits>::
                               :      _M_emplace(std::true_type, _Args&&... __args)
                               :      {
                               :	// First build the node to get access to the hash code
                               :	__node_type* __node = _M_allocate_node(std::forward<_Args>(__args)...);
                               :	const key_type& __k = this->_M_extract()(__node->_M_v);
                               :	__hash_code __code;
                               :	__try
                               :	  {
                               :	    __code = this->_M_hash_code(__k);
                               :	  }
                               :	__catch(...)
                               :	  {
                               :	    _M_deallocate_node(__node);
                               :	    __throw_exception_again;
                               :	  }
                               :
                               :	size_type __bkt = _M_bucket_index(__k, __code);
                               :	if (__node_type* __p = _M_find_node(__bkt, __k, __code))
                               :	  {
                               :	    // There is already an equivalent node, no insertion
                               :	    _M_deallocate_node(__node);
                               :	    return std::make_pair(iterator(__p), false);
                               :	  }
                               :
                               :	// Insert the node
                               :	return std::make_pair(_M_insert_unique_node(__bkt, __code, __node),
                               :			      true);
                               :      }
                               :
                               :  template<typename _Key, typename _Value,
                               :	   typename _Alloc, typename _ExtractKey, typename _Equal,
                               :	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
                               :	   typename _Traits>
                               :    template<typename... _Args>
                               :      typename _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                               :			  _H1, _H2, _Hash, _RehashPolicy,
                               :			  _Traits>::iterator
                               :      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                               :		 _H1, _H2, _Hash, _RehashPolicy, _Traits>::
                               :      _M_emplace(std::false_type, _Args&&... __args)
                               :      {
                               :	// First build the node to get its hash code.
                               :	__node_type* __node = _M_allocate_node(std::forward<_Args>(__args)...);
                               :
                               :	__hash_code __code;
                               :	__try
                               :	  {
                               :	    __code = this->_M_hash_code(this->_M_extract()(__node->_M_v));
                               :	  }
                               :	__catch(...)
                               :	  {
                               :	    _M_deallocate_node(__node);
                               :	    __throw_exception_again;
                               :	  }
                               :
                               :	return _M_insert_multi_node(__code, __node);
                               :      }
                               :
                               :  template<typename _Key, typename _Value,
                               :	   typename _Alloc, typename _ExtractKey, typename _Equal,
                               :	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
                               :	   typename _Traits>
                               :    typename _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                               :			_H1, _H2, _Hash, _RehashPolicy,
                               :			_Traits>::iterator
    13  0.0111     0       0   :    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal, /* std::_Hashtable<std::pair<int, int>, std::pair<std::pair<int, int> const, std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>, std::allocator<std::pair<int, int> > >, pair_cmp> >, std::allocator<std::pair<std::pair<int, int> const, std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>, std::allocator<std::pair<int, int> > >, pair_cmp> > >, std::__detail::_Select1st, std::equal_to<std::pair<int, int> >, pair_hash, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<true, false, true> >::_M_insert_unique_node(unsigned int, unsigned int, std::__detail::_Hash_node<std::pair<std::pair<int, int> const, std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>, std::allocator<std::pair<int, int> > >, pair_cmp> >, true>*)    141  0.1200     2  0.1181, std::_Hashtable<int, std::pair<int const, std::vector<Path*, std::allocator<Path*> > >, std::allocator<std::pair<int const, std::vector<Path*, std::allocator<Path*> > > >, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true> >::_M_insert_unique_node(unsigned int, unsigned int, std::__detail::_Hash_node<std::pair<int const, std::vector<Path*, std::allocator<Path*> > >, false>*)     46  0.0391     0       0, std::_Hashtable<int, std::pair<int const, std::unordered_map<int, std::vector<Path*, std::allocator<Path*> >, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<int const, std::vector<Path*, std::allocator<Path*> > > > > >, std::allocator<std::pair<int const, std::unordered_map<int, std::vector<Path*, std::allocator<Path*> >, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<int const, std::vector<Path*, std::allocator<Path*> > > > > > >, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true> >::_M_insert_unique_node(unsigned int, unsigned int, std::__detail::_Hash_node<std::pair<int const, std::unordered_map<int, std::vector<Path*, std::allocator<Path*> >, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<int const, std::vector<Path*, std::allocator<Path*> > > > > >, false>*)      1 8.5e-04     0       0, std::_Hashtable<int, std::pair<int const, std::vector<bitset, std::allocator<bitset> > >, std::allocator<std::pair<int const, std::vector<bitset, std::allocator<bitset> > > >, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true> >::_M_insert_unique_node(unsigned int, unsigned int, std::__detail::_Hash_node<std::pair<int const, std::vector<bitset, std::allocator<bitset> > >, false>*)     41  0.0349     0       0, total:    229  0.1948     2  0.1181 */
                               :	       _H1, _H2, _Hash, _RehashPolicy, _Traits>::
                               :    _M_insert_unique_node(size_type __bkt, __hash_code __code,
                               :			  __node_type* __node)
                               :    {
     1 8.5e-04     0       0   :      const __rehash_state& __saved_state = _M_rehash_policy._M_state();
                               :      std::pair<bool, std::size_t> __do_rehash
    16  0.0136     0       0   :	= _M_rehash_policy._M_need_rehash(_M_bucket_count, _M_element_count, 1);
                               :
                               :      __try
                               :	{
                               :	  if (__do_rehash.first)
                               :	    {
                               :	      _M_rehash(__do_rehash.second, __saved_state);
                               :	      __bkt = _M_bucket_index(this->_M_extract()(__node->_M_v), __code);
                               :	    }
                               :
                               :	  this->_M_store_code(__node, __code);
                               :
                               :	  // Always insert at the begining of the bucket.
                               :	  _M_insert_bucket_begin(__bkt, __node);
                               :	  ++_M_element_count;
                               :	  return iterator(__node);
                               :	}
                               :      __catch(...)
                               :	{
                               :	  _M_deallocate_node(__node);
                               :	  __throw_exception_again;
                               :	}
     7  0.0060     0       0   :    }
                               :
                               :  // Insert node, in bucket bkt if no rehash (assumes no element with its key
                               :  // already present). Take ownership of the node, deallocate it on exception.
                               :  template<typename _Key, typename _Value,
                               :	   typename _Alloc, typename _ExtractKey, typename _Equal,
                               :	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
                               :	   typename _Traits>
                               :    typename _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                               :			_H1, _H2, _Hash, _RehashPolicy,
                               :			_Traits>::iterator
                               :    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                               :	       _H1, _H2, _Hash, _RehashPolicy, _Traits>::
                               :    _M_insert_multi_node(__hash_code __code, __node_type* __node)
                               :    {
                               :      const __rehash_state& __saved_state = _M_rehash_policy._M_state();
                               :      std::pair<bool, std::size_t> __do_rehash
                               :	= _M_rehash_policy._M_need_rehash(_M_bucket_count, _M_element_count, 1);
                               :
                               :      __try
                               :	{
                               :	  if (__do_rehash.first)
                               :	    _M_rehash(__do_rehash.second, __saved_state);
                               :
                               :	  this->_M_store_code(__node, __code);
                               :	  const key_type& __k = this->_M_extract()(__node->_M_v);
                               :	  size_type __bkt = _M_bucket_index(__k, __code);
                               :
                               :	  // Find the node before an equivalent one.
                               :	  __node_base* __prev = _M_find_before_node(__bkt, __k, __code);
                               :	  if (__prev)
                               :	    {
                               :	      // Insert after the node before the equivalent one.
                               :	      __node->_M_nxt = __prev->_M_nxt;
                               :	      __prev->_M_nxt = __node;
                               :	    }
                               :	  else
                               :	    // The inserted node has no equivalent in the
                               :	    // hashtable. We must insert the new node at the
                               :	    // beginning of the bucket to preserve equivalent
                               :	    // elements' relative positions.
                               :	    _M_insert_bucket_begin(__bkt, __node);
                               :	  ++_M_element_count;
                               :	  return iterator(__node);
                               :	}
                               :      __catch(...)
                               :	{
                               :	  _M_deallocate_node(__node);
                               :	  __throw_exception_again;
                               :	}
                               :    }
                               :
                               :  // Insert v if no element with its key is already present.
                               :  template<typename _Key, typename _Value,
                               :	   typename _Alloc, typename _ExtractKey, typename _Equal,
                               :	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
                               :	   typename _Traits>
                               :    template<typename _Arg>
                               :      std::pair<typename _Hashtable<_Key, _Value, _Alloc,
                               :				    _ExtractKey, _Equal, _H1,
                               :				    _H2, _Hash, _RehashPolicy,
                               :				    _Traits>::iterator, bool>
                               :      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                               :		 _H1, _H2, _Hash, _RehashPolicy, _Traits>::
                               :      _M_insert(_Arg&& __v, std::true_type)
                               :      {
                               :	const key_type& __k = this->_M_extract()(__v);
                               :	__hash_code __code = this->_M_hash_code(__k);
                               :	size_type __bkt = _M_bucket_index(__k, __code);
                               :
                               :	__node_type* __n = _M_find_node(__bkt, __k, __code);
                               :	if (__n)
                               :	  return std::make_pair(iterator(__n), false);
                               :
                               :	__n = _M_allocate_node(std::forward<_Arg>(__v));
                               :	return std::make_pair(_M_insert_unique_node(__bkt, __code, __n), true);
                               :      }
                               :
                               :  // Insert v unconditionally.
                               :  template<typename _Key, typename _Value,
                               :	   typename _Alloc, typename _ExtractKey, typename _Equal,
                               :	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
                               :	   typename _Traits>
                               :    template<typename _Arg>
                               :      typename _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                               :			  _H1, _H2, _Hash, _RehashPolicy,
                               :			  _Traits>::iterator
                               :      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                               :		 _H1, _H2, _Hash, _RehashPolicy, _Traits>::
                               :      _M_insert(_Arg&& __v, std::false_type)
                               :      {
                               :	// First compute the hash code so that we don't do anything if it
                               :	// throws.
                               :	__hash_code __code = this->_M_hash_code(this->_M_extract()(__v));
                               :
                               :	// Second allocate new node so that we don't rehash if it throws.
                               :	__node_type* __node = _M_allocate_node(std::forward<_Arg>(__v));
                               :
                               :	return _M_insert_multi_node(__code, __node);
                               :      }
                               :
                               :  template<typename _Key, typename _Value,
                               :	   typename _Alloc, typename _ExtractKey, typename _Equal,
                               :	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
                               :	   typename _Traits>
                               :    typename _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                               :			_H1, _H2, _Hash, _RehashPolicy,
                               :			_Traits>::iterator
                               :    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                               :	       _H1, _H2, _Hash, _RehashPolicy, _Traits>::
                               :    erase(const_iterator __it)
                               :    {
                               :      __node_type* __n = __it._M_cur;
                               :      std::size_t __bkt = _M_bucket_index(__n);
                               :
                               :      // Look for previous node to unlink it from the erased one, this
                               :      // is why we need buckets to contain the before begin to make
                               :      // this search fast.
                               :      __node_base* __prev_n = _M_get_previous_node(__bkt, __n);
                               :      return _M_erase(__bkt, __prev_n, __n);
                               :    }
                               :
                               :  template<typename _Key, typename _Value,
                               :	   typename _Alloc, typename _ExtractKey, typename _Equal,
                               :	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
                               :	   typename _Traits>
                               :    typename _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                               :			_H1, _H2, _Hash, _RehashPolicy,
                               :			_Traits>::iterator
                               :    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                               :	       _H1, _H2, _Hash, _RehashPolicy, _Traits>::
                               :    _M_erase(size_type __bkt, __node_base* __prev_n, __node_type* __n)
                               :    {
                               :      if (__prev_n == _M_buckets[__bkt])
                               :	_M_remove_bucket_begin(__bkt, __n->_M_next(),
                               :	   __n->_M_nxt ? _M_bucket_index(__n->_M_next()) : 0);
                               :      else if (__n->_M_nxt)
                               :	{
                               :	  size_type __next_bkt = _M_bucket_index(__n->_M_next());
                               :	  if (__next_bkt != __bkt)
                               :	    _M_buckets[__next_bkt] = __prev_n;
                               :	}
                               :
                               :      __prev_n->_M_nxt = __n->_M_nxt;
                               :      iterator __result(__n->_M_next());
                               :      _M_deallocate_node(__n);
                               :      --_M_element_count;
                               :
                               :      return __result;
                               :    }
                               :
                               :  template<typename _Key, typename _Value,
                               :	   typename _Alloc, typename _ExtractKey, typename _Equal,
                               :	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
                               :	   typename _Traits>
                               :    typename _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                               :			_H1, _H2, _Hash, _RehashPolicy,
                               :			_Traits>::size_type
                               :    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                               :	       _H1, _H2, _Hash, _RehashPolicy, _Traits>::
                               :    _M_erase(std::true_type, const key_type& __k)
                               :    {
                               :      __hash_code __code = this->_M_hash_code(__k);
                               :      std::size_t __bkt = _M_bucket_index(__k, __code);
                               :
                               :      // Look for the node before the first matching node.
                               :      __node_base* __prev_n = _M_find_before_node(__bkt, __k, __code);
                               :      if (!__prev_n)
                               :	return 0;
                               :
                               :      // We found a matching node, erase it.
                               :      __node_type* __n = static_cast<__node_type*>(__prev_n->_M_nxt);
                               :      _M_erase(__bkt, __prev_n, __n);
                               :      return 1;
                               :    }
                               :
                               :  template<typename _Key, typename _Value,
                               :	   typename _Alloc, typename _ExtractKey, typename _Equal,
                               :	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
                               :	   typename _Traits>
                               :    typename _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                               :			_H1, _H2, _Hash, _RehashPolicy,
                               :			_Traits>::size_type
                               :    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                               :	       _H1, _H2, _Hash, _RehashPolicy, _Traits>::
                               :    _M_erase(std::false_type, const key_type& __k)
                               :    {
                               :      __hash_code __code = this->_M_hash_code(__k);
                               :      std::size_t __bkt = _M_bucket_index(__k, __code);
                               :
                               :      // Look for the node before the first matching node.
                               :      __node_base* __prev_n = _M_find_before_node(__bkt, __k, __code);
                               :      if (!__prev_n)
                               :	return 0;
                               :
                               :      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                               :      // 526. Is it undefined if a function in the standard changes
                               :      // in parameters?
                               :      // We use one loop to find all matching nodes and another to deallocate
                               :      // them so that the key stays valid during the first loop. It might be
                               :      // invalidated indirectly when destroying nodes.
                               :      __node_type* __n = static_cast<__node_type*>(__prev_n->_M_nxt);
                               :      __node_type* __n_last = __n;
                               :      std::size_t __n_last_bkt = __bkt;
                               :      do
                               :	{
                               :	  __n_last = __n_last->_M_next();
                               :	  if (!__n_last)
                               :	    break;
                               :	  __n_last_bkt = _M_bucket_index(__n_last);
                               :	}
                               :      while (__n_last_bkt == __bkt && this->_M_equals(__k, __code, __n_last));
                               :
                               :      // Deallocate nodes.
                               :      size_type __result = 0;
                               :      do
                               :	{
                               :	  __node_type* __p = __n->_M_next();
                               :	  _M_deallocate_node(__n);
                               :	  __n = __p;
                               :	  ++__result;
                               :	  --_M_element_count;
                               :	}
                               :      while (__n != __n_last);
                               :
                               :      if (__prev_n == _M_buckets[__bkt])
                               :	_M_remove_bucket_begin(__bkt, __n_last, __n_last_bkt);
                               :      else if (__n_last && __n_last_bkt != __bkt)
                               :	_M_buckets[__n_last_bkt] = __prev_n;
                               :      __prev_n->_M_nxt = __n_last;
                               :      return __result;
                               :    }
                               :
                               :  template<typename _Key, typename _Value,
                               :	   typename _Alloc, typename _ExtractKey, typename _Equal,
                               :	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
                               :	   typename _Traits>
                               :    typename _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                               :			_H1, _H2, _Hash, _RehashPolicy,
                               :			_Traits>::iterator
                               :    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                               :	       _H1, _H2, _Hash, _RehashPolicy, _Traits>::
                               :    erase(const_iterator __first, const_iterator __last)
                               :    {
                               :      __node_type* __n = __first._M_cur;
                               :      __node_type* __last_n = __last._M_cur;
                               :      if (__n == __last_n)
                               :	return iterator(__n);
                               :
                               :      std::size_t __bkt = _M_bucket_index(__n);
                               :
                               :      __node_base* __prev_n = _M_get_previous_node(__bkt, __n);
                               :      bool __is_bucket_begin = __n == _M_bucket_begin(__bkt);
                               :      std::size_t __n_bkt = __bkt;
                               :      for (;;)
                               :	{
                               :	  do
                               :	    {
                               :	      __node_type* __tmp = __n;
                               :	      __n = __n->_M_next();
                               :	      _M_deallocate_node(__tmp);
                               :	      --_M_element_count;
                               :	      if (!__n)
                               :		break;
                               :	      __n_bkt = _M_bucket_index(__n);
                               :	    }
                               :	  while (__n != __last_n && __n_bkt == __bkt);
                               :	  if (__is_bucket_begin)
                               :	    _M_remove_bucket_begin(__bkt, __n, __n_bkt);
                               :	  if (__n == __last_n)
                               :	    break;
                               :	  __is_bucket_begin = true;
                               :	  __bkt = __n_bkt;
                               :	}
                               :
                               :      if (__n && (__n_bkt != __bkt || __is_bucket_begin))
                               :	_M_buckets[__n_bkt] = __prev_n;
                               :      __prev_n->_M_nxt = __n;
                               :      return iterator(__n);
                               :    }
                               :
                               :  template<typename _Key, typename _Value,
                               :	   typename _Alloc, typename _ExtractKey, typename _Equal,
                               :	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
                               :	   typename _Traits>
                               :    void
                               :    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                               :	       _H1, _H2, _Hash, _RehashPolicy, _Traits>::
                               :    clear() noexcept
                               :    {
                               :      _M_deallocate_nodes(_M_begin());
                               :      __builtin_memset(_M_buckets, 0, _M_bucket_count * sizeof(__bucket_type));
                               :      _M_element_count = 0;
                               :      _M_before_begin()._M_nxt = nullptr;
                               :    }
                               :
                               :  template<typename _Key, typename _Value,
                               :	   typename _Alloc, typename _ExtractKey, typename _Equal,
                               :	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
                               :	   typename _Traits>
                               :    void
                               :    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                               :	       _H1, _H2, _Hash, _RehashPolicy, _Traits>::
                               :    rehash(size_type __n)
                               :    {
                               :      const __rehash_state& __saved_state = _M_rehash_policy._M_state();
                               :      std::size_t __buckets
                               :	= std::max(_M_rehash_policy._M_bkt_for_elements(_M_element_count + 1),
                               :		   __n);
                               :      __buckets = _M_rehash_policy._M_next_bkt(__buckets);
                               :
                               :      if (__buckets != _M_bucket_count)
                               :	_M_rehash(__buckets, __saved_state);
                               :      else
                               :	// No rehash, restore previous state to keep a consistent state.
                               :	_M_rehash_policy._M_reset(__saved_state);
                               :    }
                               :
                               :  template<typename _Key, typename _Value,
                               :	   typename _Alloc, typename _ExtractKey, typename _Equal,
                               :	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
                               :	   typename _Traits>
                               :    void
                               :    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                               :	       _H1, _H2, _Hash, _RehashPolicy, _Traits>::
                               :    _M_rehash(size_type __n, const __rehash_state& __state)
                               :    {
                               :      __try
                               :	{
                               :	  _M_rehash_aux(__n, __unique_keys());
                               :	}
                               :      __catch(...)
                               :	{
                               :	  // A failure here means that buckets allocation failed.  We only
                               :	  // have to restore hash policy previous state.
                               :	  _M_rehash_policy._M_reset(__state);
                               :	  __throw_exception_again;
                               :	}
                               :    }
                               :
                               :  // Rehash when there is no equivalent elements.
                               :  template<typename _Key, typename _Value,
                               :	   typename _Alloc, typename _ExtractKey, typename _Equal,
                               :	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
                               :	   typename _Traits>
                               :    void
                               :    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                               :	       _H1, _H2, _Hash, _RehashPolicy, _Traits>::
                               :    _M_rehash_aux(size_type __n, std::true_type)
                               :    {
                               :      __bucket_type* __new_buckets = _M_allocate_buckets(__n);
                               :      __node_type* __p = _M_begin();
                               :      _M_before_begin()._M_nxt = nullptr;
                               :      std::size_t __bbegin_bkt = 0;
     2  0.0017     0       0   :      while (__p)
                               :	{
                               :	  __node_type* __next = __p->_M_next();
                               :	  std::size_t __bkt = __hash_code_base::_M_bucket_index(__p, __n);
    47  0.0400     0       0   :	  if (!__new_buckets[__bkt])
                               :	    {
     4  0.0034     1  0.0591   :	      __p->_M_nxt = _M_before_begin()._M_nxt;
     2  0.0017     0       0   :	      _M_before_begin()._M_nxt = __p;
     1 8.5e-04     0       0   :	      __new_buckets[__bkt] = &_M_before_begin();
     2  0.0017     0       0   :	      if (__p->_M_nxt)
                               :		__new_buckets[__bbegin_bkt] = __p;
     2  0.0017     0       0   :	      __bbegin_bkt = __bkt;
                               :	    }
                               :	  else
                               :	    {
     8  0.0068     0       0   :	      __p->_M_nxt = __new_buckets[__bkt]->_M_nxt;
     2  0.0017     0       0   :	      __new_buckets[__bkt]->_M_nxt = __p;
                               :	    }
                               :	  __p = __next;
                               :	}
                               :      _M_deallocate_buckets(_M_buckets, _M_bucket_count);
                               :      _M_bucket_count = __n;
                               :      _M_buckets = __new_buckets;
                               :    }
                               :
                               :  // Rehash when there can be equivalent elements, preserve their relative
                               :  // order.
                               :  template<typename _Key, typename _Value,
                               :	   typename _Alloc, typename _ExtractKey, typename _Equal,
                               :	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
                               :	   typename _Traits>
                               :    void
                               :    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                               :	       _H1, _H2, _Hash, _RehashPolicy, _Traits>::
                               :    _M_rehash_aux(size_type __n, std::false_type)
                               :    {
                               :      __bucket_type* __new_buckets = _M_allocate_buckets(__n);
                               :
                               :      __node_type* __p = _M_begin();
                               :      _M_before_begin()._M_nxt = nullptr;
                               :      std::size_t __bbegin_bkt = 0;
                               :      std::size_t __prev_bkt = 0;
                               :      __node_type* __prev_p = nullptr;
                               :      bool __check_bucket = false;
                               :
                               :      while (__p)
                               :	{
                               :	  __node_type* __next = __p->_M_next();
                               :	  std::size_t __bkt = __hash_code_base::_M_bucket_index(__p, __n);
                               :
                               :	  if (__prev_p && __prev_bkt == __bkt)
                               :	    {
                               :	      // Previous insert was already in this bucket, we insert after
                               :	      // the previously inserted one to preserve equivalent elements
                               :	      // relative order.
                               :	      __p->_M_nxt = __prev_p->_M_nxt;
                               :	      __prev_p->_M_nxt = __p;
                               :
                               :	      // Inserting after a node in a bucket require to check that we
                               :	      // haven't change the bucket last node, in this case next
                               :	      // bucket containing its before begin node must be updated. We
                               :	      // schedule a check as soon as we move out of the sequence of
                               :	      // equivalent nodes to limit the number of checks.
                               :	      __check_bucket = true;
                               :	    }
                               :	  else
                               :	    {
                               :	      if (__check_bucket)
                               :		{
                               :		  // Check if we shall update the next bucket because of
                               :		  // insertions into __prev_bkt bucket.
                               :		  if (__prev_p->_M_nxt)
                               :		    {
                               :		      std::size_t __next_bkt
                               :			= __hash_code_base::_M_bucket_index(__prev_p->_M_next(),
                               :							    __n);
                               :		      if (__next_bkt != __prev_bkt)
                               :			__new_buckets[__next_bkt] = __prev_p;
                               :		    }
                               :		  __check_bucket = false;
                               :		}
                               :
                               :	      if (!__new_buckets[__bkt])
                               :		{
                               :		  __p->_M_nxt = _M_before_begin()._M_nxt;
                               :		  _M_before_begin()._M_nxt = __p;
                               :		  __new_buckets[__bkt] = &_M_before_begin();
                               :		  if (__p->_M_nxt)
                               :		    __new_buckets[__bbegin_bkt] = __p;
                               :		  __bbegin_bkt = __bkt;
                               :		}
                               :	      else
                               :		{
                               :		  __p->_M_nxt = __new_buckets[__bkt]->_M_nxt;
                               :		  __new_buckets[__bkt]->_M_nxt = __p;
                               :		}
                               :	    }
                               :	  __prev_p = __p;
                               :	  __prev_bkt = __bkt;
                               :	  __p = __next;
                               :	}
                               :
                               :      if (__check_bucket && __prev_p->_M_nxt)
                               :	{
                               :	  std::size_t __next_bkt
                               :	    = __hash_code_base::_M_bucket_index(__prev_p->_M_next(), __n);
                               :	  if (__next_bkt != __prev_bkt)
                               :	    __new_buckets[__next_bkt] = __prev_p;
                               :	}
                               :
                               :      _M_deallocate_buckets(_M_buckets, _M_bucket_count);
                               :      _M_bucket_count = __n;
                               :      _M_buckets = __new_buckets;
                               :    }
                               :
                               :_GLIBCXX_END_NAMESPACE_VERSION
                               :} // namespace std
                               :
                               :#endif // _HASHTABLE_H
/* 
 * Total samples for file : "/usr/include/c++/4.8/bits/stl_vector.h"
 * 
 *   5575  4.7431    54  3.1896
 */


                               :// Vector implementation -*- C++ -*-
                               :
                               :// Copyright (C) 2001-2013 Free Software Foundation, Inc.
                               ://
                               :// This file is part of the GNU ISO C++ Library.  This library is free
                               :// software; you can redistribute it and/or modify it under the
                               :// terms of the GNU General Public License as published by the
                               :// Free Software Foundation; either version 3, or (at your option)
                               :// any later version.
                               :
                               :// This library is distributed in the hope that it will be useful,
                               :// but WITHOUT ANY WARRANTY; without even the implied warranty of
                               :// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                               :// GNU General Public License for more details.
                               :
                               :// Under Section 7 of GPL version 3, you are granted additional
                               :// permissions described in the GCC Runtime Library Exception, version
                               :// 3.1, as published by the Free Software Foundation.
                               :
                               :// You should have received a copy of the GNU General Public License and
                               :// a copy of the GCC Runtime Library Exception along with this program;
                               :// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                               :// <http://www.gnu.org/licenses/>.
                               :
                               :/*
                               : *
                               : * Copyright (c) 1994
                               : * Hewlett-Packard Company
                               : *
                               : * Permission to use, copy, modify, distribute and sell this software
                               : * and its documentation for any purpose is hereby granted without fee,
                               : * provided that the above copyright notice appear in all copies and
                               : * that both that copyright notice and this permission notice appear
                               : * in supporting documentation.  Hewlett-Packard Company makes no
                               : * representations about the suitability of this software for any
                               : * purpose.  It is provided "as is" without express or implied warranty.
                               : *
                               : *
                               : * Copyright (c) 1996
                               : * Silicon Graphics Computer Systems, Inc.
                               : *
                               : * Permission to use, copy, modify, distribute and sell this software
                               : * and its documentation for any purpose is hereby granted without fee,
                               : * provided that the above copyright notice appear in all copies and
                               : * that both that copyright notice and this permission notice appear
                               : * in supporting documentation.  Silicon Graphics makes no
                               : * representations about the suitability of this  software for any
                               : * purpose.  It is provided "as is" without express or implied warranty.
                               : */
                               :
                               :/** @file bits/stl_vector.h
                               : *  This is an internal header file, included by other library headers.
                               : *  Do not attempt to use it directly. @headername{vector}
                               : */
                               :
                               :#ifndef _STL_VECTOR_H
                               :#define _STL_VECTOR_H 1
                               :
                               :#include <bits/stl_iterator_base_funcs.h>
                               :#include <bits/functexcept.h>
                               :#include <bits/concept_check.h>
                               :#if __cplusplus >= 201103L
                               :#include <initializer_list>
                               :#endif
                               :
                               :namespace std _GLIBCXX_VISIBILITY(default)
                               :{
                               :_GLIBCXX_BEGIN_NAMESPACE_CONTAINER
                               :
                               :  /// See bits/stl_deque.h's _Deque_base for an explanation.
                               :  template<typename _Tp, typename _Alloc>
                               :    struct _Vector_base
                               :    {
                               :      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
                               :        rebind<_Tp>::other _Tp_alloc_type;
                               :      typedef typename __gnu_cxx::__alloc_traits<_Tp_alloc_type>::pointer
                               :       	pointer;
                               :
                               :      struct _Vector_impl 
                               :      : public _Tp_alloc_type
                               :      {
                               :	pointer _M_start;
                               :	pointer _M_finish;
                               :	pointer _M_end_of_storage;
                               :
                               :	_Vector_impl()
    19  0.0162     0       0   :	: _Tp_alloc_type(), _M_start(0), _M_finish(0), _M_end_of_storage(0)
                               :	{ }
                               :
                               :	_Vector_impl(_Tp_alloc_type const& __a)
     3  0.0026     0       0   :	: _Tp_alloc_type(__a), _M_start(0), _M_finish(0), _M_end_of_storage(0)
                               :	{ }
                               :
                               :#if __cplusplus >= 201103L
                               :	_Vector_impl(_Tp_alloc_type&& __a)
                               :	: _Tp_alloc_type(std::move(__a)),
     6  0.0051     0       0   :	  _M_start(0), _M_finish(0), _M_end_of_storage(0)
                               :	{ }
                               :#endif
                               :
                               :	void _M_swap_data(_Vector_impl& __x)
                               :	{
                               :	  std::swap(_M_start, __x._M_start);
                               :	  std::swap(_M_finish, __x._M_finish);
                               :	  std::swap(_M_end_of_storage, __x._M_end_of_storage);
                               :	}
                               :      };
                               :      
                               :    public:
                               :      typedef _Alloc allocator_type;
                               :
                               :      _Tp_alloc_type&
                               :      _M_get_Tp_allocator() _GLIBCXX_NOEXCEPT
                               :      { return *static_cast<_Tp_alloc_type*>(&this->_M_impl); }
                               :
                               :      const _Tp_alloc_type&
                               :      _M_get_Tp_allocator() const _GLIBCXX_NOEXCEPT
                               :      { return *static_cast<const _Tp_alloc_type*>(&this->_M_impl); }
                               :
                               :      allocator_type
                               :      get_allocator() const _GLIBCXX_NOEXCEPT
                               :      { return allocator_type(_M_get_Tp_allocator()); }
                               :
                               :      _Vector_base()
                               :      : _M_impl() { }
                               :
                               :      _Vector_base(const allocator_type& __a)
                               :      : _M_impl(__a) { }
                               :
                               :      _Vector_base(size_t __n)
                               :      : _M_impl()
                               :      { _M_create_storage(__n); }
                               :
                               :      _Vector_base(size_t __n, const allocator_type& __a)
                               :      : _M_impl(__a)
                               :      { _M_create_storage(__n); }
                               :
                               :#if __cplusplus >= 201103L
                               :      _Vector_base(_Tp_alloc_type&& __a)
                               :      : _M_impl(std::move(__a)) { }
                               :
                               :      _Vector_base(_Vector_base&& __x)
                               :      : _M_impl(std::move(__x._M_get_Tp_allocator()))
                               :      { this->_M_impl._M_swap_data(__x._M_impl); }
                               :
                               :      _Vector_base(_Vector_base&& __x, const allocator_type& __a)
                               :      : _M_impl(__a)
                               :      {
                               :	if (__x.get_allocator() == __a)
                               :	  this->_M_impl._M_swap_data(__x._M_impl);
                               :	else
                               :	  {
                               :	    size_t __n = __x._M_impl._M_finish - __x._M_impl._M_start;
                               :	    _M_create_storage(__n);
                               :	  }
                               :      }
                               :#endif
                               :
                               :      ~_Vector_base()
                               :      { _M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage
     5  0.0043     0       0   :		      - this->_M_impl._M_start); }
                               :
                               :    public:
                               :      _Vector_impl _M_impl;
                               :
                               :      pointer
                               :      _M_allocate(size_t __n)
    43  0.0366     0       0   :      { return __n != 0 ? _M_impl.allocate(__n) : 0; }
                               :
                               :      void
                               :      _M_deallocate(pointer __p, size_t __n)
                               :      {
    31  0.0264     1  0.0591   :	if (__p)
                               :	  _M_impl.deallocate(__p, __n);
                               :      }
                               :
                               :    private:
                               :      void
                               :      _M_create_storage(size_t __n)
                               :      {
                               :	this->_M_impl._M_start = this->_M_allocate(__n);
                               :	this->_M_impl._M_finish = this->_M_impl._M_start;
                               :	this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
                               :      }
                               :    };
                               :
                               :
                               :  /**
                               :   *  @brief A standard container which offers fixed time access to
                               :   *  individual elements in any order.
                               :   *
                               :   *  @ingroup sequences
                               :   *
                               :   *  @tparam _Tp  Type of element.
                               :   *  @tparam _Alloc  Allocator type, defaults to allocator<_Tp>.
                               :   *
                               :   *  Meets the requirements of a <a href="tables.html#65">container</a>, a
                               :   *  <a href="tables.html#66">reversible container</a>, and a
                               :   *  <a href="tables.html#67">sequence</a>, including the
                               :   *  <a href="tables.html#68">optional sequence requirements</a> with the
                               :   *  %exception of @c push_front and @c pop_front.
                               :   *
                               :   *  In some terminology a %vector can be described as a dynamic
                               :   *  C-style array, it offers fast and efficient access to individual
                               :   *  elements in any order and saves the user from worrying about
                               :   *  memory and size allocation.  Subscripting ( @c [] ) access is
                               :   *  also provided as with C-style arrays.
                               :  */
                               :  template<typename _Tp, typename _Alloc = std::allocator<_Tp> >
                               :    class vector : protected _Vector_base<_Tp, _Alloc>
                               :    {
                               :      // Concept requirements.
                               :      typedef typename _Alloc::value_type                _Alloc_value_type;
                               :      __glibcxx_class_requires(_Tp, _SGIAssignableConcept)
                               :      __glibcxx_class_requires2(_Tp, _Alloc_value_type, _SameTypeConcept)
                               :      
                               :      typedef _Vector_base<_Tp, _Alloc>			 _Base;
                               :      typedef typename _Base::_Tp_alloc_type		 _Tp_alloc_type;
                               :      typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type>  _Alloc_traits;
                               :
                               :    public:
                               :      typedef _Tp					 value_type;
                               :      typedef typename _Base::pointer                    pointer;
                               :      typedef typename _Alloc_traits::const_pointer      const_pointer;
                               :      typedef typename _Alloc_traits::reference          reference;
                               :      typedef typename _Alloc_traits::const_reference    const_reference;
                               :      typedef __gnu_cxx::__normal_iterator<pointer, vector> iterator;
                               :      typedef __gnu_cxx::__normal_iterator<const_pointer, vector>
                               :      const_iterator;
                               :      typedef std::reverse_iterator<const_iterator>  const_reverse_iterator;
                               :      typedef std::reverse_iterator<iterator>		 reverse_iterator;
                               :      typedef size_t					 size_type;
                               :      typedef ptrdiff_t					 difference_type;
                               :      typedef _Alloc                        		 allocator_type;
                               :
                               :    protected:
                               :      using _Base::_M_allocate;
                               :      using _Base::_M_deallocate;
                               :      using _Base::_M_impl;
                               :      using _Base::_M_get_Tp_allocator;
                               :
                               :    public:
                               :      // [23.2.4.1] construct/copy/destroy
                               :      // (assign() and get_allocator() are also listed in this section)
                               :      /**
                               :       *  @brief  Default constructor creates no elements.
                               :       */
                               :      vector()
                               :      : _Base() { }
                               :
                               :      /**
                               :       *  @brief  Creates a %vector with no elements.
                               :       *  @param  __a  An allocator object.
                               :       */
                               :      explicit
                               :      vector(const allocator_type& __a)
                               :      : _Base(__a) { }
                               :
                               :#if __cplusplus >= 201103L
                               :      /**
                               :       *  @brief  Creates a %vector with default constructed elements.
                               :       *  @param  __n  The number of elements to initially create.
                               :       *  @param  __a  An allocator.
                               :       *
                               :       *  This constructor fills the %vector with @a __n default
                               :       *  constructed elements.
                               :       */
                               :      explicit
                               :      vector(size_type __n, const allocator_type& __a = allocator_type())
                               :      : _Base(__n, __a)
                               :      { _M_default_initialize(__n); }
                               :
                               :      /**
                               :       *  @brief  Creates a %vector with copies of an exemplar element.
                               :       *  @param  __n  The number of elements to initially create.
                               :       *  @param  __value  An element to copy.
                               :       *  @param  __a  An allocator.
                               :       *
                               :       *  This constructor fills the %vector with @a __n copies of @a __value.
                               :       */
                               :      vector(size_type __n, const value_type& __value,
                               :	     const allocator_type& __a = allocator_type())
                               :      : _Base(__n, __a)
                               :      { _M_fill_initialize(__n, __value); }
                               :#else
                               :      /**
                               :       *  @brief  Creates a %vector with copies of an exemplar element.
                               :       *  @param  __n  The number of elements to initially create.
                               :       *  @param  __value  An element to copy.
                               :       *  @param  __a  An allocator.
                               :       *
                               :       *  This constructor fills the %vector with @a __n copies of @a __value.
                               :       */
                               :      explicit
                               :      vector(size_type __n, const value_type& __value = value_type(),
                               :	     const allocator_type& __a = allocator_type())
                               :      : _Base(__n, __a)
                               :      { _M_fill_initialize(__n, __value); }
                               :#endif
                               :
                               :      /**
                               :       *  @brief  %Vector copy constructor.
                               :       *  @param  __x  A %vector of identical element and allocator types.
                               :       *
                               :       *  The newly-created %vector uses a copy of the allocation
                               :       *  object used by @a __x.  All the elements of @a __x are copied,
                               :       *  but any extra memory in
                               :       *  @a __x (for fast expansion) will not be copied.
                               :       */
     3  0.0026     0       0   :      vector(const vector& __x)
                               :      : _Base(__x.size(),
                               :        _Alloc_traits::_S_select_on_copy(__x._M_get_Tp_allocator()))
     2  0.0017     0       0   :      { this->_M_impl._M_finish =
                               :	  std::__uninitialized_copy_a(__x.begin(), __x.end(),
                               :				      this->_M_impl._M_start,
                               :				      _M_get_Tp_allocator());
                               :      }
                               :
                               :#if __cplusplus >= 201103L
                               :      /**
                               :       *  @brief  %Vector move constructor.
                               :       *  @param  __x  A %vector of identical element and allocator types.
                               :       *
                               :       *  The newly-created %vector contains the exact contents of @a __x.
                               :       *  The contents of @a __x are a valid, but unspecified %vector.
                               :       */
                               :      vector(vector&& __x) noexcept
                               :      : _Base(std::move(__x)) { }
                               :
                               :      /// Copy constructor with alternative allocator
                               :      vector(const vector& __x, const allocator_type& __a)
                               :      : _Base(__x.size(), __a)
                               :      { this->_M_impl._M_finish =
                               :	  std::__uninitialized_copy_a(__x.begin(), __x.end(),
                               :				      this->_M_impl._M_start,
                               :				      _M_get_Tp_allocator());
                               :      }
                               :
                               :      /// Move constructor with alternative allocator
                               :      vector(vector&& __rv, const allocator_type& __m)
                               :      : _Base(std::move(__rv), __m)
                               :      {
                               :	if (__rv.get_allocator() != __m)
                               :	  {
                               :	    this->_M_impl._M_finish =
                               :	      std::__uninitialized_move_a(__rv.begin(), __rv.end(),
                               :					  this->_M_impl._M_start,
                               :					  _M_get_Tp_allocator());
                               :	    __rv.clear();
                               :	  }
                               :      }
                               :
                               :      /**
                               :       *  @brief  Builds a %vector from an initializer list.
                               :       *  @param  __l  An initializer_list.
                               :       *  @param  __a  An allocator.
                               :       *
                               :       *  Create a %vector consisting of copies of the elements in the
                               :       *  initializer_list @a __l.
                               :       *
                               :       *  This will call the element type's copy constructor N times
                               :       *  (where N is @a __l.size()) and do no memory reallocation.
                               :       */
                               :      vector(initializer_list<value_type> __l,
                               :	     const allocator_type& __a = allocator_type())
                               :      : _Base(__a)
                               :      {
                               :	_M_range_initialize(__l.begin(), __l.end(),
                               :			    random_access_iterator_tag());
                               :      }
                               :#endif
                               :
                               :      /**
                               :       *  @brief  Builds a %vector from a range.
                               :       *  @param  __first  An input iterator.
                               :       *  @param  __last  An input iterator.
                               :       *  @param  __a  An allocator.
                               :       *
                               :       *  Create a %vector consisting of copies of the elements from
                               :       *  [first,last).
                               :       *
                               :       *  If the iterators are forward, bidirectional, or
                               :       *  random-access, then this will call the elements' copy
                               :       *  constructor N times (where N is distance(first,last)) and do
                               :       *  no memory reallocation.  But if only input iterators are
                               :       *  used, then this will do at most 2N calls to the copy
                               :       *  constructor, and logN memory reallocations.
                               :       */
                               :#if __cplusplus >= 201103L
                               :      template<typename _InputIterator,
                               :	       typename = std::_RequireInputIter<_InputIterator>>
                               :        vector(_InputIterator __first, _InputIterator __last,
                               :	       const allocator_type& __a = allocator_type())
                               :	: _Base(__a)
                               :        { _M_initialize_dispatch(__first, __last, __false_type()); }
                               :#else
                               :      template<typename _InputIterator>
                               :        vector(_InputIterator __first, _InputIterator __last,
                               :	       const allocator_type& __a = allocator_type())
                               :	: _Base(__a)
                               :        {
                               :	  // Check whether it's an integral type.  If so, it's not an iterator.
                               :	  typedef typename std::__is_integer<_InputIterator>::__type _Integral;
                               :	  _M_initialize_dispatch(__first, __last, _Integral());
                               :	}
                               :#endif
                               :
                               :      /**
                               :       *  The dtor only erases the elements, and note that if the
                               :       *  elements themselves are pointers, the pointed-to memory is
                               :       *  not touched in any way.  Managing the pointer is the user's
                               :       *  responsibility.
                               :       */
                               :      ~vector() _GLIBCXX_NOEXCEPT /* std::vector<std::unordered_map<int, std::vector<bitset, std::allocator<bitset> >, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<int const, std::vector<bitset, std::allocator<bitset> > > > >, std::allocator<std::unordered_map<int, std::vector<bitset, std::allocator<bitset> >, std::hash<int>, std::equal_to<int>, std::allocator<std::pair<int const, std::vector<bitset, std::allocator<bitset> > > > > > >::~vector()     43  0.0366     2  0.1181, std::vector<std::set<int, std::less<int>, std::allocator<int> >, std::allocator<std::set<int, std::less<int>, std::allocator<int> > > >::~vector()     37  0.0315     2  0.1181, total:     80  0.0681     4  0.2363 */
                               :      { std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
                               :		      _M_get_Tp_allocator()); }
                               :
                               :      /**
                               :       *  @brief  %Vector assignment operator.
                               :       *  @param  __x  A %vector of identical element and allocator types.
                               :       *
                               :       *  All the elements of @a __x are copied, but any extra memory in
                               :       *  @a __x (for fast expansion) will not be copied.  Unlike the
                               :       *  copy constructor, the allocator object is not copied.
                               :       */
                               :      vector&
                               :      operator=(const vector& __x);
                               :
                               :#if __cplusplus >= 201103L
                               :      /**
                               :       *  @brief  %Vector move assignment operator.
                               :       *  @param  __x  A %vector of identical element and allocator types.
                               :       *
                               :       *  The contents of @a __x are moved into this %vector (without copying,
                               :       *  if the allocators permit it).
                               :       *  @a __x is a valid, but unspecified %vector.
                               :       */
                               :      vector&
                               :      operator=(vector&& __x) noexcept(_Alloc_traits::_S_nothrow_move())
                               :      {
                               :        constexpr bool __move_storage =
                               :          _Alloc_traits::_S_propagate_on_move_assign()
                               :          || _Alloc_traits::_S_always_equal();
                               :        _M_move_assign(std::move(__x),
                               :                       integral_constant<bool, __move_storage>());
                               :	return *this;
                               :      }
                               :
                               :      /**
                               :       *  @brief  %Vector list assignment operator.
                               :       *  @param  __l  An initializer_list.
                               :       *
                               :       *  This function fills a %vector with copies of the elements in the
                               :       *  initializer list @a __l.
                               :       *
                               :       *  Note that the assignment completely changes the %vector and
                               :       *  that the resulting %vector's size is the same as the number
                               :       *  of elements assigned.  Old data may be lost.
                               :       */
                               :      vector&
                               :      operator=(initializer_list<value_type> __l)
                               :      {
                               :	this->assign(__l.begin(), __l.end());
                               :	return *this;
                               :      }
                               :#endif
                               :
                               :      /**
                               :       *  @brief  Assigns a given value to a %vector.
                               :       *  @param  __n  Number of elements to be assigned.
                               :       *  @param  __val  Value to be assigned.
                               :       *
                               :       *  This function fills a %vector with @a __n copies of the given
                               :       *  value.  Note that the assignment completely changes the
                               :       *  %vector and that the resulting %vector's size is the same as
                               :       *  the number of elements assigned.  Old data may be lost.
                               :       */
                               :      void
                               :      assign(size_type __n, const value_type& __val)
                               :      { _M_fill_assign(__n, __val); }
                               :
                               :      /**
                               :       *  @brief  Assigns a range to a %vector.
                               :       *  @param  __first  An input iterator.
                               :       *  @param  __last   An input iterator.
                               :       *
                               :       *  This function fills a %vector with copies of the elements in the
                               :       *  range [__first,__last).
                               :       *
                               :       *  Note that the assignment completely changes the %vector and
                               :       *  that the resulting %vector's size is the same as the number
                               :       *  of elements assigned.  Old data may be lost.
                               :       */
                               :#if __cplusplus >= 201103L
                               :      template<typename _InputIterator,
                               :	       typename = std::_RequireInputIter<_InputIterator>>
                               :        void
                               :        assign(_InputIterator __first, _InputIterator __last)
                               :        { _M_assign_dispatch(__first, __last, __false_type()); }
                               :#else
                               :      template<typename _InputIterator>
                               :        void
                               :        assign(_InputIterator __first, _InputIterator __last)
                               :        {
                               :	  // Check whether it's an integral type.  If so, it's not an iterator.
                               :	  typedef typename std::__is_integer<_InputIterator>::__type _Integral;
                               :	  _M_assign_dispatch(__first, __last, _Integral());
                               :	}
                               :#endif
                               :
                               :#if __cplusplus >= 201103L
                               :      /**
                               :       *  @brief  Assigns an initializer list to a %vector.
                               :       *  @param  __l  An initializer_list.
                               :       *
                               :       *  This function fills a %vector with copies of the elements in the
                               :       *  initializer list @a __l.
                               :       *
                               :       *  Note that the assignment completely changes the %vector and
                               :       *  that the resulting %vector's size is the same as the number
                               :       *  of elements assigned.  Old data may be lost.
                               :       */
                               :      void
                               :      assign(initializer_list<value_type> __l)
                               :      { this->assign(__l.begin(), __l.end()); }
                               :#endif
                               :
                               :      /// Get a copy of the memory allocation object.
                               :      using _Base::get_allocator;
                               :
                               :      // iterators
                               :      /**
                               :       *  Returns a read/write iterator that points to the first
                               :       *  element in the %vector.  Iteration is done in ordinary
                               :       *  element order.
                               :       */
                               :      iterator
                               :      begin() _GLIBCXX_NOEXCEPT
                               :      { return iterator(this->_M_impl._M_start); }
                               :
                               :      /**
                               :       *  Returns a read-only (constant) iterator that points to the
                               :       *  first element in the %vector.  Iteration is done in ordinary
                               :       *  element order.
                               :       */
                               :      const_iterator
                               :      begin() const _GLIBCXX_NOEXCEPT
                               :      { return const_iterator(this->_M_impl._M_start); }
                               :
                               :      /**
                               :       *  Returns a read/write iterator that points one past the last
                               :       *  element in the %vector.  Iteration is done in ordinary
                               :       *  element order.
                               :       */
                               :      iterator
                               :      end() _GLIBCXX_NOEXCEPT
                               :      { return iterator(this->_M_impl._M_finish); }
                               :
                               :      /**
                               :       *  Returns a read-only (constant) iterator that points one past
                               :       *  the last element in the %vector.  Iteration is done in
                               :       *  ordinary element order.
                               :       */
                               :      const_iterator
                               :      end() const _GLIBCXX_NOEXCEPT
                               :      { return const_iterator(this->_M_impl._M_finish); }
                               :
                               :      /**
                               :       *  Returns a read/write reverse iterator that points to the
                               :       *  last element in the %vector.  Iteration is done in reverse
                               :       *  element order.
                               :       */
                               :      reverse_iterator
                               :      rbegin() _GLIBCXX_NOEXCEPT
                               :      { return reverse_iterator(end()); }
                               :
                               :      /**
                               :       *  Returns a read-only (constant) reverse iterator that points
                               :       *  to the last element in the %vector.  Iteration is done in
                               :       *  reverse element order.
                               :       */
                               :      const_reverse_iterator
                               :      rbegin() const _GLIBCXX_NOEXCEPT
                               :      { return const_reverse_iterator(end()); }
                               :
                               :      /**
                               :       *  Returns a read/write reverse iterator that points to one
                               :       *  before the first element in the %vector.  Iteration is done
                               :       *  in reverse element order.
                               :       */
                               :      reverse_iterator
                               :      rend() _GLIBCXX_NOEXCEPT
                               :      { return reverse_iterator(begin()); }
                               :
                               :      /**
                               :       *  Returns a read-only (constant) reverse iterator that points
                               :       *  to one before the first element in the %vector.  Iteration
                               :       *  is done in reverse element order.
                               :       */
                               :      const_reverse_iterator
                               :      rend() const _GLIBCXX_NOEXCEPT
                               :      { return const_reverse_iterator(begin()); }
                               :
                               :#if __cplusplus >= 201103L
                               :      /**
                               :       *  Returns a read-only (constant) iterator that points to the
                               :       *  first element in the %vector.  Iteration is done in ordinary
                               :       *  element order.
                               :       */
                               :      const_iterator
                               :      cbegin() const noexcept
                               :      { return const_iterator(this->_M_impl._M_start); }
                               :
                               :      /**
                               :       *  Returns a read-only (constant) iterator that points one past
                               :       *  the last element in the %vector.  Iteration is done in
                               :       *  ordinary element order.
                               :       */
                               :      const_iterator
                               :      cend() const noexcept
                               :      { return const_iterator(this->_M_impl._M_finish); }
                               :
                               :      /**
                               :       *  Returns a read-only (constant) reverse iterator that points
                               :       *  to the last element in the %vector.  Iteration is done in
                               :       *  reverse element order.
                               :       */
                               :      const_reverse_iterator
                               :      crbegin() const noexcept
                               :      { return const_reverse_iterator(end()); }
                               :
                               :      /**
                               :       *  Returns a read-only (constant) reverse iterator that points
                               :       *  to one before the first element in the %vector.  Iteration
                               :       *  is done in reverse element order.
                               :       */
                               :      const_reverse_iterator
                               :      crend() const noexcept
                               :      { return const_reverse_iterator(begin()); }
                               :#endif
                               :
                               :      // [23.2.4.2] capacity
                               :      /**  Returns the number of elements in the %vector.  */
                               :      size_type
                               :      size() const _GLIBCXX_NOEXCEPT
  1773  1.5084    20  1.1813   :      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
                               :
                               :      /**  Returns the size() of the largest possible %vector.  */
                               :      size_type
                               :      max_size() const _GLIBCXX_NOEXCEPT
                               :      { return _Alloc_traits::max_size(_M_get_Tp_allocator()); }
                               :
                               :#if __cplusplus >= 201103L
                               :      /**
                               :       *  @brief  Resizes the %vector to the specified number of elements.
                               :       *  @param  __new_size  Number of elements the %vector should contain.
                               :       *
                               :       *  This function will %resize the %vector to the specified
                               :       *  number of elements.  If the number is smaller than the
                               :       *  %vector's current size the %vector is truncated, otherwise
                               :       *  default constructed elements are appended.
                               :       */
                               :      void
                               :      resize(size_type __new_size)
                               :      {
                               :	if (__new_size > size())
                               :	  _M_default_append(__new_size - size());
                               :	else if (__new_size < size())
                               :	  _M_erase_at_end(this->_M_impl._M_start + __new_size);
                               :      }
                               :
                               :      /**
                               :       *  @brief  Resizes the %vector to the specified number of elements.
                               :       *  @param  __new_size  Number of elements the %vector should contain.
                               :       *  @param  __x  Data with which new elements should be populated.
                               :       *
                               :       *  This function will %resize the %vector to the specified
                               :       *  number of elements.  If the number is smaller than the
                               :       *  %vector's current size the %vector is truncated, otherwise
                               :       *  the %vector is extended and new elements are populated with
                               :       *  given data.
                               :       */
                               :      void
                               :      resize(size_type __new_size, const value_type& __x)
                               :      {
                               :	if (__new_size > size())
                               :	  insert(end(), __new_size - size(), __x);
                               :	else if (__new_size < size())
                               :	  _M_erase_at_end(this->_M_impl._M_start + __new_size);
                               :      }
                               :#else
                               :      /**
                               :       *  @brief  Resizes the %vector to the specified number of elements.
                               :       *  @param  __new_size  Number of elements the %vector should contain.
                               :       *  @param  __x  Data with which new elements should be populated.
                               :       *
                               :       *  This function will %resize the %vector to the specified
                               :       *  number of elements.  If the number is smaller than the
                               :       *  %vector's current size the %vector is truncated, otherwise
                               :       *  the %vector is extended and new elements are populated with
                               :       *  given data.
                               :       */
                               :      void
                               :      resize(size_type __new_size, value_type __x = value_type())
                               :      {
                               :	if (__new_size > size())
                               :	  insert(end(), __new_size - size(), __x);
                               :	else if (__new_size < size())
                               :	  _M_erase_at_end(this->_M_impl._M_start + __new_size);
                               :      }
                               :#endif
                               :
                               :#if __cplusplus >= 201103L
                               :      /**  A non-binding request to reduce capacity() to size().  */
                               :      void
                               :      shrink_to_fit()
                               :      { _M_shrink_to_fit(); }
                               :#endif
                               :
                               :      /**
                               :       *  Returns the total number of elements that the %vector can
                               :       *  hold before needing to allocate more memory.
                               :       */
                               :      size_type
                               :      capacity() const _GLIBCXX_NOEXCEPT
                               :      { return size_type(this->_M_impl._M_end_of_storage
                               :			 - this->_M_impl._M_start); }
                               :
                               :      /**
                               :       *  Returns true if the %vector is empty.  (Thus begin() would
                               :       *  equal end().)
                               :       */
                               :      bool
                               :      empty() const _GLIBCXX_NOEXCEPT
                               :      { return begin() == end(); }
                               :
                               :      /**
                               :       *  @brief  Attempt to preallocate enough memory for specified number of
                               :       *          elements.
                               :       *  @param  __n  Number of elements required.
                               :       *  @throw  std::length_error  If @a n exceeds @c max_size().
                               :       *
                               :       *  This function attempts to reserve enough memory for the
                               :       *  %vector to hold the specified number of elements.  If the
                               :       *  number requested is more than max_size(), length_error is
                               :       *  thrown.
                               :       *
                               :       *  The advantage of this function is that if optimal code is a
                               :       *  necessity and the user can determine the number of elements
                               :       *  that will be required, the user can reserve the memory in
                               :       *  %advance, and thus prevent a possible reallocation of memory
                               :       *  and copying of %vector data.
                               :       */
                               :      void
                               :      reserve(size_type __n);
                               :
                               :      // element access
                               :      /**
                               :       *  @brief  Subscript access to the data contained in the %vector.
                               :       *  @param __n The index of the element for which data should be
                               :       *  accessed.
                               :       *  @return  Read/write reference to data.
                               :       *
                               :       *  This operator allows for easy, array-style, data access.
                               :       *  Note that data access with this operator is unchecked and
                               :       *  out_of_range lookups are not defined. (For checked lookups
                               :       *  see at().)
                               :       */
                               :      reference
                               :      operator[](size_type __n)
  1727  1.4693    29  1.7129   :      { return *(this->_M_impl._M_start + __n); }
                               :
                               :      /**
                               :       *  @brief  Subscript access to the data contained in the %vector.
                               :       *  @param __n The index of the element for which data should be
                               :       *  accessed.
                               :       *  @return  Read-only (constant) reference to data.
                               :       *
                               :       *  This operator allows for easy, array-style, data access.
                               :       *  Note that data access with this operator is unchecked and
                               :       *  out_of_range lookups are not defined. (For checked lookups
                               :       *  see at().)
                               :       */
                               :      const_reference
                               :      operator[](size_type __n) const
                               :      { return *(this->_M_impl._M_start + __n); }
                               :
                               :    protected:
                               :      /// Safety check used only from at().
                               :      void
                               :      _M_range_check(size_type __n) const
                               :      {
                               :	if (__n >= this->size())
                               :	  __throw_out_of_range(__N("vector::_M_range_check"));
                               :      }
                               :
                               :    public:
                               :      /**
                               :       *  @brief  Provides access to the data contained in the %vector.
                               :       *  @param __n The index of the element for which data should be
                               :       *  accessed.
                               :       *  @return  Read/write reference to data.
                               :       *  @throw  std::out_of_range  If @a __n is an invalid index.
                               :       *
                               :       *  This function provides for safer data access.  The parameter
                               :       *  is first checked that it is in the range of the vector.  The
                               :       *  function throws out_of_range if the check fails.
                               :       */
                               :      reference
                               :      at(size_type __n)
                               :      {
                               :	_M_range_check(__n);
                               :	return (*this)[__n]; 
                               :      }
                               :
                               :      /**
                               :       *  @brief  Provides access to the data contained in the %vector.
                               :       *  @param __n The index of the element for which data should be
                               :       *  accessed.
                               :       *  @return  Read-only (constant) reference to data.
                               :       *  @throw  std::out_of_range  If @a __n is an invalid index.
                               :       *
                               :       *  This function provides for safer data access.  The parameter
                               :       *  is first checked that it is in the range of the vector.  The
                               :       *  function throws out_of_range if the check fails.
                               :       */
                               :      const_reference
                               :      at(size_type __n) const
                               :      {
                               :	_M_range_check(__n);
                               :	return (*this)[__n];
                               :      }
                               :
                               :      /**
                               :       *  Returns a read/write reference to the data at the first
                               :       *  element of the %vector.
                               :       */
                               :      reference
                               :      front()
                               :      { return *begin(); }
                               :
                               :      /**
                               :       *  Returns a read-only (constant) reference to the data at the first
                               :       *  element of the %vector.
                               :       */
                               :      const_reference
   109  0.0927     0       0   :      front() const
                               :      { return *begin(); }
                               :
                               :      /**
                               :       *  Returns a read/write reference to the data at the last
                               :       *  element of the %vector.
                               :       */
                               :      reference
                               :      back()
                               :      { return *(end() - 1); }
                               :      
                               :      /**
                               :       *  Returns a read-only (constant) reference to the data at the
                               :       *  last element of the %vector.
                               :       */
                               :      const_reference
                               :      back() const
                               :      { return *(end() - 1); }
                               :
                               :      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                               :      // DR 464. Suggestion for new member functions in standard containers.
                               :      // data access
                               :      /**
                               :       *   Returns a pointer such that [data(), data() + size()) is a valid
                               :       *   range.  For a non-empty %vector, data() == &front().
                               :       */
                               :#if __cplusplus >= 201103L
                               :      _Tp*
                               :#else
                               :      pointer
                               :#endif
                               :      data() _GLIBCXX_NOEXCEPT
                               :      { return std::__addressof(front()); }
                               :
                               :#if __cplusplus >= 201103L
                               :      const _Tp*
                               :#else
                               :      const_pointer
                               :#endif
                               :      data() const _GLIBCXX_NOEXCEPT
                               :      { return std::__addressof(front()); }
                               :
                               :      // [23.2.4.3] modifiers
                               :      /**
                               :       *  @brief  Add data to the end of the %vector.
                               :       *  @param  __x  Data to be added.
                               :       *
                               :       *  This is a typical stack operation.  The function creates an
                               :       *  element at the end of the %vector and assigns the given data
                               :       *  to it.  Due to the nature of a %vector this operation can be
                               :       *  done in constant time if the %vector has preallocated space
                               :       *  available.
                               :       */
                               :      void
                               :      push_back(const value_type& __x)
                               :      {
    64  0.0545     0       0   :	if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
                               :	  {
                               :	    _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
                               :	                             __x);
    60  0.0510     1  0.0591   :	    ++this->_M_impl._M_finish;
                               :	  }
                               :	else
                               :#if __cplusplus >= 201103L
    30  0.0255     2  0.1181   :	  _M_emplace_back_aux(__x);
                               :#else
                               :	  _M_insert_aux(end(), __x);
                               :#endif
                               :      }
                               :
                               :#if __cplusplus >= 201103L
                               :      void
                               :      push_back(value_type&& __x)
                               :      { emplace_back(std::move(__x)); }
                               :
                               :      template<typename... _Args>
                               :        void
                               :        emplace_back(_Args&&... __args);
                               :#endif
                               :
                               :      /**
                               :       *  @brief  Removes last element.
                               :       *
                               :       *  This is a typical stack operation. It shrinks the %vector by one.
                               :       *
                               :       *  Note that no data is returned, and if the last element's
                               :       *  data is needed, it should be retrieved before pop_back() is
                               :       *  called.
                               :       */
                               :      void
                               :      pop_back()
                               :      {
  1201  1.0218     0       0   :	--this->_M_impl._M_finish;
                               :	_Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
                               :      }
                               :
                               :#if __cplusplus >= 201103L
                               :      /**
                               :       *  @brief  Inserts an object in %vector before specified iterator.
                               :       *  @param  __position  An iterator into the %vector.
                               :       *  @param  __args  Arguments.
                               :       *  @return  An iterator that points to the inserted data.
                               :       *
                               :       *  This function will insert an object of type T constructed
                               :       *  with T(std::forward<Args>(args)...) before the specified location.
                               :       *  Note that this kind of operation could be expensive for a %vector
                               :       *  and if it is frequently used the user should consider using
                               :       *  std::list.
                               :       */
                               :      template<typename... _Args>
                               :        iterator
                               :        emplace(iterator __position, _Args&&... __args);
                               :#endif
                               :
                               :      /**
                               :       *  @brief  Inserts given value into %vector before specified iterator.
                               :       *  @param  __position  An iterator into the %vector.
                               :       *  @param  __x  Data to be inserted.
                               :       *  @return  An iterator that points to the inserted data.
                               :       *
                               :       *  This function will insert a copy of the given value before
                               :       *  the specified location.  Note that this kind of operation
                               :       *  could be expensive for a %vector and if it is frequently
                               :       *  used the user should consider using std::list.
                               :       */
                               :      iterator
                               :      insert(iterator __position, const value_type& __x);
                               :
                               :#if __cplusplus >= 201103L
                               :      /**
                               :       *  @brief  Inserts given rvalue into %vector before specified iterator.
                               :       *  @param  __position  An iterator into the %vector.
                               :       *  @param  __x  Data to be inserted.
                               :       *  @return  An iterator that points to the inserted data.
                               :       *
                               :       *  This function will insert a copy of the given rvalue before
                               :       *  the specified location.  Note that this kind of operation
                               :       *  could be expensive for a %vector and if it is frequently
                               :       *  used the user should consider using std::list.
                               :       */
                               :      iterator
                               :      insert(iterator __position, value_type&& __x)
                               :      { return emplace(__position, std::move(__x)); }
                               :
                               :      /**
                               :       *  @brief  Inserts an initializer_list into the %vector.
                               :       *  @param  __position  An iterator into the %vector.
                               :       *  @param  __l  An initializer_list.
                               :       *
                               :       *  This function will insert copies of the data in the 
                               :       *  initializer_list @a l into the %vector before the location
                               :       *  specified by @a position.
                               :       *
                               :       *  Note that this kind of operation could be expensive for a
                               :       *  %vector and if it is frequently used the user should
                               :       *  consider using std::list.
                               :       */
                               :      void
                               :      insert(iterator __position, initializer_list<value_type> __l)
                               :      { this->insert(__position, __l.begin(), __l.end()); }
                               :#endif
                               :
                               :      /**
                               :       *  @brief  Inserts a number of copies of given data into the %vector.
                               :       *  @param  __position  An iterator into the %vector.
                               :       *  @param  __n  Number of elements to be inserted.
                               :       *  @param  __x  Data to be inserted.
                               :       *
                               :       *  This function will insert a specified number of copies of
                               :       *  the given data before the location specified by @a position.
                               :       *
                               :       *  Note that this kind of operation could be expensive for a
                               :       *  %vector and if it is frequently used the user should
                               :       *  consider using std::list.
                               :       */
                               :      void
                               :      insert(iterator __position, size_type __n, const value_type& __x)
                               :      { _M_fill_insert(__position, __n, __x); }
                               :
                               :      /**
                               :       *  @brief  Inserts a range into the %vector.
                               :       *  @param  __position  An iterator into the %vector.
                               :       *  @param  __first  An input iterator.
                               :       *  @param  __last   An input iterator.
                               :       *
                               :       *  This function will insert copies of the data in the range
                               :       *  [__first,__last) into the %vector before the location specified
                               :       *  by @a pos.
                               :       *
                               :       *  Note that this kind of operation could be expensive for a
                               :       *  %vector and if it is frequently used the user should
                               :       *  consider using std::list.
                               :       */
                               :#if __cplusplus >= 201103L
                               :      template<typename _InputIterator,
                               :	       typename = std::_RequireInputIter<_InputIterator>>
                               :        void
                               :        insert(iterator __position, _InputIterator __first,
                               :	       _InputIterator __last)
                               :        { _M_insert_dispatch(__position, __first, __last, __false_type()); }
                               :#else
                               :      template<typename _InputIterator>
                               :        void
                               :        insert(iterator __position, _InputIterator __first,
                               :	       _InputIterator __last)
                               :        {
                               :	  // Check whether it's an integral type.  If so, it's not an iterator.
                               :	  typedef typename std::__is_integer<_InputIterator>::__type _Integral;
                               :	  _M_insert_dispatch(__position, __first, __last, _Integral());
                               :	}
                               :#endif
                               :
                               :      /**
                               :       *  @brief  Remove element at given position.
                               :       *  @param  __position  Iterator pointing to element to be erased.
                               :       *  @return  An iterator pointing to the next element (or end()).
                               :       *
                               :       *  This function will erase the element at the given position and thus
                               :       *  shorten the %vector by one.
                               :       *
                               :       *  Note This operation could be expensive and if it is
                               :       *  frequently used the user should consider using std::list.
                               :       *  The user is also cautioned that this function only erases
                               :       *  the element, and that if the element is itself a pointer,
                               :       *  the pointed-to memory is not touched in any way.  Managing
                               :       *  the pointer is the user's responsibility.
                               :       */
                               :      iterator
                               :      erase(iterator __position);
                               :
                               :      /**
                               :       *  @brief  Remove a range of elements.
                               :       *  @param  __first  Iterator pointing to the first element to be erased.
                               :       *  @param  __last  Iterator pointing to one past the last element to be
                               :       *                  erased.
                               :       *  @return  An iterator pointing to the element pointed to by @a __last
                               :       *           prior to erasing (or end()).
                               :       *
                               :       *  This function will erase the elements in the range
                               :       *  [__first,__last) and shorten the %vector accordingly.
                               :       *
                               :       *  Note This operation could be expensive and if it is
                               :       *  frequently used the user should consider using std::list.
                               :       *  The user is also cautioned that this function only erases
                               :       *  the elements, and that if the elements themselves are
                               :       *  pointers, the pointed-to memory is not touched in any way.
                               :       *  Managing the pointer is the user's responsibility.
                               :       */
                               :      iterator
                               :      erase(iterator __first, iterator __last);
                               :
                               :      /**
                               :       *  @brief  Swaps data with another %vector.
                               :       *  @param  __x  A %vector of the same element and allocator types.
                               :       *
                               :       *  This exchanges the elements between two vectors in constant time.
                               :       *  (Three pointers, so it should be quite fast.)
                               :       *  Note that the global std::swap() function is specialized such that
                               :       *  std::swap(v1,v2) will feed to this function.
                               :       */
                               :      void
                               :      swap(vector& __x)
                               :#if __cplusplus >= 201103L
                               :			noexcept(_Alloc_traits::_S_nothrow_swap())
                               :#endif
                               :      {
                               :	this->_M_impl._M_swap_data(__x._M_impl);
                               :	_Alloc_traits::_S_on_swap(_M_get_Tp_allocator(),
                               :	                          __x._M_get_Tp_allocator());
                               :      }
                               :
                               :      /**
                               :       *  Erases all the elements.  Note that this function only erases the
                               :       *  elements, and that if the elements themselves are pointers, the
                               :       *  pointed-to memory is not touched in any way.  Managing the pointer is
                               :       *  the user's responsibility.
                               :       */
                               :      void
                               :      clear() _GLIBCXX_NOEXCEPT
                               :      { _M_erase_at_end(this->_M_impl._M_start); }
                               :
                               :    protected:
                               :      /**
                               :       *  Memory expansion handler.  Uses the member allocation function to
                               :       *  obtain @a n bytes of memory, and then copies [first,last) into it.
                               :       */
                               :      template<typename _ForwardIterator>
                               :        pointer
                               :        _M_allocate_and_copy(size_type __n,
                               :			     _ForwardIterator __first, _ForwardIterator __last)
                               :        {
                               :	  pointer __result = this->_M_allocate(__n);
                               :	  __try
                               :	    {
                               :	      std::__uninitialized_copy_a(__first, __last, __result,
                               :					  _M_get_Tp_allocator());
                               :	      return __result;
                               :	    }
                               :	  __catch(...)
                               :	    {
                               :	      _M_deallocate(__result, __n);
                               :	      __throw_exception_again;
                               :	    }
                               :	}
                               :
                               :
                               :      // Internal constructor functions follow.
                               :
                               :      // Called by the range constructor to implement [23.1.1]/9
                               :
                               :      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                               :      // 438. Ambiguity in the "do the right thing" clause
                               :      template<typename _Integer>
                               :        void
                               :        _M_initialize_dispatch(_Integer __n, _Integer __value, __true_type)
                               :        {
                               :	  this->_M_impl._M_start = _M_allocate(static_cast<size_type>(__n));
                               :	  this->_M_impl._M_end_of_storage =
                               :	    this->_M_impl._M_start + static_cast<size_type>(__n);
                               :	  _M_fill_initialize(static_cast<size_type>(__n), __value);
                               :	}
                               :
                               :      // Called by the range constructor to implement [23.1.1]/9
                               :      template<typename _InputIterator>
                               :        void
                               :        _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
                               :			       __false_type)
                               :        {
                               :	  typedef typename std::iterator_traits<_InputIterator>::
                               :	    iterator_category _IterCategory;
                               :	  _M_range_initialize(__first, __last, _IterCategory());
                               :	}
                               :
                               :      // Called by the second initialize_dispatch above
                               :      template<typename _InputIterator>
                               :        void
                               :        _M_range_initialize(_InputIterator __first,
                               :			    _InputIterator __last, std::input_iterator_tag)
                               :        {
                               :	  for (; __first != __last; ++__first)
                               :#if __cplusplus >= 201103L
                               :	    emplace_back(*__first);
                               :#else
                               :	    push_back(*__first);
                               :#endif
                               :	}
                               :
                               :      // Called by the second initialize_dispatch above
                               :      template<typename _ForwardIterator>
                               :        void
                               :        _M_range_initialize(_ForwardIterator __first,
                               :			    _ForwardIterator __last, std::forward_iterator_tag)
                               :        {
                               :	  const size_type __n = std::distance(__first, __last);
                               :	  this->_M_impl._M_start = this->_M_allocate(__n);
                               :	  this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
                               :	  this->_M_impl._M_finish =
                               :	    std::__uninitialized_copy_a(__first, __last,
                               :					this->_M_impl._M_start,
                               :					_M_get_Tp_allocator());
                               :	}
                               :
                               :      // Called by the first initialize_dispatch above and by the
                               :      // vector(n,value,a) constructor.
                               :      void
                               :      _M_fill_initialize(size_type __n, const value_type& __value)
                               :      {
                               :	std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value, 
                               :				      _M_get_Tp_allocator());
                               :	this->_M_impl._M_finish = this->_M_impl._M_end_of_storage;
                               :      }
                               :
                               :#if __cplusplus >= 201103L
                               :      // Called by the vector(n) constructor.
                               :      void
                               :      _M_default_initialize(size_type __n) /* std::vector<std::set<int, std::less<int>, std::allocator<int> >, std::allocator<std::set<int, std::less<int>, std::allocator<int> > > >::_M_default_initialize(unsigned int) total:      1 8.5e-04     0       0 */
                               :      {
                               :	std::__uninitialized_default_n_a(this->_M_impl._M_start, __n, 
                               :					 _M_get_Tp_allocator());
                               :	this->_M_impl._M_finish = this->_M_impl._M_end_of_storage;
                               :      }
                               :#endif
                               :
                               :      // Internal assign functions follow.  The *_aux functions do the actual
                               :      // assignment work for the range versions.
                               :
                               :      // Called by the range assign to implement [23.1.1]/9
                               :
                               :      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                               :      // 438. Ambiguity in the "do the right thing" clause
                               :      template<typename _Integer>
                               :        void
                               :        _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
                               :        { _M_fill_assign(__n, __val); }
                               :
                               :      // Called by the range assign to implement [23.1.1]/9
                               :      template<typename _InputIterator>
                               :        void
                               :        _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
                               :			   __false_type)
                               :        {
                               :	  typedef typename std::iterator_traits<_InputIterator>::
                               :	    iterator_category _IterCategory;
                               :	  _M_assign_aux(__first, __last, _IterCategory());
                               :	}
                               :
                               :      // Called by the second assign_dispatch above
                               :      template<typename _InputIterator>
                               :        void
                               :        _M_assign_aux(_InputIterator __first, _InputIterator __last,
                               :		      std::input_iterator_tag);
                               :
                               :      // Called by the second assign_dispatch above
                               :      template<typename _ForwardIterator>
                               :        void
                               :        _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
                               :		      std::forward_iterator_tag);
                               :
                               :      // Called by assign(n,t), and the range assign when it turns out
                               :      // to be the same thing.
                               :      void
                               :      _M_fill_assign(size_type __n, const value_type& __val);
                               :
                               :
                               :      // Internal insert functions follow.
                               :
                               :      // Called by the range insert to implement [23.1.1]/9
                               :
                               :      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                               :      // 438. Ambiguity in the "do the right thing" clause
                               :      template<typename _Integer>
                               :        void
                               :        _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __val,
                               :			   __true_type)
                               :        { _M_fill_insert(__pos, __n, __val); }
                               :
                               :      // Called by the range insert to implement [23.1.1]/9
                               :      template<typename _InputIterator>
                               :        void
                               :        _M_insert_dispatch(iterator __pos, _InputIterator __first,
                               :			   _InputIterator __last, __false_type)
                               :        {
                               :	  typedef typename std::iterator_traits<_InputIterator>::
                               :	    iterator_category _IterCategory;
                               :	  _M_range_insert(__pos, __first, __last, _IterCategory());
                               :	}
                               :
                               :      // Called by the second insert_dispatch above
                               :      template<typename _InputIterator>
                               :        void
                               :        _M_range_insert(iterator __pos, _InputIterator __first,
                               :			_InputIterator __last, std::input_iterator_tag);
                               :
                               :      // Called by the second insert_dispatch above
                               :      template<typename _ForwardIterator>
                               :        void
                               :        _M_range_insert(iterator __pos, _ForwardIterator __first,
                               :			_ForwardIterator __last, std::forward_iterator_tag);
                               :
                               :      // Called by insert(p,n,x), and the range insert when it turns out to be
                               :      // the same thing.
                               :      void
                               :      _M_fill_insert(iterator __pos, size_type __n, const value_type& __x);
                               :
                               :#if __cplusplus >= 201103L
                               :      // Called by resize(n).
                               :      void
                               :      _M_default_append(size_type __n);
                               :
                               :      bool
                               :      _M_shrink_to_fit();
                               :#endif
                               :
                               :      // Called by insert(p,x)
                               :#if __cplusplus < 201103L
                               :      void
                               :      _M_insert_aux(iterator __position, const value_type& __x);
                               :#else
                               :      template<typename... _Args>
                               :        void
                               :        _M_insert_aux(iterator __position, _Args&&... __args);
                               :
                               :      template<typename... _Args>
                               :        void
                               :        _M_emplace_back_aux(_Args&&... __args);
                               :#endif
                               :
                               :      // Called by the latter.
                               :      size_type
    24  0.0204     0       0   :      _M_check_len(size_type __n, const char* __s) const
                               :      {
    72  0.0613     0       0   :	if (max_size() - size() < __n)
    18  0.0153     0       0   :	  __throw_length_error(__N(__s));
                               :
    11  0.0094     1  0.0591   :	const size_type __len = size() + std::max(size(), __n);
   121  0.1029     0       0   :	return (__len < size() || __len > max_size()) ? max_size() : __len;
                               :      }
                               :
                               :      // Internal erase functions follow.
                               :
                               :      // Called by erase(q1,q2), clear(), resize(), _M_fill_assign,
                               :      // _M_assign_aux.
                               :      void
                               :      _M_erase_at_end(pointer __pos)
                               :      {
                               :	std::_Destroy(__pos, this->_M_impl._M_finish, _M_get_Tp_allocator());
                               :	this->_M_impl._M_finish = __pos;
                               :      }
                               :
                               :#if __cplusplus >= 201103L
                               :    private:
                               :      // Constant-time move assignment when source object's memory can be
                               :      // moved, either because the source's allocator will move too
                               :      // or because the allocators are equal.
                               :      void
                               :      _M_move_assign(vector&& __x, std::true_type) noexcept
                               :      {
                               :	vector __tmp(get_allocator());
                               :	this->_M_impl._M_swap_data(__tmp._M_impl);
                               :	this->_M_impl._M_swap_data(__x._M_impl);
                               :	if (_Alloc_traits::_S_propagate_on_move_assign())
                               :	  std::__alloc_on_move(_M_get_Tp_allocator(),
                               :			       __x._M_get_Tp_allocator());
                               :      }
                               :
                               :      // Do move assignment when it might not be possible to move source
                               :      // object's memory, resulting in a linear-time operation.
                               :      void
                               :      _M_move_assign(vector&& __x, std::false_type)
                               :      {
                               :	if (__x._M_get_Tp_allocator() == this->_M_get_Tp_allocator())
                               :	  _M_move_assign(std::move(__x), std::true_type());
                               :	else
                               :	  {
                               :	    // The rvalue's allocator cannot be moved and is not equal,
                               :	    // so we need to individually move each element.
                               :	    this->assign(std::__make_move_if_noexcept_iterator(__x.begin()),
                               :			 std::__make_move_if_noexcept_iterator(__x.end()));
                               :	    __x.clear();
                               :	  }
                               :      }
                               :#endif
                               :    };
                               :
                               :
                               :  /**
                               :   *  @brief  Vector equality comparison.
                               :   *  @param  __x  A %vector.
                               :   *  @param  __y  A %vector of the same type as @a __x.
                               :   *  @return  True iff the size and elements of the vectors are equal.
                               :   *
                               :   *  This is an equivalence relation.  It is linear in the size of the
                               :   *  vectors.  Vectors are considered equivalent if their sizes are equal,
                               :   *  and if corresponding elements compare equal.
                               :  */
                               :  template<typename _Tp, typename _Alloc>
                               :    inline bool
   151  0.1285     0       0   :    operator==(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
                               :    { return (__x.size() == __y.size()
   102  0.0868     0       0   :	      && std::equal(__x.begin(), __x.end(), __y.begin())); }
                               :
                               :  /**
                               :   *  @brief  Vector ordering relation.
                               :   *  @param  __x  A %vector.
                               :   *  @param  __y  A %vector of the same type as @a __x.
                               :   *  @return  True iff @a __x is lexicographically less than @a __y.
                               :   *
                               :   *  This is a total ordering relation.  It is linear in the size of the
                               :   *  vectors.  The elements must be comparable with @c <.
                               :   *
                               :   *  See std::lexicographical_compare() for how the determination is made.
                               :  */
                               :  template<typename _Tp, typename _Alloc>
                               :    inline bool
                               :    operator<(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
                               :    { return std::lexicographical_compare(__x.begin(), __x.end(),
                               :					  __y.begin(), __y.end()); }
                               :
                               :  /// Based on operator==
                               :  template<typename _Tp, typename _Alloc>
                               :    inline bool
                               :    operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
                               :    { return !(__x == __y); }
                               :
                               :  /// Based on operator<
                               :  template<typename _Tp, typename _Alloc>
                               :    inline bool
                               :    operator>(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
                               :    { return __y < __x; }
                               :
                               :  /// Based on operator<
                               :  template<typename _Tp, typename _Alloc>
                               :    inline bool
                               :    operator<=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
                               :    { return !(__y < __x); }
                               :
                               :  /// Based on operator<
                               :  template<typename _Tp, typename _Alloc>
                               :    inline bool
                               :    operator>=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
                               :    { return !(__x < __y); }
                               :
                               :  /// See std::vector::swap().
                               :  template<typename _Tp, typename _Alloc>
                               :    inline void
                               :    swap(vector<_Tp, _Alloc>& __x, vector<_Tp, _Alloc>& __y)
                               :    { __x.swap(__y); }
                               :
                               :_GLIBCXX_END_NAMESPACE_CONTAINER
                               :} // namespace std
                               :
                               :#endif /* _STL_VECTOR_H */
/* 
 * Total samples for file : "/usr/include/c++/4.8/ext/new_allocator.h"
 * 
 *   5193  4.4181   441 26.0484
 */


                               :// Allocator that wraps operator new -*- C++ -*-
                               :
                               :// Copyright (C) 2001-2013 Free Software Foundation, Inc.
                               ://
                               :// This file is part of the GNU ISO C++ Library.  This library is free
                               :// software; you can redistribute it and/or modify it under the
                               :// terms of the GNU General Public License as published by the
                               :// Free Software Foundation; either version 3, or (at your option)
                               :// any later version.
                               :
                               :// This library is distributed in the hope that it will be useful,
                               :// but WITHOUT ANY WARRANTY; without even the implied warranty of
                               :// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                               :// GNU General Public License for more details.
                               :
                               :// Under Section 7 of GPL version 3, you are granted additional
                               :// permissions described in the GCC Runtime Library Exception, version
                               :// 3.1, as published by the Free Software Foundation.
                               :
                               :// You should have received a copy of the GNU General Public License and
                               :// a copy of the GCC Runtime Library Exception along with this program;
                               :// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                               :// <http://www.gnu.org/licenses/>.
                               :
                               :/** @file ext/new_allocator.h
                               : *  This file is a GNU extension to the Standard C++ Library.
                               : */
                               :
                               :#ifndef _NEW_ALLOCATOR_H
                               :#define _NEW_ALLOCATOR_H 1
                               :
                               :#include <bits/c++config.h>
                               :#include <new>
                               :#include <bits/functexcept.h>
                               :#include <bits/move.h>
                               :#if __cplusplus >= 201103L
                               :#include <type_traits>
                               :#endif
                               :
                               :namespace __gnu_cxx _GLIBCXX_VISIBILITY(default)
                               :{
                               :_GLIBCXX_BEGIN_NAMESPACE_VERSION
                               :
                               :  using std::size_t;
                               :  using std::ptrdiff_t;
                               :
                               :  /**
                               :   *  @brief  An allocator that uses global new, as per [20.4].
                               :   *  @ingroup allocators
                               :   *
                               :   *  This is precisely the allocator defined in the C++ Standard. 
                               :   *    - all allocation calls operator new
                               :   *    - all deallocation calls operator delete
                               :   *
                               :   *  @tparam  _Tp  Type of allocated object.
                               :   */
                               :  template<typename _Tp>
                               :    class new_allocator
                               :    {
                               :    public:
                               :      typedef size_t     size_type;
                               :      typedef ptrdiff_t  difference_type;
                               :      typedef _Tp*       pointer;
                               :      typedef const _Tp* const_pointer;
                               :      typedef _Tp&       reference;
                               :      typedef const _Tp& const_reference;
                               :      typedef _Tp        value_type;
                               :
                               :      template<typename _Tp1>
                               :        struct rebind
                               :        { typedef new_allocator<_Tp1> other; };
                               :
                               :#if __cplusplus >= 201103L
                               :      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                               :      // 2103. propagate_on_container_move_assignment
                               :      typedef std::true_type propagate_on_container_move_assignment;
                               :#endif
                               :
                               :      new_allocator() _GLIBCXX_USE_NOEXCEPT { }
                               :
                               :      new_allocator(const new_allocator&) _GLIBCXX_USE_NOEXCEPT { }
                               :
                               :      template<typename _Tp1>
                               :        new_allocator(const new_allocator<_Tp1>&) _GLIBCXX_USE_NOEXCEPT { }
                               :
                               :      ~new_allocator() _GLIBCXX_USE_NOEXCEPT { }
                               :
                               :      pointer
                               :      address(reference __x) const _GLIBCXX_NOEXCEPT
                               :      { return std::__addressof(__x); }
                               :
                               :      const_pointer
                               :      address(const_reference __x) const _GLIBCXX_NOEXCEPT
                               :      { return std::__addressof(__x); }
                               :
                               :      // NB: __n is permitted to be 0.  The C++ standard says nothing
                               :      // about what the return value is when __n == 0.
                               :      pointer
                               :      allocate(size_type __n, const void* = 0)
                               :      { 
     7  0.0060     0       0   :	if (__n > this->max_size())
                               :	  std::__throw_bad_alloc();
                               :
   322  0.2740     1  0.0591   :	return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
                               :      }
                               :
                               :      // __p is not permitted to be a null pointer.
                               :      void
                               :      deallocate(pointer __p, size_type)
    65  0.0553     0       0   :      { ::operator delete(__p); }
                               :
                               :      size_type
                               :      max_size() const _GLIBCXX_USE_NOEXCEPT
                               :      { return size_t(-1) / sizeof(_Tp); }
                               :
                               :#if __cplusplus >= 201103L
                               :      template<typename _Up, typename... _Args>
                               :        void
                               :        construct(_Up* __p, _Args&&... __args)
  4799  4.0829   440 25.9894   :	{ ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }
                               :
                               :      template<typename _Up>
                               :        void 
                               :        destroy(_Up* __p) { __p->~_Up(); }
                               :#else
                               :      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                               :      // 402. wrong new expression in [some_] allocator::construct
                               :      void 
                               :      construct(pointer __p, const _Tp& __val) 
                               :      { ::new((void *)__p) _Tp(__val); }
                               :
                               :      void 
                               :      destroy(pointer __p) { __p->~_Tp(); }
                               :#endif
                               :    };
                               :
                               :  template<typename _Tp>
                               :    inline bool
                               :    operator==(const new_allocator<_Tp>&, const new_allocator<_Tp>&)
                               :    { return true; }
                               :  
                               :  template<typename _Tp>
                               :    inline bool
                               :    operator!=(const new_allocator<_Tp>&, const new_allocator<_Tp>&)
                               :    { return false; }
                               :
                               :_GLIBCXX_END_NAMESPACE_VERSION
                               :} // namespace
                               :
                               :#endif
/* 
 * Total samples for file : "/usr/include/c++/4.8/bitset"
 * 
 *   5153  4.3841     0       0
 */


                               :// <bitset> -*- C++ -*-
                               :
                               :// Copyright (C) 2001-2013 Free Software Foundation, Inc.
                               ://
                               :// This file is part of the GNU ISO C++ Library.  This library is free
                               :// software; you can redistribute it and/or modify it under the
                               :// terms of the GNU General Public License as published by the
                               :// Free Software Foundation; either version 3, or (at your option)
                               :// any later version.
                               :
                               :// This library is distributed in the hope that it will be useful,
                               :// but WITHOUT ANY WARRANTY; without even the implied warranty of
                               :// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                               :// GNU General Public License for more details.
                               :
                               :// Under Section 7 of GPL version 3, you are granted additional
                               :// permissions described in the GCC Runtime Library Exception, version
                               :// 3.1, as published by the Free Software Foundation.
                               :
                               :// You should have received a copy of the GNU General Public License and
                               :// a copy of the GCC Runtime Library Exception along with this program;
                               :// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                               :// <http://www.gnu.org/licenses/>.
                               :
                               :/*
                               : * Copyright (c) 1998
                               : * Silicon Graphics Computer Systems, Inc.
                               : *
                               : * Permission to use, copy, modify, distribute and sell this software
                               : * and its documentation for any purpose is hereby granted without fee,
                               : * provided that the above copyright notice appear in all copies and
                               : * that both that copyright notice and this permission notice appear
                               : * in supporting documentation.  Silicon Graphics makes no
                               : * representations about the suitability of this software for any
                               : * purpose.  It is provided "as is" without express or implied warranty.
                               : */
                               :
                               :/** @file include/bitset
                               : *  This is a Standard C++ Library header.
                               : */
                               :
                               :#ifndef _GLIBCXX_BITSET
                               :#define _GLIBCXX_BITSET 1
                               :
                               :#pragma GCC system_header
                               :
                               :#include <string>
                               :#include <bits/functexcept.h>   // For invalid_argument, out_of_range,
                               :                                // overflow_error
                               :#include <iosfwd>
                               :#include <bits/cxxabi_forced.h>
                               :
                               :#define _GLIBCXX_BITSET_BITS_PER_WORD  (__CHAR_BIT__ * __SIZEOF_LONG__)
                               :#define _GLIBCXX_BITSET_WORDS(__n) \
                               :  ((__n) / _GLIBCXX_BITSET_BITS_PER_WORD + \
                               :   ((__n) % _GLIBCXX_BITSET_BITS_PER_WORD == 0 ? 0 : 1))
                               :
                               :#define _GLIBCXX_BITSET_BITS_PER_ULL (__CHAR_BIT__ * __SIZEOF_LONG_LONG__)
                               :
                               :namespace std _GLIBCXX_VISIBILITY(default)
                               :{
                               :_GLIBCXX_BEGIN_NAMESPACE_CONTAINER
                               :
                               :  /**
                               :   *  Base class, general case.  It is a class invariant that _Nw will be
                               :   *  nonnegative.
                               :   *
                               :   *  See documentation for bitset.
                               :  */
                               :  template<size_t _Nw>
                               :    struct _Base_bitset
                               :    {
                               :      typedef unsigned long _WordT;
                               :
                               :      /// 0 is the least significant word.
                               :      _WordT 		_M_w[_Nw];
                               :
                               :      _GLIBCXX_CONSTEXPR _Base_bitset() _GLIBCXX_NOEXCEPT
                               :      : _M_w() { }
                               :
                               :#if __cplusplus >= 201103L
                               :      constexpr _Base_bitset(unsigned long long __val) noexcept
                               :      : _M_w{ _WordT(__val)
                               :#if __SIZEOF_LONG_LONG__ > __SIZEOF_LONG__
                               :	       , _WordT(__val >> _GLIBCXX_BITSET_BITS_PER_WORD)
                               :#endif
                               :       } { }
                               :#else
                               :      _Base_bitset(unsigned long __val)
                               :      : _M_w()
                               :      { _M_w[0] = __val; }
                               :#endif
                               :
                               :      static _GLIBCXX_CONSTEXPR size_t
                               :      _S_whichword(size_t __pos) _GLIBCXX_NOEXCEPT
    27  0.0230     0       0   :      { return __pos / _GLIBCXX_BITSET_BITS_PER_WORD; }
                               :
                               :      static _GLIBCXX_CONSTEXPR size_t
                               :      _S_whichbyte(size_t __pos) _GLIBCXX_NOEXCEPT
                               :      { return (__pos % _GLIBCXX_BITSET_BITS_PER_WORD) / __CHAR_BIT__; }
                               :
                               :      static _GLIBCXX_CONSTEXPR size_t
                               :      _S_whichbit(size_t __pos) _GLIBCXX_NOEXCEPT
                               :      { return __pos % _GLIBCXX_BITSET_BITS_PER_WORD; }
                               :
                               :      static _GLIBCXX_CONSTEXPR _WordT
                               :      _S_maskbit(size_t __pos) _GLIBCXX_NOEXCEPT
   327  0.2782     0       0   :      { return (static_cast<_WordT>(1)) << _S_whichbit(__pos); }
                               :
                               :      _WordT&
                               :      _M_getword(size_t __pos) _GLIBCXX_NOEXCEPT
                               :      { return _M_w[_S_whichword(__pos)]; }
                               :
                               :      _GLIBCXX_CONSTEXPR _WordT
                               :      _M_getword(size_t __pos) const _GLIBCXX_NOEXCEPT
                               :      { return _M_w[_S_whichword(__pos)]; }
                               :
                               :#if __cplusplus >= 201103L
                               :      const _WordT*
                               :      _M_getdata() const noexcept
                               :      { return _M_w; }
                               :#endif
                               :
                               :      _WordT&
                               :      _M_hiword() _GLIBCXX_NOEXCEPT
                               :      { return _M_w[_Nw - 1]; }
                               :
                               :      _GLIBCXX_CONSTEXPR _WordT
                               :      _M_hiword() const _GLIBCXX_NOEXCEPT
                               :      { return _M_w[_Nw - 1]; }
                               :
                               :      void
                               :      _M_do_and(const _Base_bitset<_Nw>& __x) _GLIBCXX_NOEXCEPT
                               :      {
  1393  1.1851     0       0   :	for (size_t __i = 0; __i < _Nw; __i++)
   720  0.6126     0       0   :	  _M_w[__i] &= __x._M_w[__i];
                               :      }
                               :
                               :      void
                               :      _M_do_or(const _Base_bitset<_Nw>& __x) _GLIBCXX_NOEXCEPT
                               :      {
                               :	for (size_t __i = 0; __i < _Nw; __i++)
                               :	  _M_w[__i] |= __x._M_w[__i];
                               :      }
                               :
                               :      void
                               :      _M_do_xor(const _Base_bitset<_Nw>& __x) _GLIBCXX_NOEXCEPT
                               :      {
                               :	for (size_t __i = 0; __i < _Nw; __i++)
                               :	  _M_w[__i] ^= __x._M_w[__i];
                               :      }
                               :
                               :      void
                               :      _M_do_left_shift(size_t __shift) _GLIBCXX_NOEXCEPT;
                               :
                               :      void
                               :      _M_do_right_shift(size_t __shift) _GLIBCXX_NOEXCEPT;
                               :
                               :      void
                               :      _M_do_flip() _GLIBCXX_NOEXCEPT
                               :      {
                               :	for (size_t __i = 0; __i < _Nw; __i++)
                               :	  _M_w[__i] = ~_M_w[__i];
                               :      }
                               :
                               :      void
                               :      _M_do_set() _GLIBCXX_NOEXCEPT
                               :      {
                               :	for (size_t __i = 0; __i < _Nw; __i++)
                               :	  _M_w[__i] = ~static_cast<_WordT>(0);
                               :      }
                               :
                               :      void
                               :      _M_do_reset() _GLIBCXX_NOEXCEPT
                               :      { __builtin_memset(_M_w, 0, _Nw * sizeof(_WordT)); }
                               :
                               :      bool
                               :      _M_is_equal(const _Base_bitset<_Nw>& __x) const _GLIBCXX_NOEXCEPT
                               :      {
                               :	for (size_t __i = 0; __i < _Nw; ++__i)
                               :	  if (_M_w[__i] != __x._M_w[__i])
                               :	    return false;
                               :	return true;
                               :      }
                               :
                               :      template<size_t _Nb>
                               :        bool
                               :        _M_are_all() const _GLIBCXX_NOEXCEPT
                               :        {
                               :	  for (size_t __i = 0; __i < _Nw - 1; __i++)
                               :	    if (_M_w[__i] != ~static_cast<_WordT>(0))
                               :	      return false;
                               :	  return _M_hiword() == (~static_cast<_WordT>(0)
                               :				 >> (_Nw * _GLIBCXX_BITSET_BITS_PER_WORD
                               :				     - _Nb));
                               :	}
                               :
                               :      bool
                               :      _M_is_any() const _GLIBCXX_NOEXCEPT
                               :      {
                               :	for (size_t __i = 0; __i < _Nw; __i++)
                               :	  if (_M_w[__i] != static_cast<_WordT>(0))
                               :	    return true;
                               :	return false;
                               :      }
                               :
                               :      size_t
                               :      _M_do_count() const _GLIBCXX_NOEXCEPT
                               :      {
                               :	size_t __result = 0;
                               :	for (size_t __i = 0; __i < _Nw; __i++)
  2062  1.7543     0       0   :	  __result += __builtin_popcountl(_M_w[__i]);
                               :	return __result;
                               :      }
                               :
                               :      unsigned long
                               :      _M_do_to_ulong() const;
                               :
                               :#if __cplusplus >= 201103L
                               :      unsigned long long
                               :      _M_do_to_ullong() const;
                               :#endif
                               :
                               :      // find first "on" bit
                               :      size_t
                               :      _M_do_find_first(size_t) const _GLIBCXX_NOEXCEPT;
                               :
                               :      // find the next "on" bit that follows "prev"
                               :      size_t
                               :      _M_do_find_next(size_t, size_t) const _GLIBCXX_NOEXCEPT;
                               :    };
                               :
                               :  // Definitions of non-inline functions from _Base_bitset.
                               :  template<size_t _Nw>
                               :    void
                               :    _Base_bitset<_Nw>::_M_do_left_shift(size_t __shift) _GLIBCXX_NOEXCEPT
                               :    {
                               :      if (__builtin_expect(__shift != 0, 1))
                               :	{
                               :	  const size_t __wshift = __shift / _GLIBCXX_BITSET_BITS_PER_WORD;
                               :	  const size_t __offset = __shift % _GLIBCXX_BITSET_BITS_PER_WORD;
                               :
                               :	  if (__offset == 0)
                               :	    for (size_t __n = _Nw - 1; __n >= __wshift; --__n)
                               :	      _M_w[__n] = _M_w[__n - __wshift];
                               :	  else
                               :	    {
                               :	      const size_t __sub_offset = (_GLIBCXX_BITSET_BITS_PER_WORD 
                               :					   - __offset);
                               :	      for (size_t __n = _Nw - 1; __n > __wshift; --__n)
                               :		_M_w[__n] = ((_M_w[__n - __wshift] << __offset)
                               :			     | (_M_w[__n - __wshift - 1] >> __sub_offset));
                               :	      _M_w[__wshift] = _M_w[0] << __offset;
                               :	    }
                               :
                               :	  std::fill(_M_w + 0, _M_w + __wshift, static_cast<_WordT>(0));
                               :	}
                               :    }
                               :
                               :  template<size_t _Nw>
                               :    void
                               :    _Base_bitset<_Nw>::_M_do_right_shift(size_t __shift) _GLIBCXX_NOEXCEPT
                               :    {
                               :      if (__builtin_expect(__shift != 0, 1))
                               :	{
                               :	  const size_t __wshift = __shift / _GLIBCXX_BITSET_BITS_PER_WORD;
                               :	  const size_t __offset = __shift % _GLIBCXX_BITSET_BITS_PER_WORD;
                               :	  const size_t __limit = _Nw - __wshift - 1;
                               :
                               :	  if (__offset == 0)
                               :	    for (size_t __n = 0; __n <= __limit; ++__n)
                               :	      _M_w[__n] = _M_w[__n + __wshift];
                               :	  else
                               :	    {
                               :	      const size_t __sub_offset = (_GLIBCXX_BITSET_BITS_PER_WORD
                               :					   - __offset);
                               :	      for (size_t __n = 0; __n < __limit; ++__n)
                               :		_M_w[__n] = ((_M_w[__n + __wshift] >> __offset)
                               :			     | (_M_w[__n + __wshift + 1] << __sub_offset));
                               :	      _M_w[__limit] = _M_w[_Nw-1] >> __offset;
                               :	    }
                               :	  
                               :	  std::fill(_M_w + __limit + 1, _M_w + _Nw, static_cast<_WordT>(0));
                               :	}
                               :    }
                               :
                               :  template<size_t _Nw>
                               :    unsigned long
                               :    _Base_bitset<_Nw>::_M_do_to_ulong() const
                               :    {
                               :      for (size_t __i = 1; __i < _Nw; ++__i)
                               :	if (_M_w[__i])
                               :	  __throw_overflow_error(__N("_Base_bitset::_M_do_to_ulong"));
                               :      return _M_w[0];
                               :    }
                               :
                               :#if __cplusplus >= 201103L
                               :  template<size_t _Nw>
                               :    unsigned long long
                               :    _Base_bitset<_Nw>::_M_do_to_ullong() const
                               :    {
                               :      const bool __dw = sizeof(unsigned long long) > sizeof(unsigned long);
                               :      for (size_t __i = 1 + __dw; __i < _Nw; ++__i)
                               :	if (_M_w[__i])
                               :	  __throw_overflow_error(__N("_Base_bitset::_M_do_to_ullong"));
                               :
                               :      if (__dw)
                               :	return _M_w[0] + (static_cast<unsigned long long>(_M_w[1])
                               :			  << _GLIBCXX_BITSET_BITS_PER_WORD);
                               :      return _M_w[0];
                               :    }
                               :#endif
                               :
                               :  template<size_t _Nw>
                               :    size_t
                               :    _Base_bitset<_Nw>::
                               :    _M_do_find_first(size_t __not_found) const _GLIBCXX_NOEXCEPT
                               :    {
                               :      for (size_t __i = 0; __i < _Nw; __i++)
                               :	{
                               :	  _WordT __thisword = _M_w[__i];
                               :	  if (__thisword != static_cast<_WordT>(0))
                               :	    return (__i * _GLIBCXX_BITSET_BITS_PER_WORD
                               :		    + __builtin_ctzl(__thisword));
                               :	}
                               :      // not found, so return an indication of failure.
                               :      return __not_found;
                               :    }
                               :
                               :  template<size_t _Nw>
                               :    size_t
                               :    _Base_bitset<_Nw>::
                               :    _M_do_find_next(size_t __prev, size_t __not_found) const _GLIBCXX_NOEXCEPT
                               :    {
                               :      // make bound inclusive
                               :      ++__prev;
                               :
                               :      // check out of bounds
                               :      if (__prev >= _Nw * _GLIBCXX_BITSET_BITS_PER_WORD)
                               :	return __not_found;
                               :
                               :      // search first word
                               :      size_t __i = _S_whichword(__prev);
                               :      _WordT __thisword = _M_w[__i];
                               :
                               :      // mask off bits below bound
                               :      __thisword &= (~static_cast<_WordT>(0)) << _S_whichbit(__prev);
                               :
                               :      if (__thisword != static_cast<_WordT>(0))
                               :	return (__i * _GLIBCXX_BITSET_BITS_PER_WORD
                               :		+ __builtin_ctzl(__thisword));
                               :
                               :      // check subsequent words
                               :      __i++;
                               :      for (; __i < _Nw; __i++)
                               :	{
                               :	  __thisword = _M_w[__i];
                               :	  if (__thisword != static_cast<_WordT>(0))
                               :	    return (__i * _GLIBCXX_BITSET_BITS_PER_WORD
                               :		    + __builtin_ctzl(__thisword));
                               :	}
                               :      // not found, so return an indication of failure.
                               :      return __not_found;
                               :    } // end _M_do_find_next
                               :
                               :  /**
                               :   *  Base class, specialization for a single word.
                               :   *
                               :   *  See documentation for bitset.
                               :  */
                               :  template<>
                               :    struct _Base_bitset<1>
                               :    {
                               :      typedef unsigned long _WordT;
                               :      _WordT _M_w;
                               :
                               :      _GLIBCXX_CONSTEXPR _Base_bitset() _GLIBCXX_NOEXCEPT
                               :      : _M_w(0)
                               :      { }
                               :
                               :#if __cplusplus >= 201103L
                               :      constexpr _Base_bitset(unsigned long long __val) noexcept
                               :#else
                               :      _Base_bitset(unsigned long __val)
                               :#endif
                               :      : _M_w(__val)
                               :      { }
                               :
                               :      static _GLIBCXX_CONSTEXPR size_t
                               :      _S_whichword(size_t __pos) _GLIBCXX_NOEXCEPT
                               :      { return __pos / _GLIBCXX_BITSET_BITS_PER_WORD; }
                               :
                               :      static _GLIBCXX_CONSTEXPR size_t
                               :      _S_whichbyte(size_t __pos) _GLIBCXX_NOEXCEPT
                               :      { return (__pos % _GLIBCXX_BITSET_BITS_PER_WORD) / __CHAR_BIT__; }
                               :
                               :      static _GLIBCXX_CONSTEXPR size_t
                               :      _S_whichbit(size_t __pos) _GLIBCXX_NOEXCEPT
                               :      {  return __pos % _GLIBCXX_BITSET_BITS_PER_WORD; }
                               :
                               :      static _GLIBCXX_CONSTEXPR _WordT
                               :      _S_maskbit(size_t __pos) _GLIBCXX_NOEXCEPT
                               :      { return (static_cast<_WordT>(1)) << _S_whichbit(__pos); }
                               :
                               :      _WordT&
                               :      _M_getword(size_t) _GLIBCXX_NOEXCEPT
                               :      { return _M_w; }
                               :
                               :      _GLIBCXX_CONSTEXPR _WordT
                               :      _M_getword(size_t) const _GLIBCXX_NOEXCEPT
                               :      { return _M_w; }
                               :
                               :#if __cplusplus >= 201103L
                               :      const _WordT*
                               :      _M_getdata() const noexcept
                               :      { return &_M_w; }
                               :#endif
                               :
                               :      _WordT&
                               :      _M_hiword() _GLIBCXX_NOEXCEPT
                               :      { return _M_w; }
                               :
                               :      _GLIBCXX_CONSTEXPR _WordT
                               :      _M_hiword() const _GLIBCXX_NOEXCEPT
                               :      { return _M_w; }
                               :
                               :      void
                               :      _M_do_and(const _Base_bitset<1>& __x) _GLIBCXX_NOEXCEPT
                               :      { _M_w &= __x._M_w; }
                               :
                               :      void
                               :      _M_do_or(const _Base_bitset<1>& __x) _GLIBCXX_NOEXCEPT
                               :      { _M_w |= __x._M_w; }
                               :
                               :      void
                               :      _M_do_xor(const _Base_bitset<1>& __x) _GLIBCXX_NOEXCEPT
                               :      { _M_w ^= __x._M_w; }
                               :
                               :      void
                               :      _M_do_left_shift(size_t __shift) _GLIBCXX_NOEXCEPT
                               :      { _M_w <<= __shift; }
                               :
                               :      void
                               :      _M_do_right_shift(size_t __shift) _GLIBCXX_NOEXCEPT
                               :      { _M_w >>= __shift; }
                               :
                               :      void
                               :      _M_do_flip() _GLIBCXX_NOEXCEPT
                               :      { _M_w = ~_M_w; }
                               :
                               :      void
                               :      _M_do_set() _GLIBCXX_NOEXCEPT
                               :      { _M_w = ~static_cast<_WordT>(0); }
                               :
                               :      void
                               :      _M_do_reset() _GLIBCXX_NOEXCEPT
                               :      { _M_w = 0; }
                               :
                               :      bool
                               :      _M_is_equal(const _Base_bitset<1>& __x) const _GLIBCXX_NOEXCEPT
                               :      { return _M_w == __x._M_w; }
                               :
                               :      template<size_t _Nb>
                               :        bool
                               :        _M_are_all() const _GLIBCXX_NOEXCEPT
                               :        { return _M_w == (~static_cast<_WordT>(0)
                               :			  >> (_GLIBCXX_BITSET_BITS_PER_WORD - _Nb)); }
                               :
                               :      bool
                               :      _M_is_any() const _GLIBCXX_NOEXCEPT
                               :      { return _M_w != 0; }
                               :
                               :      size_t
                               :      _M_do_count() const _GLIBCXX_NOEXCEPT
                               :      { return __builtin_popcountl(_M_w); }
                               :
                               :      unsigned long
                               :      _M_do_to_ulong() const _GLIBCXX_NOEXCEPT
                               :      { return _M_w; }
                               :
                               :#if __cplusplus >= 201103L
                               :      unsigned long long
                               :      _M_do_to_ullong() const noexcept
                               :      { return _M_w; }
                               :#endif
                               :
                               :      size_t
                               :      _M_do_find_first(size_t __not_found) const _GLIBCXX_NOEXCEPT
                               :      {
                               :        if (_M_w != 0)
                               :          return __builtin_ctzl(_M_w);
                               :        else
                               :          return __not_found;
                               :      }
                               :
                               :      // find the next "on" bit that follows "prev"
                               :      size_t
                               :      _M_do_find_next(size_t __prev, size_t __not_found) const
                               :	_GLIBCXX_NOEXCEPT
                               :      {
                               :	++__prev;
                               :	if (__prev >= ((size_t) _GLIBCXX_BITSET_BITS_PER_WORD))
                               :	  return __not_found;
                               :
                               :	_WordT __x = _M_w >> __prev;
                               :	if (__x != 0)
                               :	  return __builtin_ctzl(__x) + __prev;
                               :	else
                               :	  return __not_found;
                               :      }
                               :    };
                               :
                               :  /**
                               :   *  Base class, specialization for no storage (zero-length %bitset).
                               :   *
                               :   *  See documentation for bitset.
                               :  */
                               :  template<>
                               :    struct _Base_bitset<0>
                               :    {
                               :      typedef unsigned long _WordT;
                               :
                               :      _GLIBCXX_CONSTEXPR _Base_bitset() _GLIBCXX_NOEXCEPT
                               :      { }
                               :
                               :#if __cplusplus >= 201103L
                               :      constexpr _Base_bitset(unsigned long long) noexcept
                               :#else
                               :      _Base_bitset(unsigned long)
                               :#endif
                               :      { }
                               :
                               :      static _GLIBCXX_CONSTEXPR size_t
                               :      _S_whichword(size_t __pos) _GLIBCXX_NOEXCEPT
                               :      { return __pos / _GLIBCXX_BITSET_BITS_PER_WORD; }
                               :
                               :      static _GLIBCXX_CONSTEXPR size_t
                               :      _S_whichbyte(size_t __pos) _GLIBCXX_NOEXCEPT
                               :      { return (__pos % _GLIBCXX_BITSET_BITS_PER_WORD) / __CHAR_BIT__; }
                               :
                               :      static _GLIBCXX_CONSTEXPR size_t
                               :      _S_whichbit(size_t __pos) _GLIBCXX_NOEXCEPT
                               :      {  return __pos % _GLIBCXX_BITSET_BITS_PER_WORD; }
                               :
                               :      static _GLIBCXX_CONSTEXPR _WordT
                               :      _S_maskbit(size_t __pos) _GLIBCXX_NOEXCEPT
                               :      { return (static_cast<_WordT>(1)) << _S_whichbit(__pos); }
                               :
                               :      // This would normally give access to the data.  The bounds-checking
                               :      // in the bitset class will prevent the user from getting this far,
                               :      // but (1) it must still return an lvalue to compile, and (2) the
                               :      // user might call _Unchecked_set directly, in which case this /needs/
                               :      // to fail.  Let's not penalize zero-length users unless they actually
                               :      // make an unchecked call; all the memory ugliness is therefore
                               :      // localized to this single should-never-get-this-far function.
                               :      _WordT&
                               :      _M_getword(size_t) _GLIBCXX_NOEXCEPT
                               :      {
                               :	__throw_out_of_range(__N("_Base_bitset::_M_getword")); 
                               :	return *new _WordT;
                               :      }
                               :
                               :      _GLIBCXX_CONSTEXPR _WordT
                               :      _M_getword(size_t __pos) const _GLIBCXX_NOEXCEPT
                               :      { return 0; }
                               :
                               :      _GLIBCXX_CONSTEXPR _WordT
                               :      _M_hiword() const _GLIBCXX_NOEXCEPT
                               :      { return 0; }
                               :
                               :      void
                               :      _M_do_and(const _Base_bitset<0>&) _GLIBCXX_NOEXCEPT
                               :      { }
                               :
                               :      void
                               :      _M_do_or(const _Base_bitset<0>&) _GLIBCXX_NOEXCEPT
                               :      { }
                               :
                               :      void
                               :      _M_do_xor(const _Base_bitset<0>&) _GLIBCXX_NOEXCEPT
                               :      { }
                               :
                               :      void
                               :      _M_do_left_shift(size_t) _GLIBCXX_NOEXCEPT
                               :      { }
                               :
                               :      void
                               :      _M_do_right_shift(size_t) _GLIBCXX_NOEXCEPT
                               :      { }
                               :
                               :      void
                               :      _M_do_flip() _GLIBCXX_NOEXCEPT
                               :      { }
                               :
                               :      void
                               :      _M_do_set() _GLIBCXX_NOEXCEPT
                               :      { }
                               :
                               :      void
                               :      _M_do_reset() _GLIBCXX_NOEXCEPT
                               :      { }
                               :
                               :      // Are all empty bitsets equal to each other?  Are they equal to
                               :      // themselves?  How to compare a thing which has no state?  What is
                               :      // the sound of one zero-length bitset clapping?
                               :      bool
                               :      _M_is_equal(const _Base_bitset<0>&) const _GLIBCXX_NOEXCEPT
                               :      { return true; }
                               :
                               :      template<size_t _Nb>
                               :        bool
                               :        _M_are_all() const _GLIBCXX_NOEXCEPT
                               :        { return true; }
                               :
                               :      bool
                               :      _M_is_any() const _GLIBCXX_NOEXCEPT
                               :      { return false; }
                               :
                               :      size_t
                               :      _M_do_count() const _GLIBCXX_NOEXCEPT
                               :      { return 0; }
                               :
                               :      unsigned long
                               :      _M_do_to_ulong() const _GLIBCXX_NOEXCEPT
                               :      { return 0; }
                               :
                               :#if __cplusplus >= 201103L
                               :      unsigned long long
                               :      _M_do_to_ullong() const noexcept
                               :      { return 0; }
                               :#endif
                               :
                               :      // Normally "not found" is the size, but that could also be
                               :      // misinterpreted as an index in this corner case.  Oh well.
                               :      size_t
                               :      _M_do_find_first(size_t) const _GLIBCXX_NOEXCEPT
                               :      { return 0; }
                               :
                               :      size_t
                               :      _M_do_find_next(size_t, size_t) const _GLIBCXX_NOEXCEPT
                               :      { return 0; }
                               :    };
                               :
                               :
                               :  // Helper class to zero out the unused high-order bits in the highest word.
                               :  template<size_t _Extrabits>
                               :    struct _Sanitize
                               :    {
                               :      typedef unsigned long _WordT;
                               :
                               :      static void
                               :      _S_do_sanitize(_WordT& __val) _GLIBCXX_NOEXCEPT
                               :      { __val &= ~((~static_cast<_WordT>(0)) << _Extrabits); }
                               :    };
                               :
                               :  template<>
                               :    struct _Sanitize<0>
                               :    {
                               :      typedef unsigned long _WordT;
                               :
                               :      static void
                               :      _S_do_sanitize(_WordT) _GLIBCXX_NOEXCEPT { } 
                               :    };
                               :
                               :#if __cplusplus >= 201103L
                               :  template<size_t _Nb, bool = _Nb < _GLIBCXX_BITSET_BITS_PER_ULL>
                               :    struct _Sanitize_val
                               :    {
                               :      static constexpr unsigned long long
                               :      _S_do_sanitize_val(unsigned long long __val)
                               :      { return __val; }
                               :    };
                               :
                               :  template<size_t _Nb>
                               :    struct _Sanitize_val<_Nb, true>
                               :    {
                               :      static constexpr unsigned long long
                               :      _S_do_sanitize_val(unsigned long long __val)
                               :      { return __val & ~((~static_cast<unsigned long long>(0)) << _Nb); }
                               :    };
                               :#endif
                               :
                               :  /**
                               :   *  The %bitset class represents a @e fixed-size sequence of bits.
                               :   *
                               :   *  @ingroup containers
                               :   *
                               :   *  (Note that %bitset does @e not meet the formal requirements of a
                               :   *  <a href="tables.html#65">container</a>.  Mainly, it lacks iterators.)
                               :   *
                               :   *  The template argument, @a Nb, may be any non-negative number,
                               :   *  specifying the number of bits (e.g., "0", "12", "1024*1024").
                               :   *
                               :   *  In the general unoptimized case, storage is allocated in word-sized
                               :   *  blocks.  Let B be the number of bits in a word, then (Nb+(B-1))/B
                               :   *  words will be used for storage.  B - Nb%B bits are unused.  (They are
                               :   *  the high-order bits in the highest word.)  It is a class invariant
                               :   *  that those unused bits are always zero.
                               :   *
                               :   *  If you think of %bitset as <em>a simple array of bits</em>, be
                               :   *  aware that your mental picture is reversed: a %bitset behaves
                               :   *  the same way as bits in integers do, with the bit at index 0 in
                               :   *  the <em>least significant / right-hand</em> position, and the bit at
                               :   *  index Nb-1 in the <em>most significant / left-hand</em> position.
                               :   *  Thus, unlike other containers, a %bitset's index <em>counts from
                               :   *  right to left</em>, to put it very loosely.
                               :   *
                               :   *  This behavior is preserved when translating to and from strings.  For
                               :   *  example, the first line of the following program probably prints
                               :   *  <em>b(&apos;a&apos;) is 0001100001</em> on a modern ASCII system.
                               :   *
                               :   *  @code
                               :   *     #include <bitset>
                               :   *     #include <iostream>
                               :   *     #include <sstream>
                               :   *
                               :   *     using namespace std;
                               :   *
                               :   *     int main()
                               :   *     {
                               :   *         long         a = 'a';
                               :   *         bitset<10>   b(a);
                               :   *
                               :   *         cout << "b('a') is " << b << endl;
                               :   *
                               :   *         ostringstream s;
                               :   *         s << b;
                               :   *         string  str = s.str();
                               :   *         cout << "index 3 in the string is " << str[3] << " but\n"
                               :   *              << "index 3 in the bitset is " << b[3] << endl;
                               :   *     }
                               :   *  @endcode
                               :   *
                               :   *  Also see:
                               :   *  http://gcc.gnu.org/onlinedocs/libstdc++/manual/bk01pt12ch33s02.html
                               :   *  for a description of extensions.
                               :   *
                               :   *  Most of the actual code isn't contained in %bitset<> itself, but in the
                               :   *  base class _Base_bitset.  The base class works with whole words, not with
                               :   *  individual bits.  This allows us to specialize _Base_bitset for the
                               :   *  important special case where the %bitset is only a single word.
                               :   *
                               :   *  Extra confusion can result due to the fact that the storage for
                               :   *  _Base_bitset @e is a regular array, and is indexed as such.  This is
                               :   *  carefully encapsulated.
                               :  */
                               :  template<size_t _Nb>
                               :    class bitset
                               :    : private _Base_bitset<_GLIBCXX_BITSET_WORDS(_Nb)>
                               :    {
                               :    private:
                               :      typedef _Base_bitset<_GLIBCXX_BITSET_WORDS(_Nb)> _Base;
                               :      typedef unsigned long _WordT;
                               :
                               :      void
                               :      _M_do_sanitize() _GLIBCXX_NOEXCEPT
                               :      { 
                               :	typedef _Sanitize<_Nb % _GLIBCXX_BITSET_BITS_PER_WORD> __sanitize_type;
                               :	__sanitize_type::_S_do_sanitize(this->_M_hiword());
                               :      }
                               :
                               :#if __cplusplus >= 201103L
                               :      template<typename> friend struct hash;
                               :#endif
                               :
                               :    public:
                               :      /**
                               :       *  This encapsulates the concept of a single bit.  An instance of this
                               :       *  class is a proxy for an actual bit; this way the individual bit
                               :       *  operations are done as faster word-size bitwise instructions.
                               :       *
                               :       *  Most users will never need to use this class directly; conversions
                               :       *  to and from bool are automatic and should be transparent.  Overloaded
                               :       *  operators help to preserve the illusion.
                               :       *
                               :       *  (On a typical system, this <em>bit %reference</em> is 64
                               :       *  times the size of an actual bit.  Ha.)
                               :       */
                               :      class reference
                               :      {
                               :	friend class bitset;
                               :
                               :	_WordT*	_M_wp;
                               :	size_t 	_M_bpos;
                               :	
                               :	// left undefined
                               :	reference();
                               :	
                               :      public:
                               :	reference(bitset& __b, size_t __pos) _GLIBCXX_NOEXCEPT
                               :	{
                               :	  _M_wp = &__b._M_getword(__pos);
                               :	  _M_bpos = _Base::_S_whichbit(__pos);
                               :	}
                               :
                               :	~reference() _GLIBCXX_NOEXCEPT
                               :	{ }
                               :
                               :	// For b[i] = __x;
                               :	reference&
                               :	operator=(bool __x) _GLIBCXX_NOEXCEPT
                               :	{
                               :	  if (__x)
                               :	    *_M_wp |= _Base::_S_maskbit(_M_bpos);
                               :	  else
                               :	    *_M_wp &= ~_Base::_S_maskbit(_M_bpos);
                               :	  return *this;
                               :	}
                               :
                               :	// For b[i] = b[__j];
                               :	reference&
                               :	operator=(const reference& __j) _GLIBCXX_NOEXCEPT
                               :	{
                               :	  if ((*(__j._M_wp) & _Base::_S_maskbit(__j._M_bpos)))
                               :	    *_M_wp |= _Base::_S_maskbit(_M_bpos);
                               :	  else
                               :	    *_M_wp &= ~_Base::_S_maskbit(_M_bpos);
                               :	  return *this;
                               :	}
                               :
                               :	// Flips the bit
                               :	bool
                               :	operator~() const _GLIBCXX_NOEXCEPT
                               :	{ return (*(_M_wp) & _Base::_S_maskbit(_M_bpos)) == 0; }
                               :
                               :	// For __x = b[i];
                               :	operator bool() const _GLIBCXX_NOEXCEPT
                               :	{ return (*(_M_wp) & _Base::_S_maskbit(_M_bpos)) != 0; }
                               :
                               :	// For b[i].flip();
                               :	reference&
                               :	flip() _GLIBCXX_NOEXCEPT
                               :	{
                               :	  *_M_wp ^= _Base::_S_maskbit(_M_bpos);
                               :	  return *this;
                               :	}
                               :      };
                               :      friend class reference;
                               :
                               :      // 23.3.5.1 constructors:
                               :      /// All bits set to zero.
                               :      _GLIBCXX_CONSTEXPR bitset() _GLIBCXX_NOEXCEPT
                               :      { }
                               :
                               :      /// Initial bits bitwise-copied from a single word (others set to zero).
                               :#if __cplusplus >= 201103L
                               :      constexpr bitset(unsigned long long __val) noexcept
                               :      : _Base(_Sanitize_val<_Nb>::_S_do_sanitize_val(__val)) { }
                               :#else
                               :      bitset(unsigned long __val)
                               :      : _Base(__val)
                               :      { _M_do_sanitize(); }
                               :#endif
                               :
                               :      /**
                               :       *  Use a subset of a string.
                               :       *  @param  __s  A string of @a 0 and @a 1 characters.
                               :       *  @param  __position  Index of the first character in @a __s to use;
                               :       *                    defaults to zero.
                               :       *  @throw  std::out_of_range  If @a pos is bigger the size of @a __s.
                               :       *  @throw  std::invalid_argument  If a character appears in the string
                               :       *                                 which is neither @a 0 nor @a 1.
                               :       */
                               :      template<class _CharT, class _Traits, class _Alloc>
                               :	explicit
                               :	bitset(const std::basic_string<_CharT, _Traits, _Alloc>& __s,
                               :	       size_t __position = 0)
                               :	: _Base()
                               :	{
                               :	  if (__position > __s.size())
                               :	    __throw_out_of_range(__N("bitset::bitset initial position "
                               :				     "not valid"));
                               :	  _M_copy_from_string(__s, __position,
                               :			      std::basic_string<_CharT, _Traits, _Alloc>::npos,
                               :			      _CharT('0'), _CharT('1'));
                               :	}
                               :
                               :      /**
                               :       *  Use a subset of a string.
                               :       *  @param  __s  A string of @a 0 and @a 1 characters.
                               :       *  @param  __position  Index of the first character in @a __s to use.
                               :       *  @param  __n    The number of characters to copy.
                               :       *  @throw std::out_of_range If @a __position is bigger the size
                               :       *  of @a __s.
                               :       *  @throw  std::invalid_argument  If a character appears in the string
                               :       *                                 which is neither @a 0 nor @a 1.
                               :       */
                               :      template<class _CharT, class _Traits, class _Alloc>
                               :	bitset(const std::basic_string<_CharT, _Traits, _Alloc>& __s,
                               :	       size_t __position, size_t __n)
                               :	: _Base()
                               :	{
                               :	  if (__position > __s.size())
                               :	    __throw_out_of_range(__N("bitset::bitset initial position "
                               :				     "not valid"));
                               :	  _M_copy_from_string(__s, __position, __n, _CharT('0'), _CharT('1'));
                               :	}
                               :
                               :      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                               :      // 396. what are characters zero and one.
                               :      template<class _CharT, class _Traits, class _Alloc>
                               :	bitset(const std::basic_string<_CharT, _Traits, _Alloc>& __s,
                               :	       size_t __position, size_t __n,
                               :	       _CharT __zero, _CharT __one = _CharT('1'))
                               :	: _Base()
                               :	{
                               :	  if (__position > __s.size())
                               :	    __throw_out_of_range(__N("bitset::bitset initial position "
                               :				     "not valid"));
                               :	  _M_copy_from_string(__s, __position, __n, __zero, __one);
                               :	}
                               :
                               :#if __cplusplus >= 201103L
                               :      /**
                               :       *  Construct from a character %array.
                               :       *  @param  __str  An %array of characters @a zero and @a one.
                               :       *  @param  __n    The number of characters to use.
                               :       *  @param  __zero The character corresponding to the value 0.
                               :       *  @param  __one  The character corresponding to the value 1.
                               :       *  @throw  std::invalid_argument If a character appears in the string
                               :       *                                which is neither @a __zero nor @a __one.
                               :       */
                               :      template<typename _CharT>
                               :        explicit
                               :        bitset(const _CharT* __str,
                               :	       typename std::basic_string<_CharT>::size_type __n
                               :	       = std::basic_string<_CharT>::npos,
                               :	       _CharT __zero = _CharT('0'), _CharT __one = _CharT('1'))
                               :        : _Base()
                               :        {
                               :	  if (!__str)
                               :	    __throw_logic_error(__N("bitset::bitset(const _CharT*, ...)"));
                               :
                               :	  if (__n == std::basic_string<_CharT>::npos)
                               :	    __n = std::char_traits<_CharT>::length(__str);
                               :	  _M_copy_from_ptr<_CharT, std::char_traits<_CharT>>(__str, __n, 0,
                               :							     __n, __zero,
                               :							     __one);
                               :	}
                               :#endif
                               :
                               :      // 23.3.5.2 bitset operations:
                               :      //@{
                               :      /**
                               :       *  Operations on bitsets.
                               :       *  @param  __rhs  A same-sized bitset.
                               :       *
                               :       *  These should be self-explanatory.
                               :       */
                               :      bitset<_Nb>&
                               :      operator&=(const bitset<_Nb>& __rhs) _GLIBCXX_NOEXCEPT
                               :      {
                               :	this->_M_do_and(__rhs);
                               :	return *this;
                               :      }
                               :
                               :      bitset<_Nb>&
                               :      operator|=(const bitset<_Nb>& __rhs) _GLIBCXX_NOEXCEPT
                               :      {
                               :	this->_M_do_or(__rhs);
                               :	return *this;
                               :      }
                               :
                               :      bitset<_Nb>&
                               :      operator^=(const bitset<_Nb>& __rhs) _GLIBCXX_NOEXCEPT
                               :      {
                               :	this->_M_do_xor(__rhs);
                               :	return *this;
                               :      }
                               :      //@}
                               :      
                               :      //@{
                               :      /**
                               :       *  Operations on bitsets.
                               :       *  @param  __position  The number of places to shift.
                               :       *
                               :       *  These should be self-explanatory.
                               :       */
                               :      bitset<_Nb>&
                               :      operator<<=(size_t __position) _GLIBCXX_NOEXCEPT
                               :      {
                               :	if (__builtin_expect(__position < _Nb, 1))
                               :	  {
                               :	    this->_M_do_left_shift(__position);
                               :	    this->_M_do_sanitize();
                               :	  }
                               :	else
                               :	  this->_M_do_reset();
                               :	return *this;
                               :      }
                               :
                               :      bitset<_Nb>&
                               :      operator>>=(size_t __position) _GLIBCXX_NOEXCEPT
                               :      {
                               :	if (__builtin_expect(__position < _Nb, 1))
                               :	  {
                               :	    this->_M_do_right_shift(__position);
                               :	    this->_M_do_sanitize();
                               :	  }
                               :	else
                               :	  this->_M_do_reset();
                               :	return *this;
                               :      }
                               :      //@}
                               :      
                               :      //@{
                               :      /**
                               :       *  These versions of single-bit set, reset, flip, and test are
                               :       *  extensions from the SGI version.  They do no range checking.
                               :       *  @ingroup SGIextensions
                               :       */
                               :      bitset<_Nb>&
                               :      _Unchecked_set(size_t __pos) _GLIBCXX_NOEXCEPT
                               :      {
                               :	this->_M_getword(__pos) |= _Base::_S_maskbit(__pos);
                               :	return *this;
                               :      }
                               :
                               :      bitset<_Nb>&
                               :      _Unchecked_set(size_t __pos, int __val) _GLIBCXX_NOEXCEPT
                               :      {
                               :	if (__val)
   280  0.2382     0       0   :	  this->_M_getword(__pos) |= _Base::_S_maskbit(__pos);
                               :	else
                               :	  this->_M_getword(__pos) &= ~_Base::_S_maskbit(__pos);
                               :	return *this;
                               :      }
                               :
                               :      bitset<_Nb>&
                               :      _Unchecked_reset(size_t __pos) _GLIBCXX_NOEXCEPT
                               :      {
                               :	this->_M_getword(__pos) &= ~_Base::_S_maskbit(__pos);
                               :	return *this;
                               :      }
                               :
                               :      bitset<_Nb>&
                               :      _Unchecked_flip(size_t __pos) _GLIBCXX_NOEXCEPT
                               :      {
                               :	this->_M_getword(__pos) ^= _Base::_S_maskbit(__pos);
                               :	return *this;
                               :      }
                               :
                               :      _GLIBCXX_CONSTEXPR bool
                               :      _Unchecked_test(size_t __pos) const _GLIBCXX_NOEXCEPT
                               :      { return ((this->_M_getword(__pos) & _Base::_S_maskbit(__pos))
                               :		!= static_cast<_WordT>(0)); }
                               :      //@}
                               :      
                               :      // Set, reset, and flip.
                               :      /**
                               :       *  @brief Sets every bit to true.
                               :       */
                               :      bitset<_Nb>&
                               :      set() _GLIBCXX_NOEXCEPT
                               :      {
                               :	this->_M_do_set();
                               :	this->_M_do_sanitize();
                               :	return *this;
                               :      }
                               :
                               :      /**
                               :       *  @brief Sets a given bit to a particular value.
                               :       *  @param  __position  The index of the bit.
                               :       *  @param  __val  Either true or false, defaults to true.
                               :       *  @throw  std::out_of_range  If @a pos is bigger the size of the %set.
                               :       */
                               :      bitset<_Nb>&
                               :      set(size_t __position, bool __val = true)
                               :      {
    62  0.0527     0       0   :	if (__position >= _Nb)
                               :	  __throw_out_of_range(__N("bitset::set"));
                               :	return _Unchecked_set(__position, __val);
                               :      }
                               :
                               :      /**
                               :       *  @brief Sets every bit to false.
                               :       */
                               :      bitset<_Nb>&
                               :      reset() _GLIBCXX_NOEXCEPT
                               :      {
                               :	this->_M_do_reset();
                               :	return *this;
                               :      }
                               :
                               :      /**
                               :       *  @brief Sets a given bit to false.
                               :       *  @param  __position  The index of the bit.
                               :       *  @throw  std::out_of_range  If @a pos is bigger the size of the %set.
                               :       *
                               :       *  Same as writing @c set(pos,false).
                               :       */
                               :      bitset<_Nb>&
                               :      reset(size_t __position)
                               :      {
                               :	if (__position >= _Nb)
                               :	  __throw_out_of_range(__N("bitset::reset"));
                               :	return _Unchecked_reset(__position);
                               :      }
                               :      
                               :      /**
                               :       *  @brief Toggles every bit to its opposite value.
                               :       */
                               :      bitset<_Nb>&
                               :      flip() _GLIBCXX_NOEXCEPT
                               :      {
                               :	this->_M_do_flip();
                               :	this->_M_do_sanitize();
                               :	return *this;
                               :      }
                               :
                               :      /**
                               :       *  @brief Toggles a given bit to its opposite value.
                               :       *  @param  __position  The index of the bit.
                               :       *  @throw  std::out_of_range  If @a pos is bigger the size of the %set.
                               :       */
                               :      bitset<_Nb>&
                               :      flip(size_t __position)
                               :      {
                               :	if (__position >= _Nb)
                               :	  __throw_out_of_range(__N("bitset::flip"));
                               :	return _Unchecked_flip(__position);
                               :      }
                               :      
                               :      /// See the no-argument flip().
                               :      bitset<_Nb>
                               :      operator~() const _GLIBCXX_NOEXCEPT
                               :      { return bitset<_Nb>(*this).flip(); }
                               :
                               :      //@{
                               :      /**
                               :       *  @brief  Array-indexing support.
                               :       *  @param  __position  Index into the %bitset.
                               :       *  @return A bool for a <em>const %bitset</em>.  For non-const
                               :       *           bitsets, an instance of the reference proxy class.
                               :       *  @note  These operators do no range checking and throw no exceptions,
                               :       *         as required by DR 11 to the standard.
                               :       *
                               :       *  _GLIBCXX_RESOLVE_LIB_DEFECTS Note that this implementation already
                               :       *  resolves DR 11 (items 1 and 2), but does not do the range-checking
                               :       *  required by that DR's resolution.  -pme
                               :       *  The DR has since been changed:  range-checking is a precondition
                               :       *  (users' responsibility), and these functions must not throw.  -pme
                               :       */
                               :      reference
                               :      operator[](size_t __position)
                               :      { return reference(*this, __position); }
                               :
                               :      _GLIBCXX_CONSTEXPR bool
                               :      operator[](size_t __position) const
                               :      { return _Unchecked_test(__position); }
                               :      //@}
                               :      
                               :      /**
                               :       *  @brief Returns a numerical interpretation of the %bitset.
                               :       *  @return  The integral equivalent of the bits.
                               :       *  @throw  std::overflow_error  If there are too many bits to be
                               :       *                               represented in an @c unsigned @c long.
                               :       */
                               :      unsigned long
                               :      to_ulong() const
                               :      { return this->_M_do_to_ulong(); }
                               :
                               :#if __cplusplus >= 201103L
                               :      unsigned long long
                               :      to_ullong() const
                               :      { return this->_M_do_to_ullong(); }
                               :#endif
                               :
                               :      /**
                               :       *  @brief Returns a character interpretation of the %bitset.
                               :       *  @return  The string equivalent of the bits.
                               :       *
                               :       *  Note the ordering of the bits:  decreasing character positions
                               :       *  correspond to increasing bit positions (see the main class notes for
                               :       *  an example).
                               :       */
                               :      template<class _CharT, class _Traits, class _Alloc>
                               :	std::basic_string<_CharT, _Traits, _Alloc>
                               :	to_string() const
                               :	{
                               :	  std::basic_string<_CharT, _Traits, _Alloc> __result;
                               :	  _M_copy_to_string(__result, _CharT('0'), _CharT('1'));
                               :	  return __result;
                               :	}
                               :
                               :      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                               :      // 396. what are characters zero and one.
                               :      template<class _CharT, class _Traits, class _Alloc>
                               :	std::basic_string<_CharT, _Traits, _Alloc>
                               :	to_string(_CharT __zero, _CharT __one = _CharT('1')) const
                               :	{
                               :	  std::basic_string<_CharT, _Traits, _Alloc> __result;
                               :	  _M_copy_to_string(__result, __zero, __one);
                               :	  return __result;
                               :	}
                               :
                               :      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                               :      // 434. bitset::to_string() hard to use.
                               :      template<class _CharT, class _Traits>
                               :	std::basic_string<_CharT, _Traits, std::allocator<_CharT> >
                               :	to_string() const
                               :	{ return to_string<_CharT, _Traits, std::allocator<_CharT> >(); }
                               :
                               :      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                               :      // 853. to_string needs updating with zero and one.
                               :      template<class _CharT, class _Traits>
                               :	std::basic_string<_CharT, _Traits, std::allocator<_CharT> >
                               :	to_string(_CharT __zero, _CharT __one = _CharT('1')) const
                               :	{ return to_string<_CharT, _Traits,
                               :	                   std::allocator<_CharT> >(__zero, __one); }
                               :
                               :      template<class _CharT>
                               :	std::basic_string<_CharT, std::char_traits<_CharT>,
                               :	                  std::allocator<_CharT> >
                               :	to_string() const
                               :	{
                               :	  return to_string<_CharT, std::char_traits<_CharT>,
                               :	                   std::allocator<_CharT> >();
                               :	}
                               :
                               :      template<class _CharT>
                               :	std::basic_string<_CharT, std::char_traits<_CharT>,
                               :	                  std::allocator<_CharT> >
                               :	to_string(_CharT __zero, _CharT __one = _CharT('1')) const
                               :	{
                               :	  return to_string<_CharT, std::char_traits<_CharT>,
                               :	                   std::allocator<_CharT> >(__zero, __one);
                               :	}
                               :
                               :      std::basic_string<char, std::char_traits<char>, std::allocator<char> >
                               :      to_string() const
                               :      {
                               :	return to_string<char, std::char_traits<char>,
                               :	                 std::allocator<char> >();
                               :      }
                               :
                               :      std::basic_string<char, std::char_traits<char>, std::allocator<char> >
                               :      to_string(char __zero, char __one = '1') const
                               :      {
                               :	return to_string<char, std::char_traits<char>,
                               :	                 std::allocator<char> >(__zero, __one);
                               :      }
                               :
                               :      // Helper functions for string operations.
                               :      template<class _CharT, class _Traits>
                               :        void
                               :        _M_copy_from_ptr(const _CharT*, size_t, size_t, size_t,
                               :			 _CharT, _CharT);
                               :
                               :      template<class _CharT, class _Traits, class _Alloc>
                               :	void
                               :	_M_copy_from_string(const std::basic_string<_CharT,
                               :			    _Traits, _Alloc>& __s, size_t __pos, size_t __n,
                               :			    _CharT __zero, _CharT __one)
                               :	{ _M_copy_from_ptr<_CharT, _Traits>(__s.data(), __s.size(), __pos, __n,
                               :					    __zero, __one); }
                               :
                               :      template<class _CharT, class _Traits, class _Alloc>
                               :	void
                               :        _M_copy_to_string(std::basic_string<_CharT, _Traits, _Alloc>&,
                               :			  _CharT, _CharT) const;
                               :
                               :      // NB: Backward compat.
                               :      template<class _CharT, class _Traits, class _Alloc>
                               :	void
                               :	_M_copy_from_string(const std::basic_string<_CharT,
                               :			    _Traits, _Alloc>& __s, size_t __pos, size_t __n)
                               :	{ _M_copy_from_string(__s, __pos, __n, _CharT('0'), _CharT('1')); }
                               :
                               :      template<class _CharT, class _Traits, class _Alloc>
                               :	void
                               :        _M_copy_to_string(std::basic_string<_CharT, _Traits,_Alloc>& __s) const
                               :	{ _M_copy_to_string(__s, _CharT('0'), _CharT('1')); }
                               :
                               :      /// Returns the number of bits which are set.
                               :      size_t
                               :      count() const _GLIBCXX_NOEXCEPT
                               :      { return this->_M_do_count(); }
                               :
                               :      /// Returns the total number of bits.
                               :      _GLIBCXX_CONSTEXPR size_t
                               :      size() const _GLIBCXX_NOEXCEPT
                               :      { return _Nb; }
                               :
                               :      //@{
                               :      /// These comparisons for equality/inequality are, well, @e bitwise.
                               :      bool
                               :      operator==(const bitset<_Nb>& __rhs) const _GLIBCXX_NOEXCEPT
                               :      { return this->_M_is_equal(__rhs); }
                               :
                               :      bool
                               :      operator!=(const bitset<_Nb>& __rhs) const _GLIBCXX_NOEXCEPT
                               :      { return !this->_M_is_equal(__rhs); }
                               :      //@}
                               :      
                               :      /**
                               :       *  @brief Tests the value of a bit.
                               :       *  @param  __position  The index of a bit.
                               :       *  @return  The value at @a pos.
                               :       *  @throw  std::out_of_range  If @a pos is bigger the size of the %set.
                               :       */
                               :      bool
                               :      test(size_t __position) const
                               :      {
                               :	if (__position >= _Nb)
                               :	  __throw_out_of_range(__N("bitset::test"));
                               :	return _Unchecked_test(__position);
                               :      }
                               :
                               :      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                               :      // DR 693. std::bitset::all() missing.
                               :      /**
                               :       *  @brief Tests whether all the bits are on.
                               :       *  @return  True if all the bits are set.
                               :       */
                               :      bool
                               :      all() const _GLIBCXX_NOEXCEPT
                               :      { return this->template _M_are_all<_Nb>(); }
                               :
                               :      /**
                               :       *  @brief Tests whether any of the bits are on.
                               :       *  @return  True if at least one bit is set.
                               :       */
                               :      bool
                               :      any() const _GLIBCXX_NOEXCEPT
                               :      { return this->_M_is_any(); }
                               :
                               :      /**
                               :       *  @brief Tests whether any of the bits are on.
                               :       *  @return  True if none of the bits are set.
                               :       */
                               :      bool
                               :      none() const _GLIBCXX_NOEXCEPT
                               :      { return !this->_M_is_any(); }
                               :
                               :      //@{
                               :      /// Self-explanatory.
                               :      bitset<_Nb>
                               :      operator<<(size_t __position) const _GLIBCXX_NOEXCEPT
                               :      { return bitset<_Nb>(*this) <<= __position; }
                               :
                               :      bitset<_Nb>
                               :      operator>>(size_t __position) const _GLIBCXX_NOEXCEPT
                               :      { return bitset<_Nb>(*this) >>= __position; }
                               :      //@}
                               :      
                               :      /**
                               :       *  @brief  Finds the index of the first "on" bit.
                               :       *  @return  The index of the first bit set, or size() if not found.
                               :       *  @ingroup SGIextensions
                               :       *  @sa  _Find_next
                               :       */
                               :      size_t
                               :      _Find_first() const _GLIBCXX_NOEXCEPT
                               :      { return this->_M_do_find_first(_Nb); }
                               :
                               :      /**
                               :       *  @brief  Finds the index of the next "on" bit after prev.
                               :       *  @return  The index of the next bit set, or size() if not found.
                               :       *  @param  __prev  Where to start searching.
                               :       *  @ingroup SGIextensions
                               :       *  @sa  _Find_first
                               :       */
                               :      size_t
                               :      _Find_next(size_t __prev) const _GLIBCXX_NOEXCEPT
                               :      { return this->_M_do_find_next(__prev, _Nb); }
                               :    };
                               :
                               :  // Definitions of non-inline member functions.
                               :  template<size_t _Nb>
                               :    template<class _CharT, class _Traits>
                               :      void
                               :      bitset<_Nb>::
                               :      _M_copy_from_ptr(const _CharT* __s, size_t __len,
                               :		       size_t __pos, size_t __n, _CharT __zero, _CharT __one)
                               :      {
                               :	reset();
                               :	const size_t __nbits = std::min(_Nb, std::min(__n, size_t(__len - __pos)));
                               :	for (size_t __i = __nbits; __i > 0; --__i)
                               :	  {
                               :	    const _CharT __c = __s[__pos + __nbits - __i];
                               :	    if (_Traits::eq(__c, __zero))
                               :	      ;
                               :	    else if (_Traits::eq(__c, __one))
                               :	      _Unchecked_set(__i - 1);
                               :	    else
                               :	      __throw_invalid_argument(__N("bitset::_M_copy_from_ptr"));
                               :	  }
                               :      }
                               :
                               :  template<size_t _Nb>
                               :    template<class _CharT, class _Traits, class _Alloc>
                               :      void
                               :      bitset<_Nb>::
                               :      _M_copy_to_string(std::basic_string<_CharT, _Traits, _Alloc>& __s,
                               :			_CharT __zero, _CharT __one) const
                               :      {
                               :	__s.assign(_Nb, __zero);
                               :	for (size_t __i = _Nb; __i > 0; --__i)
                               :	  if (_Unchecked_test(__i - 1))
                               :	    _Traits::assign(__s[_Nb - __i], __one);
                               :      }
                               :
                               :  // 23.3.5.3 bitset operations:
                               :  //@{
                               :  /**
                               :   *  @brief  Global bitwise operations on bitsets.
                               :   *  @param  __x  A bitset.
                               :   *  @param  __y  A bitset of the same size as @a __x.
                               :   *  @return  A new bitset.
                               :   *
                               :   *  These should be self-explanatory.
                               :  */
                               :  template<size_t _Nb>
                               :    inline bitset<_Nb>
                               :    operator&(const bitset<_Nb>& __x, const bitset<_Nb>& __y) _GLIBCXX_NOEXCEPT
                               :    {
   282  0.2399     0       0   :      bitset<_Nb> __result(__x);
                               :      __result &= __y;
                               :      return __result;
                               :    }
                               :
                               :  template<size_t _Nb>
                               :    inline bitset<_Nb>
                               :    operator|(const bitset<_Nb>& __x, const bitset<_Nb>& __y) _GLIBCXX_NOEXCEPT
                               :    {
                               :      bitset<_Nb> __result(__x);
                               :      __result |= __y;
                               :      return __result;
                               :    }
                               :
                               :  template <size_t _Nb>
                               :    inline bitset<_Nb>
                               :    operator^(const bitset<_Nb>& __x, const bitset<_Nb>& __y) _GLIBCXX_NOEXCEPT
                               :    {
                               :      bitset<_Nb> __result(__x);
                               :      __result ^= __y;
                               :      return __result;
                               :    }
                               :  //@}
                               :
                               :  //@{
                               :  /**
                               :   *  @brief Global I/O operators for bitsets.
                               :   *
                               :   *  Direct I/O between streams and bitsets is supported.  Output is
                               :   *  straightforward.  Input will skip whitespace, only accept @a 0 and @a 1
                               :   *  characters, and will only extract as many digits as the %bitset will
                               :   *  hold.
                               :  */
                               :  template<class _CharT, class _Traits, size_t _Nb>
                               :    std::basic_istream<_CharT, _Traits>&
                               :    operator>>(std::basic_istream<_CharT, _Traits>& __is, bitset<_Nb>& __x)
                               :    {
                               :      typedef typename _Traits::char_type          char_type;
                               :      typedef std::basic_istream<_CharT, _Traits>  __istream_type;
                               :      typedef typename __istream_type::ios_base    __ios_base;
                               :
                               :      std::basic_string<_CharT, _Traits> __tmp;
                               :      __tmp.reserve(_Nb);
                               :
                               :      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                               :      // 303. Bitset input operator underspecified
                               :      const char_type __zero = __is.widen('0');
                               :      const char_type __one = __is.widen('1');
                               :
                               :      typename __ios_base::iostate __state = __ios_base::goodbit;
                               :      typename __istream_type::sentry __sentry(__is);
                               :      if (__sentry)
                               :	{
                               :	  __try
                               :	    {
                               :	      for (size_t __i = _Nb; __i > 0; --__i)
                               :		{
                               :		  static typename _Traits::int_type __eof = _Traits::eof();
                               :		  
                               :		  typename _Traits::int_type __c1 = __is.rdbuf()->sbumpc();
                               :		  if (_Traits::eq_int_type(__c1, __eof))
                               :		    {
                               :		      __state |= __ios_base::eofbit;
                               :		      break;
                               :		    }
                               :		  else
                               :		    {
                               :		      const char_type __c2 = _Traits::to_char_type(__c1);
                               :		      if (_Traits::eq(__c2, __zero))
                               :			__tmp.push_back(__zero);
                               :		      else if (_Traits::eq(__c2, __one))
                               :			__tmp.push_back(__one);
                               :		      else if (_Traits::
                               :			       eq_int_type(__is.rdbuf()->sputbackc(__c2),
                               :					   __eof))
                               :			{
                               :			  __state |= __ios_base::failbit;
                               :			  break;
                               :			}
                               :		    }
                               :		}
                               :	    }
                               :	  __catch(__cxxabiv1::__forced_unwind&)
                               :	    {
                               :	      __is._M_setstate(__ios_base::badbit);		
                               :	      __throw_exception_again;
                               :	    }
                               :	  __catch(...)
                               :	    { __is._M_setstate(__ios_base::badbit); }
                               :	}
                               :
                               :      if (__tmp.empty() && _Nb)
                               :	__state |= __ios_base::failbit;
                               :      else
                               :	__x._M_copy_from_string(__tmp, static_cast<size_t>(0), _Nb,
                               :				__zero, __one);
                               :      if (__state)
                               :	__is.setstate(__state);
                               :      return __is;
                               :    }
                               :
                               :  template <class _CharT, class _Traits, size_t _Nb>
                               :    std::basic_ostream<_CharT, _Traits>&
                               :    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
                               :	       const bitset<_Nb>& __x)
                               :    {
                               :      std::basic_string<_CharT, _Traits> __tmp;
                               :
                               :      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                               :      // 396. what are characters zero and one.
                               :      const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__os.getloc());
                               :      __x._M_copy_to_string(__tmp, __ct.widen('0'), __ct.widen('1'));
                               :      return __os << __tmp;
                               :    }
                               :  //@}
                               :
                               :_GLIBCXX_END_NAMESPACE_CONTAINER
                               :} // namespace std
                               :
                               :#undef _GLIBCXX_BITSET_WORDS
                               :#undef _GLIBCXX_BITSET_BITS_PER_WORD
                               :#undef _GLIBCXX_BITSET_BITS_PER_ULL
                               :
                               :#if __cplusplus >= 201103L
                               :
                               :#include <bits/functional_hash.h>
                               :
                               :namespace std _GLIBCXX_VISIBILITY(default)
                               :{
                               :_GLIBCXX_BEGIN_NAMESPACE_VERSION
                               :
                               :  // DR 1182.
                               :  /// std::hash specialization for bitset.
                               :  template<size_t _Nb>
                               :    struct hash<_GLIBCXX_STD_C::bitset<_Nb>>
                               :    : public __hash_base<size_t, _GLIBCXX_STD_C::bitset<_Nb>>
                               :    {
                               :      size_t
                               :      operator()(const _GLIBCXX_STD_C::bitset<_Nb>& __b) const noexcept
                               :      {
                               :	const size_t __clength = (_Nb + __CHAR_BIT__ - 1) / __CHAR_BIT__;
                               :	return std::_Hash_impl::hash(__b._M_getdata(), __clength);
                               :      }
                               :    };
                               :
                               :  template<>
                               :    struct hash<_GLIBCXX_STD_C::bitset<0>>
                               :    : public __hash_base<size_t, _GLIBCXX_STD_C::bitset<0>>
                               :    {
                               :      size_t
                               :      operator()(const _GLIBCXX_STD_C::bitset<0>&) const noexcept
                               :      { return 0; }
                               :    };
                               :
                               :_GLIBCXX_END_NAMESPACE_VERSION
                               :} // namespace
                               :
                               :#endif // C++11
                               :
                               :#ifdef _GLIBCXX_DEBUG
                               :# include <debug/bitset>
                               :#endif
                               :
                               :#ifdef _GLIBCXX_PROFILE
                               :# include <profile/bitset>
                               :#endif
                               :
                               :#endif /* _GLIBCXX_BITSET */
/* 
 * Total samples for file : "/usr/include/c++/4.8/bits/stl_iterator.h"
 * 
 *   3219  2.7387     1  0.0591
 */


                               :// Iterators -*- C++ -*-
                               :
                               :// Copyright (C) 2001-2013 Free Software Foundation, Inc.
                               ://
                               :// This file is part of the GNU ISO C++ Library.  This library is free
                               :// software; you can redistribute it and/or modify it under the
                               :// terms of the GNU General Public License as published by the
                               :// Free Software Foundation; either version 3, or (at your option)
                               :// any later version.
                               :
                               :// This library is distributed in the hope that it will be useful,
                               :// but WITHOUT ANY WARRANTY; without even the implied warranty of
                               :// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                               :// GNU General Public License for more details.
                               :
                               :// Under Section 7 of GPL version 3, you are granted additional
                               :// permissions described in the GCC Runtime Library Exception, version
                               :// 3.1, as published by the Free Software Foundation.
                               :
                               :// You should have received a copy of the GNU General Public License and
                               :// a copy of the GCC Runtime Library Exception along with this program;
                               :// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                               :// <http://www.gnu.org/licenses/>.
                               :
                               :/*
                               : *
                               : * Copyright (c) 1994
                               : * Hewlett-Packard Company
                               : *
                               : * Permission to use, copy, modify, distribute and sell this software
                               : * and its documentation for any purpose is hereby granted without fee,
                               : * provided that the above copyright notice appear in all copies and
                               : * that both that copyright notice and this permission notice appear
                               : * in supporting documentation.  Hewlett-Packard Company makes no
                               : * representations about the suitability of this software for any
                               : * purpose.  It is provided "as is" without express or implied warranty.
                               : *
                               : *
                               : * Copyright (c) 1996-1998
                               : * Silicon Graphics Computer Systems, Inc.
                               : *
                               : * Permission to use, copy, modify, distribute and sell this software
                               : * and its documentation for any purpose is hereby granted without fee,
                               : * provided that the above copyright notice appear in all copies and
                               : * that both that copyright notice and this permission notice appear
                               : * in supporting documentation.  Silicon Graphics makes no
                               : * representations about the suitability of this software for any
                               : * purpose.  It is provided "as is" without express or implied warranty.
                               : */
                               :
                               :/** @file bits/stl_iterator.h
                               : *  This is an internal header file, included by other library headers.
                               : *  Do not attempt to use it directly. @headername{iterator}
                               : *
                               : *  This file implements reverse_iterator, back_insert_iterator,
                               : *  front_insert_iterator, insert_iterator, __normal_iterator, and their
                               : *  supporting functions and overloaded operators.
                               : */
                               :
                               :#ifndef _STL_ITERATOR_H
                               :#define _STL_ITERATOR_H 1
                               :
                               :#include <bits/cpp_type_traits.h>
                               :#include <ext/type_traits.h>
                               :#include <bits/move.h>
                               :
                               :namespace std _GLIBCXX_VISIBILITY(default)
                               :{
                               :_GLIBCXX_BEGIN_NAMESPACE_VERSION
                               :
                               :  /**
                               :   * @addtogroup iterators
                               :   * @{
                               :   */
                               :
                               :  // 24.4.1 Reverse iterators
                               :  /**
                               :   *  Bidirectional and random access iterators have corresponding reverse
                               :   *  %iterator adaptors that iterate through the data structure in the
                               :   *  opposite direction.  They have the same signatures as the corresponding
                               :   *  iterators.  The fundamental relation between a reverse %iterator and its
                               :   *  corresponding %iterator @c i is established by the identity:
                               :   *  @code
                               :   *      &*(reverse_iterator(i)) == &*(i - 1)
                               :   *  @endcode
                               :   *
                               :   *  <em>This mapping is dictated by the fact that while there is always a
                               :   *  pointer past the end of an array, there might not be a valid pointer
                               :   *  before the beginning of an array.</em> [24.4.1]/1,2
                               :   *
                               :   *  Reverse iterators can be tricky and surprising at first.  Their
                               :   *  semantics make sense, however, and the trickiness is a side effect of
                               :   *  the requirement that the iterators must be safe.
                               :  */
                               :  template<typename _Iterator>
                               :    class reverse_iterator
                               :    : public iterator<typename iterator_traits<_Iterator>::iterator_category,
                               :		      typename iterator_traits<_Iterator>::value_type,
                               :		      typename iterator_traits<_Iterator>::difference_type,
                               :		      typename iterator_traits<_Iterator>::pointer,
                               :                      typename iterator_traits<_Iterator>::reference>
                               :    {
                               :    protected:
                               :      _Iterator current;
                               :
                               :      typedef iterator_traits<_Iterator>		__traits_type;
                               :
                               :    public:
                               :      typedef _Iterator					iterator_type;
                               :      typedef typename __traits_type::difference_type	difference_type;
                               :      typedef typename __traits_type::pointer		pointer;
                               :      typedef typename __traits_type::reference		reference;
                               :
                               :      /**
                               :       *  The default constructor value-initializes member @p current.
                               :       *  If it is a pointer, that means it is zero-initialized.
                               :      */
                               :      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                               :      // 235 No specification of default ctor for reverse_iterator
                               :      reverse_iterator() : current() { }
                               :
                               :      /**
                               :       *  This %iterator will move in the opposite direction that @p x does.
                               :      */
                               :      explicit
                               :      reverse_iterator(iterator_type __x) : current(__x) { }
                               :
                               :      /**
                               :       *  The copy constructor is normal.
                               :      */
                               :      reverse_iterator(const reverse_iterator& __x)
                               :      : current(__x.current) { }
                               :
                               :      /**
                               :       *  A %reverse_iterator across other types can be copied if the
                               :       *  underlying %iterator can be converted to the type of @c current.
                               :      */
                               :      template<typename _Iter>
                               :        reverse_iterator(const reverse_iterator<_Iter>& __x)
                               :	: current(__x.base()) { }
                               :
                               :      /**
                               :       *  @return  @c current, the %iterator used for underlying work.
                               :      */
                               :      iterator_type
                               :      base() const
                               :      { return current; }
                               :
                               :      /**
                               :       *  @return  A reference to the value at @c --current
                               :       *
                               :       *  This requires that @c --current is dereferenceable.
                               :       *
                               :       *  @warning This implementation requires that for an iterator of the
                               :       *           underlying iterator type, @c x, a reference obtained by
                               :       *           @c *x remains valid after @c x has been modified or
                               :       *           destroyed. This is a bug: http://gcc.gnu.org/PR51823
                               :      */
                               :      reference
                               :      operator*() const
                               :      {
                               :	_Iterator __tmp = current;
                               :	return *--__tmp;
                               :      }
                               :
                               :      /**
                               :       *  @return  A pointer to the value at @c --current
                               :       *
                               :       *  This requires that @c --current is dereferenceable.
                               :      */
                               :      pointer
                               :      operator->() const
                               :      { return &(operator*()); }
                               :
                               :      /**
                               :       *  @return  @c *this
                               :       *
                               :       *  Decrements the underlying iterator.
                               :      */
                               :      reverse_iterator&
                               :      operator++()
                               :      {
                               :	--current;
                               :	return *this;
                               :      }
                               :
                               :      /**
                               :       *  @return  The original value of @c *this
                               :       *
                               :       *  Decrements the underlying iterator.
                               :      */
                               :      reverse_iterator
                               :      operator++(int)
                               :      {
                               :	reverse_iterator __tmp = *this;
                               :	--current;
                               :	return __tmp;
                               :      }
                               :
                               :      /**
                               :       *  @return  @c *this
                               :       *
                               :       *  Increments the underlying iterator.
                               :      */
                               :      reverse_iterator&
                               :      operator--()
                               :      {
                               :	++current;
                               :	return *this;
                               :      }
                               :
                               :      /**
                               :       *  @return  A reverse_iterator with the previous value of @c *this
                               :       *
                               :       *  Increments the underlying iterator.
                               :      */
                               :      reverse_iterator
                               :      operator--(int)
                               :      {
                               :	reverse_iterator __tmp = *this;
                               :	++current;
                               :	return __tmp;
                               :      }
                               :
                               :      /**
                               :       *  @return  A reverse_iterator that refers to @c current - @a __n
                               :       *
                               :       *  The underlying iterator must be a Random Access Iterator.
                               :      */
                               :      reverse_iterator
                               :      operator+(difference_type __n) const
                               :      { return reverse_iterator(current - __n); }
                               :
                               :      /**
                               :       *  @return  *this
                               :       *
                               :       *  Moves the underlying iterator backwards @a __n steps.
                               :       *  The underlying iterator must be a Random Access Iterator.
                               :      */
                               :      reverse_iterator&
                               :      operator+=(difference_type __n)
                               :      {
                               :	current -= __n;
                               :	return *this;
                               :      }
                               :
                               :      /**
                               :       *  @return  A reverse_iterator that refers to @c current - @a __n
                               :       *
                               :       *  The underlying iterator must be a Random Access Iterator.
                               :      */
                               :      reverse_iterator
                               :      operator-(difference_type __n) const
                               :      { return reverse_iterator(current + __n); }
                               :
                               :      /**
                               :       *  @return  *this
                               :       *
                               :       *  Moves the underlying iterator forwards @a __n steps.
                               :       *  The underlying iterator must be a Random Access Iterator.
                               :      */
                               :      reverse_iterator&
                               :      operator-=(difference_type __n)
                               :      {
                               :	current += __n;
                               :	return *this;
                               :      }
                               :
                               :      /**
                               :       *  @return  The value at @c current - @a __n - 1
                               :       *
                               :       *  The underlying iterator must be a Random Access Iterator.
                               :      */
                               :      reference
                               :      operator[](difference_type __n) const
                               :      { return *(*this + __n); }
                               :    };
                               :
                               :  //@{
                               :  /**
                               :   *  @param  __x  A %reverse_iterator.
                               :   *  @param  __y  A %reverse_iterator.
                               :   *  @return  A simple bool.
                               :   *
                               :   *  Reverse iterators forward many operations to their underlying base()
                               :   *  iterators.  Others are implemented in terms of one another.
                               :   *
                               :  */
                               :  template<typename _Iterator>
                               :    inline bool
                               :    operator==(const reverse_iterator<_Iterator>& __x,
                               :	       const reverse_iterator<_Iterator>& __y)
                               :    { return __x.base() == __y.base(); }
                               :
                               :  template<typename _Iterator>
                               :    inline bool
                               :    operator<(const reverse_iterator<_Iterator>& __x,
                               :	      const reverse_iterator<_Iterator>& __y)
                               :    { return __y.base() < __x.base(); }
                               :
                               :  template<typename _Iterator>
                               :    inline bool
                               :    operator!=(const reverse_iterator<_Iterator>& __x,
                               :	       const reverse_iterator<_Iterator>& __y)
                               :    { return !(__x == __y); }
                               :
                               :  template<typename _Iterator>
                               :    inline bool
                               :    operator>(const reverse_iterator<_Iterator>& __x,
                               :	      const reverse_iterator<_Iterator>& __y)
                               :    { return __y < __x; }
                               :
                               :  template<typename _Iterator>
                               :    inline bool
                               :    operator<=(const reverse_iterator<_Iterator>& __x,
                               :	       const reverse_iterator<_Iterator>& __y)
                               :    { return !(__y < __x); }
                               :
                               :  template<typename _Iterator>
                               :    inline bool
                               :    operator>=(const reverse_iterator<_Iterator>& __x,
                               :	       const reverse_iterator<_Iterator>& __y)
                               :    { return !(__x < __y); }
                               :
                               :  template<typename _Iterator>
                               :    inline typename reverse_iterator<_Iterator>::difference_type
                               :    operator-(const reverse_iterator<_Iterator>& __x,
                               :	      const reverse_iterator<_Iterator>& __y)
                               :    { return __y.base() - __x.base(); }
                               :
                               :  template<typename _Iterator>
                               :    inline reverse_iterator<_Iterator>
                               :    operator+(typename reverse_iterator<_Iterator>::difference_type __n,
                               :	      const reverse_iterator<_Iterator>& __x)
                               :    { return reverse_iterator<_Iterator>(__x.base() - __n); }
                               :
                               :  // _GLIBCXX_RESOLVE_LIB_DEFECTS
                               :  // DR 280. Comparison of reverse_iterator to const reverse_iterator.
                               :  template<typename _IteratorL, typename _IteratorR>
                               :    inline bool
                               :    operator==(const reverse_iterator<_IteratorL>& __x,
                               :	       const reverse_iterator<_IteratorR>& __y)
                               :    { return __x.base() == __y.base(); }
                               :
                               :  template<typename _IteratorL, typename _IteratorR>
                               :    inline bool
                               :    operator<(const reverse_iterator<_IteratorL>& __x,
                               :	      const reverse_iterator<_IteratorR>& __y)
                               :    { return __y.base() < __x.base(); }
                               :
                               :  template<typename _IteratorL, typename _IteratorR>
                               :    inline bool
                               :    operator!=(const reverse_iterator<_IteratorL>& __x,
                               :	       const reverse_iterator<_IteratorR>& __y)
                               :    { return !(__x == __y); }
                               :
                               :  template<typename _IteratorL, typename _IteratorR>
                               :    inline bool
                               :    operator>(const reverse_iterator<_IteratorL>& __x,
                               :	      const reverse_iterator<_IteratorR>& __y)
                               :    { return __y < __x; }
                               :
                               :  template<typename _IteratorL, typename _IteratorR>
                               :    inline bool
                               :    operator<=(const reverse_iterator<_IteratorL>& __x,
                               :	       const reverse_iterator<_IteratorR>& __y)
                               :    { return !(__y < __x); }
                               :
                               :  template<typename _IteratorL, typename _IteratorR>
                               :    inline bool
                               :    operator>=(const reverse_iterator<_IteratorL>& __x,
                               :	       const reverse_iterator<_IteratorR>& __y)
                               :    { return !(__x < __y); }
                               :
                               :  template<typename _IteratorL, typename _IteratorR>
                               :#if __cplusplus >= 201103L
                               :    // DR 685.
                               :    inline auto
                               :    operator-(const reverse_iterator<_IteratorL>& __x,
                               :	      const reverse_iterator<_IteratorR>& __y)
                               :    -> decltype(__y.base() - __x.base())
                               :#else
                               :    inline typename reverse_iterator<_IteratorL>::difference_type
                               :    operator-(const reverse_iterator<_IteratorL>& __x,
                               :	      const reverse_iterator<_IteratorR>& __y)
                               :#endif
                               :    { return __y.base() - __x.base(); }
                               :  //@}
                               :
                               :  // 24.4.2.2.1 back_insert_iterator
                               :  /**
                               :   *  @brief  Turns assignment into insertion.
                               :   *
                               :   *  These are output iterators, constructed from a container-of-T.
                               :   *  Assigning a T to the iterator appends it to the container using
                               :   *  push_back.
                               :   *
                               :   *  Tip:  Using the back_inserter function to create these iterators can
                               :   *  save typing.
                               :  */
                               :  template<typename _Container>
                               :    class back_insert_iterator
                               :    : public iterator<output_iterator_tag, void, void, void, void>
                               :    {
                               :    protected:
                               :      _Container* container;
                               :
                               :    public:
                               :      /// A nested typedef for the type of whatever container you used.
                               :      typedef _Container          container_type;
                               :
                               :      /// The only way to create this %iterator is with a container.
                               :      explicit
                               :      back_insert_iterator(_Container& __x) : container(&__x) { }
                               :
                               :      /**
                               :       *  @param  __value  An instance of whatever type
                               :       *                 container_type::const_reference is; presumably a
                               :       *                 reference-to-const T for container<T>.
                               :       *  @return  This %iterator, for chained operations.
                               :       *
                               :       *  This kind of %iterator doesn't really have a @a position in the
                               :       *  container (you can think of the position as being permanently at
                               :       *  the end, if you like).  Assigning a value to the %iterator will
                               :       *  always append the value to the end of the container.
                               :      */
                               :#if __cplusplus < 201103L
                               :      back_insert_iterator&
                               :      operator=(typename _Container::const_reference __value)
                               :      {
                               :	container->push_back(__value);
                               :	return *this;
                               :      }
                               :#else
                               :      back_insert_iterator&
                               :      operator=(const typename _Container::value_type& __value)
                               :      {
                               :	container->push_back(__value);
                               :	return *this;
                               :      }
                               :
                               :      back_insert_iterator&
                               :      operator=(typename _Container::value_type&& __value)
                               :      {
                               :	container->push_back(std::move(__value));
                               :	return *this;
                               :      }
                               :#endif
                               :
                               :      /// Simply returns *this.
                               :      back_insert_iterator&
                               :      operator*()
                               :      { return *this; }
                               :
                               :      /// Simply returns *this.  (This %iterator does not @a move.)
                               :      back_insert_iterator&
                               :      operator++()
                               :      { return *this; }
                               :
                               :      /// Simply returns *this.  (This %iterator does not @a move.)
                               :      back_insert_iterator
                               :      operator++(int)
                               :      { return *this; }
                               :    };
                               :
                               :  /**
                               :   *  @param  __x  A container of arbitrary type.
                               :   *  @return  An instance of back_insert_iterator working on @p __x.
                               :   *
                               :   *  This wrapper function helps in creating back_insert_iterator instances.
                               :   *  Typing the name of the %iterator requires knowing the precise full
                               :   *  type of the container, which can be tedious and impedes generic
                               :   *  programming.  Using this function lets you take advantage of automatic
                               :   *  template parameter deduction, making the compiler match the correct
                               :   *  types for you.
                               :  */
                               :  template<typename _Container>
                               :    inline back_insert_iterator<_Container>
                               :    back_inserter(_Container& __x)
                               :    { return back_insert_iterator<_Container>(__x); }
                               :
                               :  /**
                               :   *  @brief  Turns assignment into insertion.
                               :   *
                               :   *  These are output iterators, constructed from a container-of-T.
                               :   *  Assigning a T to the iterator prepends it to the container using
                               :   *  push_front.
                               :   *
                               :   *  Tip:  Using the front_inserter function to create these iterators can
                               :   *  save typing.
                               :  */
                               :  template<typename _Container>
                               :    class front_insert_iterator
                               :    : public iterator<output_iterator_tag, void, void, void, void>
                               :    {
                               :    protected:
                               :      _Container* container;
                               :
                               :    public:
                               :      /// A nested typedef for the type of whatever container you used.
                               :      typedef _Container          container_type;
                               :
                               :      /// The only way to create this %iterator is with a container.
                               :      explicit front_insert_iterator(_Container& __x) : container(&__x) { }
                               :
                               :      /**
                               :       *  @param  __value  An instance of whatever type
                               :       *                 container_type::const_reference is; presumably a
                               :       *                 reference-to-const T for container<T>.
                               :       *  @return  This %iterator, for chained operations.
                               :       *
                               :       *  This kind of %iterator doesn't really have a @a position in the
                               :       *  container (you can think of the position as being permanently at
                               :       *  the front, if you like).  Assigning a value to the %iterator will
                               :       *  always prepend the value to the front of the container.
                               :      */
                               :#if __cplusplus < 201103L
                               :      front_insert_iterator&
                               :      operator=(typename _Container::const_reference __value)
                               :      {
                               :	container->push_front(__value);
                               :	return *this;
                               :      }
                               :#else
                               :      front_insert_iterator&
                               :      operator=(const typename _Container::value_type& __value)
                               :      {
                               :	container->push_front(__value);
                               :	return *this;
                               :      }
                               :
                               :      front_insert_iterator&
                               :      operator=(typename _Container::value_type&& __value)
                               :      {
                               :	container->push_front(std::move(__value));
                               :	return *this;
                               :      }
                               :#endif
                               :
                               :      /// Simply returns *this.
                               :      front_insert_iterator&
                               :      operator*()
                               :      { return *this; }
                               :
                               :      /// Simply returns *this.  (This %iterator does not @a move.)
                               :      front_insert_iterator&
                               :      operator++()
                               :      { return *this; }
                               :
                               :      /// Simply returns *this.  (This %iterator does not @a move.)
                               :      front_insert_iterator
                               :      operator++(int)
                               :      { return *this; }
                               :    };
                               :
                               :  /**
                               :   *  @param  __x  A container of arbitrary type.
                               :   *  @return  An instance of front_insert_iterator working on @p x.
                               :   *
                               :   *  This wrapper function helps in creating front_insert_iterator instances.
                               :   *  Typing the name of the %iterator requires knowing the precise full
                               :   *  type of the container, which can be tedious and impedes generic
                               :   *  programming.  Using this function lets you take advantage of automatic
                               :   *  template parameter deduction, making the compiler match the correct
                               :   *  types for you.
                               :  */
                               :  template<typename _Container>
                               :    inline front_insert_iterator<_Container>
                               :    front_inserter(_Container& __x)
                               :    { return front_insert_iterator<_Container>(__x); }
                               :
                               :  /**
                               :   *  @brief  Turns assignment into insertion.
                               :   *
                               :   *  These are output iterators, constructed from a container-of-T.
                               :   *  Assigning a T to the iterator inserts it in the container at the
                               :   *  %iterator's position, rather than overwriting the value at that
                               :   *  position.
                               :   *
                               :   *  (Sequences will actually insert a @e copy of the value before the
                               :   *  %iterator's position.)
                               :   *
                               :   *  Tip:  Using the inserter function to create these iterators can
                               :   *  save typing.
                               :  */
                               :  template<typename _Container>
                               :    class insert_iterator
                               :    : public iterator<output_iterator_tag, void, void, void, void>
                               :    {
                               :    protected:
                               :      _Container* container;
                               :      typename _Container::iterator iter;
                               :
                               :    public:
                               :      /// A nested typedef for the type of whatever container you used.
                               :      typedef _Container          container_type;
                               :
                               :      /**
                               :       *  The only way to create this %iterator is with a container and an
                               :       *  initial position (a normal %iterator into the container).
                               :      */
                               :      insert_iterator(_Container& __x, typename _Container::iterator __i)
                               :      : container(&__x), iter(__i) {}
                               :
                               :      /**
                               :       *  @param  __value  An instance of whatever type
                               :       *                 container_type::const_reference is; presumably a
                               :       *                 reference-to-const T for container<T>.
                               :       *  @return  This %iterator, for chained operations.
                               :       *
                               :       *  This kind of %iterator maintains its own position in the
                               :       *  container.  Assigning a value to the %iterator will insert the
                               :       *  value into the container at the place before the %iterator.
                               :       *
                               :       *  The position is maintained such that subsequent assignments will
                               :       *  insert values immediately after one another.  For example,
                               :       *  @code
                               :       *     // vector v contains A and Z
                               :       *
                               :       *     insert_iterator i (v, ++v.begin());
                               :       *     i = 1;
                               :       *     i = 2;
                               :       *     i = 3;
                               :       *
                               :       *     // vector v contains A, 1, 2, 3, and Z
                               :       *  @endcode
                               :      */
                               :#if __cplusplus < 201103L
                               :      insert_iterator&
                               :      operator=(typename _Container::const_reference __value)
                               :      {
                               :	iter = container->insert(iter, __value);
                               :	++iter;
                               :	return *this;
                               :      }
                               :#else
                               :      insert_iterator&
                               :      operator=(const typename _Container::value_type& __value)
                               :      {
                               :	iter = container->insert(iter, __value);
                               :	++iter;
                               :	return *this;
                               :      }
                               :
                               :      insert_iterator&
                               :      operator=(typename _Container::value_type&& __value)
                               :      {
                               :	iter = container->insert(iter, std::move(__value));
                               :	++iter;
                               :	return *this;
                               :      }
                               :#endif
                               :
                               :      /// Simply returns *this.
                               :      insert_iterator&
                               :      operator*()
                               :      { return *this; }
                               :
                               :      /// Simply returns *this.  (This %iterator does not @a move.)
                               :      insert_iterator&
                               :      operator++()
                               :      { return *this; }
                               :
                               :      /// Simply returns *this.  (This %iterator does not @a move.)
                               :      insert_iterator&
                               :      operator++(int)
                               :      { return *this; }
                               :    };
                               :
                               :  /**
                               :   *  @param __x  A container of arbitrary type.
                               :   *  @return  An instance of insert_iterator working on @p __x.
                               :   *
                               :   *  This wrapper function helps in creating insert_iterator instances.
                               :   *  Typing the name of the %iterator requires knowing the precise full
                               :   *  type of the container, which can be tedious and impedes generic
                               :   *  programming.  Using this function lets you take advantage of automatic
                               :   *  template parameter deduction, making the compiler match the correct
                               :   *  types for you.
                               :  */
                               :  template<typename _Container, typename _Iterator>
                               :    inline insert_iterator<_Container>
                               :    inserter(_Container& __x, _Iterator __i)
                               :    {
                               :      return insert_iterator<_Container>(__x,
                               :					 typename _Container::iterator(__i));
                               :    }
                               :
                               :  // @} group iterators
                               :
                               :_GLIBCXX_END_NAMESPACE_VERSION
                               :} // namespace
                               :
                               :namespace __gnu_cxx _GLIBCXX_VISIBILITY(default)
                               :{
                               :_GLIBCXX_BEGIN_NAMESPACE_VERSION
                               :
                               :  // This iterator adapter is @a normal in the sense that it does not
                               :  // change the semantics of any of the operators of its iterator
                               :  // parameter.  Its primary purpose is to convert an iterator that is
                               :  // not a class, e.g. a pointer, into an iterator that is a class.
                               :  // The _Container parameter exists solely so that different containers
                               :  // using this template can instantiate different types, even if the
                               :  // _Iterator parameter is the same.
                               :  using std::iterator_traits;
                               :  using std::iterator;
                               :  template<typename _Iterator, typename _Container>
                               :    class __normal_iterator
                               :    {
                               :    protected:
                               :      _Iterator _M_current;
                               :
                               :      typedef iterator_traits<_Iterator>		__traits_type;
                               :
                               :    public:
                               :      typedef _Iterator					iterator_type;
                               :      typedef typename __traits_type::iterator_category iterator_category;
                               :      typedef typename __traits_type::value_type  	value_type;
                               :      typedef typename __traits_type::difference_type 	difference_type;
                               :      typedef typename __traits_type::reference 	reference;
                               :      typedef typename __traits_type::pointer   	pointer;
                               :
                               :      _GLIBCXX_CONSTEXPR __normal_iterator() : _M_current(_Iterator()) { }
                               :
                               :      explicit
   168  0.1429     0       0   :      __normal_iterator(const _Iterator& __i) : _M_current(__i) { }
                               :
                               :      // Allow iterator to const_iterator conversion
                               :      template<typename _Iter>
                               :        __normal_iterator(const __normal_iterator<_Iter,
                               :			  typename __enable_if<
                               :      	       (std::__are_same<_Iter, typename _Container::pointer>::__value),
                               :		      _Container>::__type>& __i)
                               :        : _M_current(__i.base()) { }
                               :
                               :      // Forward iterator requirements
                               :      reference
                               :      operator*() const
                               :      { return *_M_current; }
                               :
                               :      pointer
                               :      operator->() const
                               :      { return _M_current; }
                               :
                               :      __normal_iterator&
                               :      operator++()
                               :      {
   195  0.1659     0       0   :	++_M_current;
                               :	return *this;
                               :      }
                               :
                               :      __normal_iterator
                               :      operator++(int)
                               :      { return __normal_iterator(_M_current++); }
                               :
                               :      // Bidirectional iterator requirements
                               :      __normal_iterator&
                               :      operator--()
                               :      {
    43  0.0366     1  0.0591   :	--_M_current;
                               :	return *this;
                               :      }
                               :
                               :      __normal_iterator
                               :      operator--(int)
                               :      { return __normal_iterator(_M_current--); }
                               :
                               :      // Random access iterator requirements
                               :      reference
                               :      operator[](const difference_type& __n) const
                               :      { return _M_current[__n]; }
                               :
                               :      __normal_iterator&
                               :      operator+=(const difference_type& __n)
                               :      { _M_current += __n; return *this; }
                               :
                               :      __normal_iterator
                               :      operator+(const difference_type& __n) const
  2636  2.2427     0       0   :      { return __normal_iterator(_M_current + __n); }
                               :
                               :      __normal_iterator&
                               :      operator-=(const difference_type& __n)
                               :      { _M_current -= __n; return *this; }
                               :
                               :      __normal_iterator
                               :      operator-(const difference_type& __n) const
                               :      { return __normal_iterator(_M_current - __n); }
                               :
                               :      const _Iterator&
                               :      base() const
                               :      { return _M_current; }
                               :    };
                               :
                               :  // Note: In what follows, the left- and right-hand-side iterators are
                               :  // allowed to vary in types (conceptually in cv-qualification) so that
                               :  // comparison between cv-qualified and non-cv-qualified iterators be
                               :  // valid.  However, the greedy and unfriendly operators in std::rel_ops
                               :  // will make overload resolution ambiguous (when in scope) if we don't
                               :  // provide overloads whose operands are of the same type.  Can someone
                               :  // remind me what generic programming is about? -- Gaby
                               :
                               :  // Forward iterator requirements
                               :  template<typename _IteratorL, typename _IteratorR, typename _Container>
                               :    inline bool
                               :    operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,
                               :	       const __normal_iterator<_IteratorR, _Container>& __rhs)
                               :    { return __lhs.base() == __rhs.base(); }
                               :
                               :  template<typename _Iterator, typename _Container>
                               :    inline bool
                               :    operator==(const __normal_iterator<_Iterator, _Container>& __lhs,
                               :	       const __normal_iterator<_Iterator, _Container>& __rhs)
                               :    { return __lhs.base() == __rhs.base(); }
                               :
                               :  template<typename _IteratorL, typename _IteratorR, typename _Container>
                               :    inline bool
                               :    operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,
                               :	       const __normal_iterator<_IteratorR, _Container>& __rhs)
                               :    { return __lhs.base() != __rhs.base(); }
                               :
                               :  template<typename _Iterator, typename _Container>
                               :    inline bool
                               :    operator!=(const __normal_iterator<_Iterator, _Container>& __lhs,
                               :	       const __normal_iterator<_Iterator, _Container>& __rhs)
                               :    { return __lhs.base() != __rhs.base(); }
                               :
                               :  // Random access iterator requirements
                               :  template<typename _IteratorL, typename _IteratorR, typename _Container>
                               :    inline bool
                               :    operator<(const __normal_iterator<_IteratorL, _Container>& __lhs,
                               :	      const __normal_iterator<_IteratorR, _Container>& __rhs)
                               :    { return __lhs.base() < __rhs.base(); }
                               :
                               :  template<typename _Iterator, typename _Container>
                               :    inline bool
                               :    operator<(const __normal_iterator<_Iterator, _Container>& __lhs,
                               :	      const __normal_iterator<_Iterator, _Container>& __rhs)
                               :    { return __lhs.base() < __rhs.base(); }
                               :
                               :  template<typename _IteratorL, typename _IteratorR, typename _Container>
                               :    inline bool
                               :    operator>(const __normal_iterator<_IteratorL, _Container>& __lhs,
                               :	      const __normal_iterator<_IteratorR, _Container>& __rhs)
                               :    { return __lhs.base() > __rhs.base(); }
                               :
                               :  template<typename _Iterator, typename _Container>
                               :    inline bool
                               :    operator>(const __normal_iterator<_Iterator, _Container>& __lhs,
                               :	      const __normal_iterator<_Iterator, _Container>& __rhs)
                               :    { return __lhs.base() > __rhs.base(); }
                               :
                               :  template<typename _IteratorL, typename _IteratorR, typename _Container>
                               :    inline bool
                               :    operator<=(const __normal_iterator<_IteratorL, _Container>& __lhs,
                               :	       const __normal_iterator<_IteratorR, _Container>& __rhs)
                               :    { return __lhs.base() <= __rhs.base(); }
                               :
                               :  template<typename _Iterator, typename _Container>
                               :    inline bool
                               :    operator<=(const __normal_iterator<_Iterator, _Container>& __lhs,
                               :	       const __normal_iterator<_Iterator, _Container>& __rhs)
                               :    { return __lhs.base() <= __rhs.base(); }
                               :
                               :  template<typename _IteratorL, typename _IteratorR, typename _Container>
                               :    inline bool
                               :    operator>=(const __normal_iterator<_IteratorL, _Container>& __lhs,
                               :	       const __normal_iterator<_IteratorR, _Container>& __rhs)
                               :    { return __lhs.base() >= __rhs.base(); }
                               :
                               :  template<typename _Iterator, typename _Container>
                               :    inline bool
                               :    operator>=(const __normal_iterator<_Iterator, _Container>& __lhs,
                               :	       const __normal_iterator<_Iterator, _Container>& __rhs)
                               :    { return __lhs.base() >= __rhs.base(); }
                               :
                               :  // _GLIBCXX_RESOLVE_LIB_DEFECTS
                               :  // According to the resolution of DR179 not only the various comparison
                               :  // operators but also operator- must accept mixed iterator/const_iterator
                               :  // parameters.
                               :  template<typename _IteratorL, typename _IteratorR, typename _Container>
                               :#if __cplusplus >= 201103L
                               :    // DR 685.
                               :    inline auto
                               :    operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,
                               :	      const __normal_iterator<_IteratorR, _Container>& __rhs)
                               :    -> decltype(__lhs.base() - __rhs.base())
                               :#else
                               :    inline typename __normal_iterator<_IteratorL, _Container>::difference_type
                               :    operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,
                               :	      const __normal_iterator<_IteratorR, _Container>& __rhs)
                               :#endif
                               :    { return __lhs.base() - __rhs.base(); }
                               :
                               :  template<typename _Iterator, typename _Container>
                               :    inline typename __normal_iterator<_Iterator, _Container>::difference_type
                               :    operator-(const __normal_iterator<_Iterator, _Container>& __lhs,
                               :	      const __normal_iterator<_Iterator, _Container>& __rhs)
   130  0.1106     0       0   :    { return __lhs.base() - __rhs.base(); }
                               :
                               :  template<typename _Iterator, typename _Container>
                               :    inline __normal_iterator<_Iterator, _Container>
                               :    operator+(typename __normal_iterator<_Iterator, _Container>::difference_type
                               :	      __n, const __normal_iterator<_Iterator, _Container>& __i)
                               :    { return __normal_iterator<_Iterator, _Container>(__i.base() + __n); }
                               :
                               :_GLIBCXX_END_NAMESPACE_VERSION
                               :} // namespace
                               :
                               :#if __cplusplus >= 201103L
                               :
                               :namespace std _GLIBCXX_VISIBILITY(default)
                               :{
                               :_GLIBCXX_BEGIN_NAMESPACE_VERSION
                               :
                               :  /**
                               :   * @addtogroup iterators
                               :   * @{
                               :   */
                               :
                               :  // 24.4.3  Move iterators
                               :  /**
                               :   *  Class template move_iterator is an iterator adapter with the same
                               :   *  behavior as the underlying iterator except that its dereference
                               :   *  operator implicitly converts the value returned by the underlying
                               :   *  iterator's dereference operator to an rvalue reference.  Some
                               :   *  generic algorithms can be called with move iterators to replace
                               :   *  copying with moving.
                               :   */
                               :  template<typename _Iterator>
                               :    class move_iterator
                               :    {
                               :    protected:
                               :      _Iterator _M_current;
                               :
                               :      typedef iterator_traits<_Iterator>		__traits_type;
                               :
                               :    public:
                               :      typedef _Iterator					iterator_type;
                               :      typedef typename __traits_type::iterator_category iterator_category;
                               :      typedef typename __traits_type::value_type  	value_type;
                               :      typedef typename __traits_type::difference_type	difference_type;
                               :      // NB: DR 680.
                               :      typedef _Iterator					pointer;
                               :      typedef value_type&&				reference;
                               :
                               :      move_iterator()
                               :      : _M_current() { }
                               :
                               :      explicit
                               :      move_iterator(iterator_type __i)
                               :      : _M_current(__i) { }
                               :
                               :      template<typename _Iter>
                               :	move_iterator(const move_iterator<_Iter>& __i)
                               :	: _M_current(__i.base()) { }
                               :
                               :      iterator_type
                               :      base() const
                               :      { return _M_current; }
                               :
                               :      reference
                               :      operator*() const
                               :      { return std::move(*_M_current); }
                               :
                               :      pointer
                               :      operator->() const
                               :      { return _M_current; }
                               :
                               :      move_iterator&
                               :      operator++()
                               :      {
    47  0.0400     0       0   :	++_M_current;
                               :	return *this;
                               :      }
                               :
                               :      move_iterator
                               :      operator++(int)
                               :      {
                               :	move_iterator __tmp = *this;
                               :	++_M_current;
                               :	return __tmp;
                               :      }
                               :
                               :      move_iterator&
                               :      operator--()
                               :      {
                               :	--_M_current;
                               :	return *this;
                               :      }
                               :
                               :      move_iterator
                               :      operator--(int)
                               :      {
                               :	move_iterator __tmp = *this;
                               :	--_M_current;
                               :	return __tmp;
                               :      }
                               :
                               :      move_iterator
                               :      operator+(difference_type __n) const
                               :      { return move_iterator(_M_current + __n); }
                               :
                               :      move_iterator&
                               :      operator+=(difference_type __n)
                               :      {
                               :	_M_current += __n;
                               :	return *this;
                               :      }
                               :
                               :      move_iterator
                               :      operator-(difference_type __n) const
                               :      { return move_iterator(_M_current - __n); }
                               :    
                               :      move_iterator&
                               :      operator-=(difference_type __n)
                               :      { 
                               :	_M_current -= __n;
                               :	return *this;
                               :      }
                               :
                               :      reference
                               :      operator[](difference_type __n) const
                               :      { return std::move(_M_current[__n]); }
                               :    };
                               :
                               :  // Note: See __normal_iterator operators note from Gaby to understand
                               :  // why there are always 2 versions for most of the move_iterator
                               :  // operators.
                               :  template<typename _IteratorL, typename _IteratorR>
                               :    inline bool
                               :    operator==(const move_iterator<_IteratorL>& __x,
                               :	       const move_iterator<_IteratorR>& __y)
                               :    { return __x.base() == __y.base(); }
                               :
                               :  template<typename _Iterator>
                               :    inline bool
                               :    operator==(const move_iterator<_Iterator>& __x,
                               :	       const move_iterator<_Iterator>& __y)
                               :    { return __x.base() == __y.base(); }
                               :
                               :  template<typename _IteratorL, typename _IteratorR>
                               :    inline bool
                               :    operator!=(const move_iterator<_IteratorL>& __x,
                               :	       const move_iterator<_IteratorR>& __y)
                               :    { return !(__x == __y); }
                               :
                               :  template<typename _Iterator>
                               :    inline bool
                               :    operator!=(const move_iterator<_Iterator>& __x,
                               :	       const move_iterator<_Iterator>& __y)
                               :    { return !(__x == __y); }
                               :
                               :  template<typename _IteratorL, typename _IteratorR>
                               :    inline bool
                               :    operator<(const move_iterator<_IteratorL>& __x,
                               :	      const move_iterator<_IteratorR>& __y)
                               :    { return __x.base() < __y.base(); }
                               :
                               :  template<typename _Iterator>
                               :    inline bool
                               :    operator<(const move_iterator<_Iterator>& __x,
                               :	      const move_iterator<_Iterator>& __y)
                               :    { return __x.base() < __y.base(); }
                               :
                               :  template<typename _IteratorL, typename _IteratorR>
                               :    inline bool
                               :    operator<=(const move_iterator<_IteratorL>& __x,
                               :	       const move_iterator<_IteratorR>& __y)
                               :    { return !(__y < __x); }
                               :
                               :  template<typename _Iterator>
                               :    inline bool
                               :    operator<=(const move_iterator<_Iterator>& __x,
                               :	       const move_iterator<_Iterator>& __y)
                               :    { return !(__y < __x); }
                               :
                               :  template<typename _IteratorL, typename _IteratorR>
                               :    inline bool
                               :    operator>(const move_iterator<_IteratorL>& __x,
                               :	      const move_iterator<_IteratorR>& __y)
                               :    { return __y < __x; }
                               :
                               :  template<typename _Iterator>
                               :    inline bool
                               :    operator>(const move_iterator<_Iterator>& __x,
                               :	      const move_iterator<_Iterator>& __y)
                               :    { return __y < __x; }
                               :
                               :  template<typename _IteratorL, typename _IteratorR>
                               :    inline bool
                               :    operator>=(const move_iterator<_IteratorL>& __x,
                               :	       const move_iterator<_IteratorR>& __y)
                               :    { return !(__x < __y); }
                               :
                               :  template<typename _Iterator>
                               :    inline bool
                               :    operator>=(const move_iterator<_Iterator>& __x,
                               :	       const move_iterator<_Iterator>& __y)
                               :    { return !(__x < __y); }
                               :
                               :  // DR 685.
                               :  template<typename _IteratorL, typename _IteratorR>
                               :    inline auto
                               :    operator-(const move_iterator<_IteratorL>& __x,
                               :	      const move_iterator<_IteratorR>& __y)
                               :    -> decltype(__x.base() - __y.base())
                               :    { return __x.base() - __y.base(); }
                               :
                               :  template<typename _Iterator>
                               :    inline auto
                               :    operator-(const move_iterator<_Iterator>& __x,
                               :	      const move_iterator<_Iterator>& __y)
                               :    -> decltype(__x.base() - __y.base())
                               :    { return __x.base() - __y.base(); }
                               :
                               :  template<typename _Iterator>
                               :    inline move_iterator<_Iterator>
                               :    operator+(typename move_iterator<_Iterator>::difference_type __n,
                               :	      const move_iterator<_Iterator>& __x)
                               :    { return __x + __n; }
                               :
                               :  template<typename _Iterator>
                               :    inline move_iterator<_Iterator>
                               :    make_move_iterator(_Iterator __i)
                               :    { return move_iterator<_Iterator>(__i); }
                               :
                               :  template<typename _Iterator, typename _ReturnType
                               :    = typename conditional<__move_if_noexcept_cond
                               :      <typename iterator_traits<_Iterator>::value_type>::value,
                               :                _Iterator, move_iterator<_Iterator>>::type>
                               :    inline _ReturnType
                               :    __make_move_if_noexcept_iterator(_Iterator __i)
                               :    { return _ReturnType(__i); }
                               :
                               :  // @} group iterators
                               :
                               :_GLIBCXX_END_NAMESPACE_VERSION
                               :} // namespace
                               :
                               :#define _GLIBCXX_MAKE_MOVE_ITERATOR(_Iter) std::make_move_iterator(_Iter)
                               :#define _GLIBCXX_MAKE_MOVE_IF_NOEXCEPT_ITERATOR(_Iter) \
                               :  std::__make_move_if_noexcept_iterator(_Iter)
                               :#else
                               :#define _GLIBCXX_MAKE_MOVE_ITERATOR(_Iter) (_Iter)
                               :#define _GLIBCXX_MAKE_MOVE_IF_NOEXCEPT_ITERATOR(_Iter) (_Iter)
                               :#endif // C++11
                               :
                               :#endif
/* 
 * Total samples for file : "/usr/include/c++/4.8/bits/stl_heap.h"
 * 
 *   3051  2.5958     3  0.1772
 */


                               :// Heap implementation -*- C++ -*-
                               :
                               :// Copyright (C) 2001-2013 Free Software Foundation, Inc.
                               ://
                               :// This file is part of the GNU ISO C++ Library.  This library is free
                               :// software; you can redistribute it and/or modify it under the
                               :// terms of the GNU General Public License as published by the
                               :// Free Software Foundation; either version 3, or (at your option)
                               :// any later version.
                               :
                               :// This library is distributed in the hope that it will be useful,
                               :// but WITHOUT ANY WARRANTY; without even the implied warranty of
                               :// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                               :// GNU General Public License for more details.
                               :
                               :// Under Section 7 of GPL version 3, you are granted additional
                               :// permissions described in the GCC Runtime Library Exception, version
                               :// 3.1, as published by the Free Software Foundation.
                               :
                               :// You should have received a copy of the GNU General Public License and
                               :// a copy of the GCC Runtime Library Exception along with this program;
                               :// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                               :// <http://www.gnu.org/licenses/>.
                               :
                               :/*
                               : *
                               : * Copyright (c) 1994
                               : * Hewlett-Packard Company
                               : *
                               : * Permission to use, copy, modify, distribute and sell this software
                               : * and its documentation for any purpose is hereby granted without fee,
                               : * provided that the above copyright notice appear in all copies and
                               : * that both that copyright notice and this permission notice appear
                               : * in supporting documentation.  Hewlett-Packard Company makes no
                               : * representations about the suitability of this software for any
                               : * purpose.  It is provided "as is" without express or implied warranty.
                               : *
                               : * Copyright (c) 1997
                               : * Silicon Graphics Computer Systems, Inc.
                               : *
                               : * Permission to use, copy, modify, distribute and sell this software
                               : * and its documentation for any purpose is hereby granted without fee,
                               : * provided that the above copyright notice appear in all copies and
                               : * that both that copyright notice and this permission notice appear
                               : * in supporting documentation.  Silicon Graphics makes no
                               : * representations about the suitability of this software for any
                               : * purpose.  It is provided "as is" without express or implied warranty.
                               : */
                               :
                               :/** @file bits/stl_heap.h
                               : *  This is an internal header file, included by other library headers.
                               : *  Do not attempt to use it directly. @headername{queue}
                               : */
                               :
                               :#ifndef _STL_HEAP_H
                               :#define _STL_HEAP_H 1
                               :
                               :#include <debug/debug.h>
                               :#include <bits/move.h>
                               :
                               :namespace std _GLIBCXX_VISIBILITY(default)
                               :{
                               :_GLIBCXX_BEGIN_NAMESPACE_VERSION
                               :
                               :  /**
                               :   * @defgroup heap_algorithms Heap
                               :   * @ingroup sorting_algorithms
                               :   */
                               :
                               :  template<typename _RandomAccessIterator, typename _Distance>
                               :    _Distance
                               :    __is_heap_until(_RandomAccessIterator __first, _Distance __n)
                               :    {
                               :      _Distance __parent = 0;
                               :      for (_Distance __child = 1; __child < __n; ++__child)
                               :	{
                               :	  if (__first[__parent] < __first[__child])
                               :	    return __child;
                               :	  if ((__child & 1) == 0)
                               :	    ++__parent;
                               :	}
                               :      return __n;
                               :    }
                               :
                               :  template<typename _RandomAccessIterator, typename _Distance,
                               :	   typename _Compare>
                               :    _Distance
                               :    __is_heap_until(_RandomAccessIterator __first, _Distance __n,
                               :		    _Compare __comp)
                               :    {
                               :      _Distance __parent = 0;
                               :      for (_Distance __child = 1; __child < __n; ++__child)
                               :	{
                               :	  if (__comp(__first[__parent], __first[__child]))
                               :	    return __child;
                               :	  if ((__child & 1) == 0)
                               :	    ++__parent;
                               :	}
                               :      return __n;
                               :    }
                               :
                               :  // __is_heap, a predicate testing whether or not a range is a heap.
                               :  // This function is an extension, not part of the C++ standard.
                               :  template<typename _RandomAccessIterator, typename _Distance>
                               :    inline bool
                               :    __is_heap(_RandomAccessIterator __first, _Distance __n)
                               :    { return std::__is_heap_until(__first, __n) == __n; }
                               :
                               :  template<typename _RandomAccessIterator, typename _Compare,
                               :	   typename _Distance>
                               :    inline bool
                               :    __is_heap(_RandomAccessIterator __first, _Compare __comp, _Distance __n)
                               :    { return std::__is_heap_until(__first, __n, __comp) == __n; }
                               :
                               :  template<typename _RandomAccessIterator>
                               :    inline bool
                               :    __is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
                               :    { return std::__is_heap(__first, std::distance(__first, __last)); }
                               :
                               :  template<typename _RandomAccessIterator, typename _Compare>
                               :    inline bool
                               :    __is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
                               :	      _Compare __comp)
                               :    { return std::__is_heap(__first, __comp, std::distance(__first, __last)); }
                               :
                               :  // Heap-manipulation functions: push_heap, pop_heap, make_heap, sort_heap,
                               :  // + is_heap and is_heap_until in C++0x.
                               :
                               :  template<typename _RandomAccessIterator, typename _Distance, typename _Tp>
                               :    void
                               :    __push_heap(_RandomAccessIterator __first,
                               :		_Distance __holeIndex, _Distance __topIndex, _Tp __value)
                               :    {
                               :      _Distance __parent = (__holeIndex - 1) / 2;
                               :      while (__holeIndex > __topIndex && *(__first + __parent) < __value)
                               :	{
                               :	  *(__first + __holeIndex) = _GLIBCXX_MOVE(*(__first + __parent));
                               :	  __holeIndex = __parent;
                               :	  __parent = (__holeIndex - 1) / 2;
                               :	}
                               :      *(__first + __holeIndex) = _GLIBCXX_MOVE(__value);
                               :    }
                               :
                               :  /**
                               :   *  @brief  Push an element onto a heap.
                               :   *  @param  __first  Start of heap.
                               :   *  @param  __last   End of heap + element.
                               :   *  @ingroup heap_algorithms
                               :   *
                               :   *  This operation pushes the element at last-1 onto the valid heap
                               :   *  over the range [__first,__last-1).  After completion,
                               :   *  [__first,__last) is a valid heap.
                               :  */
                               :  template<typename _RandomAccessIterator>
                               :    inline void
                               :    push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
                               :    {
                               :      typedef typename iterator_traits<_RandomAccessIterator>::value_type
                               :	  _ValueType;
                               :      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
                               :	  _DistanceType;
                               :
                               :      // concept requirements
                               :      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
                               :	    _RandomAccessIterator>)
                               :      __glibcxx_function_requires(_LessThanComparableConcept<_ValueType>)
                               :      __glibcxx_requires_valid_range(__first, __last);
                               :      __glibcxx_requires_heap(__first, __last - 1);
                               :
                               :      _ValueType __value = _GLIBCXX_MOVE(*(__last - 1));
                               :      std::__push_heap(__first, _DistanceType((__last - __first) - 1),
                               :		       _DistanceType(0), _GLIBCXX_MOVE(__value));
                               :    }
                               :
                               :  template<typename _RandomAccessIterator, typename _Distance, typename _Tp,
                               :	   typename _Compare>
                               :    void
                               :    __push_heap(_RandomAccessIterator __first, _Distance __holeIndex,
                               :		_Distance __topIndex, _Tp __value, _Compare __comp)
                               :    {
   125  0.1063     0       0   :      _Distance __parent = (__holeIndex - 1) / 2;
   667  0.5675     2  0.1181   :      while (__holeIndex > __topIndex
                               :	     && __comp(*(__first + __parent), __value))
                               :	{
                               :	  *(__first + __holeIndex) = _GLIBCXX_MOVE(*(__first + __parent));
                               :	  __holeIndex = __parent;
   458  0.3897     1  0.0591   :	  __parent = (__holeIndex - 1) / 2;
                               :	}
                               :      *(__first + __holeIndex) = _GLIBCXX_MOVE(__value);
                               :    }
                               :
                               :  /**
                               :   *  @brief  Push an element onto a heap using comparison functor.
                               :   *  @param  __first  Start of heap.
                               :   *  @param  __last   End of heap + element.
                               :   *  @param  __comp   Comparison functor.
                               :   *  @ingroup heap_algorithms
                               :   *
                               :   *  This operation pushes the element at __last-1 onto the valid
                               :   *  heap over the range [__first,__last-1).  After completion,
                               :   *  [__first,__last) is a valid heap.  Compare operations are
                               :   *  performed using comp.
                               :  */
                               :  template<typename _RandomAccessIterator, typename _Compare>
                               :    inline void
                               :    push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
                               :	      _Compare __comp)
                               :    {
                               :      typedef typename iterator_traits<_RandomAccessIterator>::value_type
                               :	  _ValueType;
                               :      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
                               :	  _DistanceType;
                               :
                               :      // concept requirements
                               :      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
                               :	    _RandomAccessIterator>)
                               :      __glibcxx_requires_valid_range(__first, __last);
                               :      __glibcxx_requires_heap_pred(__first, __last - 1, __comp);
                               :
    48  0.0408     0       0   :      _ValueType __value = _GLIBCXX_MOVE(*(__last - 1));
                               :      std::__push_heap(__first, _DistanceType((__last - __first) - 1),
    23  0.0196     0       0   :		       _DistanceType(0), _GLIBCXX_MOVE(__value), __comp);
                               :    }
                               :
                               :  template<typename _RandomAccessIterator, typename _Distance, typename _Tp>
                               :    void
                               :    __adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex,
                               :		  _Distance __len, _Tp __value)
                               :    {
                               :      const _Distance __topIndex = __holeIndex;
                               :      _Distance __secondChild = __holeIndex;
                               :      while (__secondChild < (__len - 1) / 2)
                               :	{
                               :	  __secondChild = 2 * (__secondChild + 1);
                               :	  if (*(__first + __secondChild) < *(__first + (__secondChild - 1)))
                               :	    __secondChild--;
                               :	  *(__first + __holeIndex) = _GLIBCXX_MOVE(*(__first + __secondChild));
                               :	  __holeIndex = __secondChild;
                               :	}
                               :      if ((__len & 1) == 0 && __secondChild == (__len - 2) / 2)
                               :	{
                               :	  __secondChild = 2 * (__secondChild + 1);
                               :	  *(__first + __holeIndex) = _GLIBCXX_MOVE(*(__first
                               :						     + (__secondChild - 1)));
                               :	  __holeIndex = __secondChild - 1;
                               :	}
                               :      std::__push_heap(__first, __holeIndex, __topIndex,
                               :		       _GLIBCXX_MOVE(__value));
                               :    }
                               :
                               :  template<typename _RandomAccessIterator>
                               :    inline void
                               :    __pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
                               :	       _RandomAccessIterator __result)
                               :    {
                               :      typedef typename iterator_traits<_RandomAccessIterator>::value_type
                               :	_ValueType;
                               :      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
                               :	_DistanceType;
                               :
                               :      _ValueType __value = _GLIBCXX_MOVE(*__result);
                               :      *__result = _GLIBCXX_MOVE(*__first);
                               :      std::__adjust_heap(__first, _DistanceType(0),
                               :			 _DistanceType(__last - __first),
                               :			 _GLIBCXX_MOVE(__value));
                               :    }
                               :
                               :  /**
                               :   *  @brief  Pop an element off a heap.
                               :   *  @param  __first  Start of heap.
                               :   *  @param  __last   End of heap.
                               :   *  @pre    [__first, __last) is a valid, non-empty range.
                               :   *  @ingroup heap_algorithms
                               :   *
                               :   *  This operation pops the top of the heap.  The elements __first
                               :   *  and __last-1 are swapped and [__first,__last-1) is made into a
                               :   *  heap.
                               :  */
                               :  template<typename _RandomAccessIterator>
                               :    inline void
                               :    pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
                               :    {
                               :      typedef typename iterator_traits<_RandomAccessIterator>::value_type
                               :	_ValueType;
                               :
                               :      // concept requirements
                               :      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
                               :	    _RandomAccessIterator>)
                               :      __glibcxx_function_requires(_LessThanComparableConcept<_ValueType>)
                               :      __glibcxx_requires_non_empty_range(__first, __last);
                               :      __glibcxx_requires_valid_range(__first, __last);
                               :      __glibcxx_requires_heap(__first, __last);
                               :
                               :      if (__last - __first > 1)
                               :	{
                               :	  --__last;
                               :	  std::__pop_heap(__first, __last, __last);
                               :	}
                               :    }
                               :
                               :  template<typename _RandomAccessIterator, typename _Distance,
                               :	   typename _Tp, typename _Compare>
                               :    void
   184  0.1565     0       0   :    __adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex, /* void std::__adjust_heap<__gnu_cxx::__normal_iterator<std::pair<int, int>*, std::vector<std::pair<int, int>, std::allocator<std::pair<int, int> > > >, int, std::pair<int, int>, pair_cmp>(__gnu_cxx::__normal_iterator<std::pair<int, int>*, std::vector<std::pair<int, int>, std::allocator<std::pair<int, int> > > >, int, int, std::pair<int, int>, pair_cmp) total:   6173  5.2519     0       0 */
                               :		  _Distance __len, _Tp __value, _Compare __comp)
                               :    {
                               :      const _Distance __topIndex = __holeIndex;
                               :      _Distance __secondChild = __holeIndex;
   782  0.6653     0       0   :      while (__secondChild < (__len - 1) / 2)
                               :	{
    58  0.0493     0       0   :	  __secondChild = 2 * (__secondChild + 1);
                               :	  if (__comp(*(__first + __secondChild),
    12  0.0102     0       0   :		     *(__first + (__secondChild - 1))))
                               :	    __secondChild--;
                               :	  *(__first + __holeIndex) = _GLIBCXX_MOVE(*(__first + __secondChild));
                               :	  __holeIndex = __secondChild;
                               :	}
   342  0.2910     0       0   :      if ((__len & 1) == 0 && __secondChild == (__len - 2) / 2)
                               :	{
                               :	  __secondChild = 2 * (__secondChild + 1);
                               :	  *(__first + __holeIndex) = _GLIBCXX_MOVE(*(__first
                               :						     + (__secondChild - 1)));
                               :	  __holeIndex = __secondChild - 1;
                               :	}
                               :      std::__push_heap(__first, __holeIndex, __topIndex, 
                               :		       _GLIBCXX_MOVE(__value), __comp);      
    91  0.0774     0       0   :    }
                               :
                               :  template<typename _RandomAccessIterator, typename _Compare>
                               :    inline void
                               :    __pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
                               :	       _RandomAccessIterator __result, _Compare __comp)
                               :    {
                               :      typedef typename iterator_traits<_RandomAccessIterator>::value_type
                               :	_ValueType;
                               :      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
                               :	_DistanceType;
                               :
     7  0.0060     0       0   :      _ValueType __value = _GLIBCXX_MOVE(*__result);
                               :      *__result = _GLIBCXX_MOVE(*__first);
   196  0.1668     0       0   :      std::__adjust_heap(__first, _DistanceType(0),
                               :			 _DistanceType(__last - __first),
                               :			 _GLIBCXX_MOVE(__value), __comp);
                               :    }
                               :
                               :  /**
                               :   *  @brief  Pop an element off a heap using comparison functor.
                               :   *  @param  __first  Start of heap.
                               :   *  @param  __last   End of heap.
                               :   *  @param  __comp   Comparison functor to use.
                               :   *  @ingroup heap_algorithms
                               :   *
                               :   *  This operation pops the top of the heap.  The elements __first
                               :   *  and __last-1 are swapped and [__first,__last-1) is made into a
                               :   *  heap.  Comparisons are made using comp.
                               :  */
                               :  template<typename _RandomAccessIterator, typename _Compare>
                               :    inline void
                               :    pop_heap(_RandomAccessIterator __first,
                               :	     _RandomAccessIterator __last, _Compare __comp)
                               :    {
                               :      // concept requirements
                               :      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
                               :	    _RandomAccessIterator>)
                               :      __glibcxx_requires_valid_range(__first, __last);
                               :      __glibcxx_requires_non_empty_range(__first, __last);
                               :      __glibcxx_requires_heap_pred(__first, __last, __comp);
                               :
    58  0.0493     0       0   :      if (__last - __first > 1)
                               :	{
                               :	  --__last;
                               :	  std::__pop_heap(__first, __last, __last, __comp);
                               :	}
                               :    }
                               :
                               :  /**
                               :   *  @brief  Construct a heap over a range.
                               :   *  @param  __first  Start of heap.
                               :   *  @param  __last   End of heap.
                               :   *  @ingroup heap_algorithms
                               :   *
                               :   *  This operation makes the elements in [__first,__last) into a heap.
                               :  */
                               :  template<typename _RandomAccessIterator>
                               :    void
                               :    make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
                               :    {
                               :      typedef typename iterator_traits<_RandomAccessIterator>::value_type
                               :	  _ValueType;
                               :      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
                               :	  _DistanceType;
                               :
                               :      // concept requirements
                               :      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
                               :	    _RandomAccessIterator>)
                               :      __glibcxx_function_requires(_LessThanComparableConcept<_ValueType>)
                               :      __glibcxx_requires_valid_range(__first, __last);
                               :
                               :      if (__last - __first < 2)
                               :	return;
                               :
                               :      const _DistanceType __len = __last - __first;
                               :      _DistanceType __parent = (__len - 2) / 2;
                               :      while (true)
                               :	{
                               :	  _ValueType __value = _GLIBCXX_MOVE(*(__first + __parent));
                               :	  std::__adjust_heap(__first, __parent, __len, _GLIBCXX_MOVE(__value));
                               :	  if (__parent == 0)
                               :	    return;
                               :	  __parent--;
                               :	}
                               :    }
                               :
                               :  /**
                               :   *  @brief  Construct a heap over a range using comparison functor.
                               :   *  @param  __first  Start of heap.
                               :   *  @param  __last   End of heap.
                               :   *  @param  __comp   Comparison functor to use.
                               :   *  @ingroup heap_algorithms
                               :   *
                               :   *  This operation makes the elements in [__first,__last) into a heap.
                               :   *  Comparisons are made using __comp.
                               :  */
                               :  template<typename _RandomAccessIterator, typename _Compare>
                               :    void
                               :    make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
                               :	      _Compare __comp)
                               :    {
                               :      typedef typename iterator_traits<_RandomAccessIterator>::value_type
                               :	  _ValueType;
                               :      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
                               :	  _DistanceType;
                               :
                               :      // concept requirements
                               :      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
                               :	    _RandomAccessIterator>)
                               :      __glibcxx_requires_valid_range(__first, __last);
                               :
                               :      if (__last - __first < 2)
                               :	return;
                               :
                               :      const _DistanceType __len = __last - __first;
                               :      _DistanceType __parent = (__len - 2) / 2;
                               :      while (true)
                               :	{
                               :	  _ValueType __value = _GLIBCXX_MOVE(*(__first + __parent));
                               :	  std::__adjust_heap(__first, __parent, __len, _GLIBCXX_MOVE(__value),
                               :			     __comp);
                               :	  if (__parent == 0)
                               :	    return;
                               :	  __parent--;
                               :	}
                               :    }
                               :
                               :  /**
                               :   *  @brief  Sort a heap.
                               :   *  @param  __first  Start of heap.
                               :   *  @param  __last   End of heap.
                               :   *  @ingroup heap_algorithms
                               :   *
                               :   *  This operation sorts the valid heap in the range [__first,__last).
                               :  */
                               :  template<typename _RandomAccessIterator>
                               :    void
                               :    sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
                               :    {
                               :      // concept requirements
                               :      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
                               :	    _RandomAccessIterator>)
                               :      __glibcxx_function_requires(_LessThanComparableConcept<
                               :	    typename iterator_traits<_RandomAccessIterator>::value_type>)
                               :      __glibcxx_requires_valid_range(__first, __last);
                               :      __glibcxx_requires_heap(__first, __last);
                               :
                               :      while (__last - __first > 1)
                               :	{
                               :	  --__last;
                               :	  std::__pop_heap(__first, __last, __last);
                               :	}
                               :    }
                               :
                               :  /**
                               :   *  @brief  Sort a heap using comparison functor.
                               :   *  @param  __first  Start of heap.
                               :   *  @param  __last   End of heap.
                               :   *  @param  __comp   Comparison functor to use.
                               :   *  @ingroup heap_algorithms
                               :   *
                               :   *  This operation sorts the valid heap in the range [__first,__last).
                               :   *  Comparisons are made using __comp.
                               :  */
                               :  template<typename _RandomAccessIterator, typename _Compare>
                               :    void
                               :    sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
                               :	      _Compare __comp)
                               :    {
                               :      // concept requirements
                               :      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
                               :	    _RandomAccessIterator>)
                               :      __glibcxx_requires_valid_range(__first, __last);
                               :      __glibcxx_requires_heap_pred(__first, __last, __comp);
                               :
                               :      while (__last - __first > 1)
                               :	{
                               :	  --__last;
                               :	  std::__pop_heap(__first, __last, __last, __comp);
                               :	}
                               :    }
                               :
                               :#if __cplusplus >= 201103L
                               :  /**
                               :   *  @brief  Search the end of a heap.
                               :   *  @param  __first  Start of range.
                               :   *  @param  __last   End of range.
                               :   *  @return  An iterator pointing to the first element not in the heap.
                               :   *  @ingroup heap_algorithms
                               :   *
                               :   *  This operation returns the last iterator i in [__first, __last) for which
                               :   *  the range [__first, i) is a heap.
                               :  */
                               :  template<typename _RandomAccessIterator>
                               :    inline _RandomAccessIterator
                               :    is_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last)
                               :    {
                               :      // concept requirements
                               :      __glibcxx_function_requires(_RandomAccessIteratorConcept<
                               :	    _RandomAccessIterator>)
                               :      __glibcxx_function_requires(_LessThanComparableConcept<
                               :	    typename iterator_traits<_RandomAccessIterator>::value_type>)
                               :      __glibcxx_requires_valid_range(__first, __last);
                               :
                               :      return __first + std::__is_heap_until(__first, std::distance(__first,
                               :								   __last));
                               :    }
                               :
                               :  /**
                               :   *  @brief  Search the end of a heap using comparison functor.
                               :   *  @param  __first  Start of range.
                               :   *  @param  __last   End of range.
                               :   *  @param  __comp   Comparison functor to use.
                               :   *  @return  An iterator pointing to the first element not in the heap.
                               :   *  @ingroup heap_algorithms
                               :   *
                               :   *  This operation returns the last iterator i in [__first, __last) for which
                               :   *  the range [__first, i) is a heap.  Comparisons are made using __comp.
                               :  */
                               :  template<typename _RandomAccessIterator, typename _Compare>
                               :    inline _RandomAccessIterator
                               :    is_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last,
                               :		  _Compare __comp)
                               :    {
                               :      // concept requirements
                               :      __glibcxx_function_requires(_RandomAccessIteratorConcept<
                               :	    _RandomAccessIterator>)
                               :      __glibcxx_requires_valid_range(__first, __last);
                               :
                               :      return __first + std::__is_heap_until(__first, std::distance(__first,
                               :								   __last),
                               :					    __comp);
                               :    }
                               :
                               :  /**
                               :   *  @brief  Determines whether a range is a heap.
                               :   *  @param  __first  Start of range.
                               :   *  @param  __last   End of range.
                               :   *  @return  True if range is a heap, false otherwise.
                               :   *  @ingroup heap_algorithms
                               :  */
                               :  template<typename _RandomAccessIterator>
                               :    inline bool
                               :    is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
                               :    { return std::is_heap_until(__first, __last) == __last; }
                               :
                               :  /**
                               :   *  @brief  Determines whether a range is a heap using comparison functor.
                               :   *  @param  __first  Start of range.
                               :   *  @param  __last   End of range.
                               :   *  @param  __comp   Comparison functor to use.
                               :   *  @return  True if range is a heap, false otherwise.
                               :   *  @ingroup heap_algorithms
                               :  */
                               :  template<typename _RandomAccessIterator, typename _Compare>
                               :    inline bool
                               :    is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
                               :	    _Compare __comp)
                               :    { return std::is_heap_until(__first, __last, __comp) == __last; }
                               :#endif
                               :
                               :_GLIBCXX_END_NAMESPACE_VERSION
                               :} // namespace
                               :
                               :#endif /* _STL_HEAP_H */
/* 
 * Total samples for file : "/usr/include/c++/4.8/bits/hashtable_policy.h"
 * 
 *   2636  2.2427    54  3.1896
 */


                               :// Internal policy header for unordered_set and unordered_map -*- C++ -*-
                               :
                               :// Copyright (C) 2010-2013 Free Software Foundation, Inc.
                               ://
                               :// This file is part of the GNU ISO C++ Library.  This library is free
                               :// software; you can redistribute it and/or modify it under the
                               :// terms of the GNU General Public License as published by the
                               :// Free Software Foundation; either version 3, or (at your option)
                               :// any later version.
                               :
                               :// This library is distributed in the hope that it will be useful,
                               :// but WITHOUT ANY WARRANTY; without even the implied warranty of
                               :// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                               :// GNU General Public License for more details.
                               :
                               :// Under Section 7 of GPL version 3, you are granted additional
                               :// permissions described in the GCC Runtime Library Exception, version
                               :// 3.1, as published by the Free Software Foundation.
                               :
                               :// You should have received a copy of the GNU General Public License and
                               :// a copy of the GCC Runtime Library Exception along with this program;
                               :// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                               :// <http://www.gnu.org/licenses/>.
                               :
                               :/** @file bits/hashtable_policy.h
                               : *  This is an internal header file, included by other library headers.
                               : *  Do not attempt to use it directly.
                               : *  @headername{unordered_map,unordered_set}
                               : */
                               :
                               :#ifndef _HASHTABLE_POLICY_H
                               :#define _HASHTABLE_POLICY_H 1
                               :
                               :namespace std _GLIBCXX_VISIBILITY(default)
                               :{
                               :_GLIBCXX_BEGIN_NAMESPACE_VERSION
                               :
                               :  template<typename _Key, typename _Value, typename _Alloc,
                               :	   typename _ExtractKey, typename _Equal,
                               :	   typename _H1, typename _H2, typename _Hash,
                               :	   typename _RehashPolicy, typename _Traits>
                               :    class _Hashtable;
                               :
                               :_GLIBCXX_END_NAMESPACE_VERSION
                               :
                               :namespace __detail
                               :{
                               :_GLIBCXX_BEGIN_NAMESPACE_VERSION
                               :
                               :  /**
                               :   *  @defgroup hashtable-detail Base and Implementation Classes
                               :   *  @ingroup unordered_associative_containers
                               :   *  @{
                               :   */
                               :  template<typename _Key, typename _Value,
                               :	   typename _ExtractKey, typename _Equal,
                               :	   typename _H1, typename _H2, typename _Hash, typename _Traits>
                               :    struct _Hashtable_base;
                               :
                               :  // Helper function: return distance(first, last) for forward
                               :  // iterators, or 0 for input iterators.
                               :  template<class _Iterator>
                               :    inline typename std::iterator_traits<_Iterator>::difference_type
                               :    __distance_fw(_Iterator __first, _Iterator __last,
                               :		  std::input_iterator_tag)
                               :    { return 0; }
                               :
                               :  template<class _Iterator>
                               :    inline typename std::iterator_traits<_Iterator>::difference_type
                               :    __distance_fw(_Iterator __first, _Iterator __last,
                               :		  std::forward_iterator_tag)
                               :    { return std::distance(__first, __last); }
                               :
                               :  template<class _Iterator>
                               :    inline typename std::iterator_traits<_Iterator>::difference_type
                               :    __distance_fw(_Iterator __first, _Iterator __last)
                               :    {
                               :      typedef typename std::iterator_traits<_Iterator>::iterator_category _Tag;
                               :      return __distance_fw(__first, __last, _Tag());
                               :    }
                               :
                               :  // Helper type used to detect whether the hash functor is noexcept.
                               :  template <typename _Key, typename _Hash>
                               :    struct __is_noexcept_hash : std::integral_constant<bool,
                               :	noexcept(declval<const _Hash&>()(declval<const _Key&>()))>
                               :    { };
                               :
                               :  struct _Identity
                               :  {
                               :    template<typename _Tp>
                               :      _Tp&&
                               :      operator()(_Tp&& __x) const
                               :      { return std::forward<_Tp>(__x); }
                               :  };
                               :
                               :  struct _Select1st
                               :  {
                               :    template<typename _Tp>
                               :      auto
                               :      operator()(_Tp&& __x) const
                               :      -> decltype(std::get<0>(std::forward<_Tp>(__x)))
                               :      { return std::get<0>(std::forward<_Tp>(__x)); }
                               :  };
                               :
                               :  // Auxiliary types used for all instantiations of _Hashtable nodes
                               :  // and iterators.
                               :
                               :  /**
                               :   *  struct _Hashtable_traits
                               :   *
                               :   *  Important traits for hash tables.
                               :   *
                               :   *  @tparam _Cache_hash_code  Boolean value. True if the value of
                               :   *  the hash function is stored along with the value. This is a
                               :   *  time-space tradeoff.  Storing it may improve lookup speed by
                               :   *  reducing the number of times we need to call the _Equal
                               :   *  function.
                               :   *
                               :   *  @tparam _Constant_iterators  Boolean value. True if iterator and
                               :   *  const_iterator are both constant iterator types. This is true
                               :   *  for unordered_set and unordered_multiset, false for
                               :   *  unordered_map and unordered_multimap.
                               :   *
                               :   *  @tparam _Unique_keys  Boolean value. True if the return value
                               :   *  of _Hashtable::count(k) is always at most one, false if it may
                               :   *  be an arbitrary number. This is true for unordered_set and
                               :   *  unordered_map, false for unordered_multiset and
                               :   *  unordered_multimap.
                               :   */
                               :  template<bool _Cache_hash_code, bool _Constant_iterators, bool _Unique_keys>
                               :    struct _Hashtable_traits
                               :    {
                               :      template<bool _Cond>
                               :	using __bool_constant = integral_constant<bool, _Cond>;
                               :
                               :      using __hash_cached = __bool_constant<_Cache_hash_code>;
                               :      using __constant_iterators = __bool_constant<_Constant_iterators>;
                               :      using __unique_keys = __bool_constant<_Unique_keys>;
                               :    };
                               :
                               :  /**
                               :   *  struct _Hash_node_base
                               :   *
                               :   *  Nodes, used to wrap elements stored in the hash table.  A policy
                               :   *  template parameter of class template _Hashtable controls whether
                               :   *  nodes also store a hash code. In some cases (e.g. strings) this
                               :   *  may be a performance win.
                               :   */
                               :  struct _Hash_node_base
                               :  {
                               :    _Hash_node_base* _M_nxt;
                               :
                               :    _Hash_node_base() : _M_nxt() { }
                               :
                               :    _Hash_node_base(_Hash_node_base* __next) : _M_nxt(__next) { }
                               :  };
                               :
                               :  /**
                               :   *  Primary template struct _Hash_node.
                               :   */
                               :  template<typename _Value, bool _Cache_hash_code>
                               :    struct _Hash_node;
                               :
                               :  /**
                               :   *  Specialization for nodes with caches, struct _Hash_node.
                               :   *
                               :   *  Base class is __detail::_Hash_node_base.
                               :   */
                               :  template<typename _Value>
                               :    struct _Hash_node<_Value, true> : _Hash_node_base
                               :    {
                               :      _Value       _M_v;
                               :      std::size_t  _M_hash_code;
                               :
                               :      template<typename... _Args>
                               :	_Hash_node(_Args&&... __args)
                               :	: _M_v(std::forward<_Args>(__args)...), _M_hash_code() { }
                               :
                               :      _Hash_node*
                               :      _M_next() const { return static_cast<_Hash_node*>(_M_nxt); }
                               :    };
                               :
                               :  /**
                               :   *  Specialization for nodes without caches, struct _Hash_node.
                               :   *
                               :   *  Base class is __detail::_Hash_node_base.
                               :   */
                               :  template<typename _Value>
                               :    struct _Hash_node<_Value, false> : _Hash_node_base
                               :    {
                               :      _Value       _M_v;
                               :
                               :      template<typename... _Args>
                               :	_Hash_node(_Args&&... __args)
                               :	: _M_v(std::forward<_Args>(__args)...) { }
                               :
                               :      _Hash_node*
                               :      _M_next() const { return static_cast<_Hash_node*>(_M_nxt); }
                               :    };
                               :
                               :  /// Base class for node iterators.
                               :  template<typename _Value, bool _Cache_hash_code>
                               :    struct _Node_iterator_base
                               :    {
                               :      using __node_type = _Hash_node<_Value, _Cache_hash_code>;
                               :
                               :      __node_type*  _M_cur;
                               :
                               :      _Node_iterator_base(__node_type* __p)
     5  0.0043     0       0   :      : _M_cur(__p) { }
                               :
                               :      void
                               :      _M_incr()
                               :      { _M_cur = _M_cur->_M_next(); }
                               :    };
                               :
                               :  template<typename _Value, bool _Cache_hash_code>
                               :    inline bool
                               :    operator==(const _Node_iterator_base<_Value, _Cache_hash_code>& __x,
                               :	       const _Node_iterator_base<_Value, _Cache_hash_code >& __y)
                               :    { return __x._M_cur == __y._M_cur; }
                               :
                               :  template<typename _Value, bool _Cache_hash_code>
                               :    inline bool
                               :    operator!=(const _Node_iterator_base<_Value, _Cache_hash_code>& __x,
                               :	       const _Node_iterator_base<_Value, _Cache_hash_code>& __y)
                               :    { return __x._M_cur != __y._M_cur; }
                               :
                               :  /// Node iterators, used to iterate through all the hashtable.
                               :  template<typename _Value, bool __constant_iterators, bool __cache>
                               :    struct _Node_iterator
                               :    : public _Node_iterator_base<_Value, __cache>
                               :    {
                               :    private:
                               :      using __base_type = _Node_iterator_base<_Value, __cache>;
                               :      using __node_type = typename __base_type::__node_type;
                               :
                               :    public:
                               :      typedef _Value                                   value_type;
                               :      typedef std::ptrdiff_t                           difference_type;
                               :      typedef std::forward_iterator_tag                iterator_category;
                               :
                               :      using pointer = typename std::conditional<__constant_iterators,
                               :						const _Value*, _Value*>::type;
                               :
                               :      using reference = typename std::conditional<__constant_iterators,
                               :						  const _Value&, _Value&>::type;
                               :
                               :      _Node_iterator()
                               :      : __base_type(0) { }
                               :
                               :      explicit
                               :      _Node_iterator(__node_type* __p)
                               :      : __base_type(__p) { }
                               :
                               :      reference
                               :      operator*() const
                               :      { return this->_M_cur->_M_v; }
                               :
                               :      pointer
                               :      operator->() const
                               :      { return std::__addressof(this->_M_cur->_M_v); }
                               :
                               :      _Node_iterator&
                               :      operator++()
                               :      {
                               :	this->_M_incr();
                               :	return *this;
                               :      }
                               :
                               :      _Node_iterator
                               :      operator++(int)
                               :      {
                               :	_Node_iterator __tmp(*this);
                               :	this->_M_incr();
                               :	return __tmp;
                               :      }
                               :    };
                               :
                               :  /// Node const_iterators, used to iterate through all the hashtable.
                               :  template<typename _Value, bool __constant_iterators, bool __cache>
                               :    struct _Node_const_iterator
                               :    : public _Node_iterator_base<_Value, __cache>
                               :    {
                               :    private:
                               :      using __base_type = _Node_iterator_base<_Value, __cache>;
                               :      using __node_type = typename __base_type::__node_type;
                               :
                               :    public:
                               :      typedef _Value                                   value_type;
                               :      typedef std::ptrdiff_t                           difference_type;
                               :      typedef std::forward_iterator_tag                iterator_category;
                               :
                               :      typedef const _Value*                            pointer;
                               :      typedef const _Value&                            reference;
                               :
                               :      _Node_const_iterator()
                               :      : __base_type(0) { }
                               :
                               :      explicit
                               :      _Node_const_iterator(__node_type* __p)
                               :      : __base_type(__p) { }
                               :
                               :      _Node_const_iterator(const _Node_iterator<_Value, __constant_iterators,
                               :			   __cache>& __x)
                               :      : __base_type(__x._M_cur) { }
                               :
                               :      reference
                               :      operator*() const
                               :      { return this->_M_cur->_M_v; }
                               :
                               :      pointer
                               :      operator->() const
                               :      { return std::__addressof(this->_M_cur->_M_v); }
                               :
                               :      _Node_const_iterator&
                               :      operator++()
                               :      {
                               :	this->_M_incr();
                               :	return *this;
                               :      }
                               :
                               :      _Node_const_iterator
                               :      operator++(int)
                               :      {
                               :	_Node_const_iterator __tmp(*this);
                               :	this->_M_incr();
                               :	return __tmp;
                               :      }
                               :    };
                               :
                               :  // Many of class template _Hashtable's template parameters are policy
                               :  // classes.  These are defaults for the policies.
                               :
                               :  /// Default range hashing function: use division to fold a large number
                               :  /// into the range [0, N).
                               :  struct _Mod_range_hashing
                               :  {
                               :    typedef std::size_t first_argument_type;
                               :    typedef std::size_t second_argument_type;
                               :    typedef std::size_t result_type;
                               :
                               :    result_type
                               :    operator()(first_argument_type __num, second_argument_type __den) const
  1522  1.2949    36  2.1264   :    { return __num % __den; }
                               :  };
                               :
                               :  /// Default ranged hash function H.  In principle it should be a
                               :  /// function object composed from objects of type H1 and H2 such that
                               :  /// h(k, N) = h2(h1(k), N), but that would mean making extra copies of
                               :  /// h1 and h2.  So instead we'll just use a tag to tell class template
                               :  /// hashtable to do that composition.
                               :  struct _Default_ranged_hash { };
                               :
                               :  /// Default value for rehash policy.  Bucket size is (usually) the
                               :  /// smallest prime that keeps the load factor small enough.
                               :  struct _Prime_rehash_policy
                               :  {
                               :    _Prime_rehash_policy(float __z = 1.0)
                               :    : _M_max_load_factor(__z), _M_next_resize(0) { }
                               :
                               :    float
                               :    max_load_factor() const noexcept
                               :    { return _M_max_load_factor; }
                               :
                               :    // Return a bucket size no smaller than n.
                               :    std::size_t
                               :    _M_next_bkt(std::size_t __n) const;
                               :
                               :    // Return a bucket count appropriate for n elements
                               :    std::size_t
                               :    _M_bkt_for_elements(std::size_t __n) const
                               :    { return __builtin_ceil(__n / (long double)_M_max_load_factor); }
                               :
                               :    // __n_bkt is current bucket count, __n_elt is current element count,
                               :    // and __n_ins is number of elements to be inserted.  Do we need to
                               :    // increase bucket count?  If so, return make_pair(true, n), where n
                               :    // is the new bucket count.  If not, return make_pair(false, 0).
                               :    std::pair<bool, std::size_t>
                               :    _M_need_rehash(std::size_t __n_bkt, std::size_t __n_elt,
                               :		   std::size_t __n_ins) const;
                               :
                               :    typedef std::size_t _State;
                               :
                               :    _State
                               :    _M_state() const
                               :    { return _M_next_resize; }
                               :
                               :    void
                               :    _M_reset(_State __state)
                               :    { _M_next_resize = __state; }
                               :
                               :    enum { _S_n_primes = sizeof(unsigned long) != 8 ? 256 : 256 + 48 };
                               :
                               :    static const std::size_t _S_growth_factor = 2;
                               :
                               :    float                _M_max_load_factor;
                               :    mutable std::size_t  _M_next_resize;
                               :  };
                               :
                               :  // Base classes for std::_Hashtable.  We define these base classes
                               :  // because in some cases we want to do different things depending on
                               :  // the value of a policy class.  In some cases the policy class
                               :  // affects which member functions and nested typedefs are defined;
                               :  // we handle that by specializing base class templates.  Several of
                               :  // the base class templates need to access other members of class
                               :  // template _Hashtable, so we use a variant of the "Curiously
                               :  // Recurring Template Pattern" (CRTP) technique.
                               :
                               :  /**
                               :   *  Primary class template _Map_base.
                               :   *
                               :   *  If the hashtable has a value type of the form pair<T1, T2> and a
                               :   *  key extraction policy (_ExtractKey) that returns the first part
                               :   *  of the pair, the hashtable gets a mapped_type typedef.  If it
                               :   *  satisfies those criteria and also has unique keys, then it also
                               :   *  gets an operator[].
                               :   */
                               :  template<typename _Key, typename _Value, typename _Alloc,
                               :	   typename _ExtractKey, typename _Equal,
                               :	   typename _H1, typename _H2, typename _Hash,
                               :	   typename _RehashPolicy, typename _Traits,
                               :	   bool _Unique_keys = _Traits::__unique_keys::value>
                               :    struct _Map_base { };
                               :
                               :  /// Partial specialization, __unique_keys set to false.
                               :  template<typename _Key, typename _Pair, typename _Alloc, typename _Equal,
                               :	   typename _H1, typename _H2, typename _Hash,
                               :	   typename _RehashPolicy, typename _Traits>
                               :    struct _Map_base<_Key, _Pair, _Alloc, _Select1st, _Equal,
                               :		     _H1, _H2, _Hash, _RehashPolicy, _Traits, false>
                               :    {
                               :      using mapped_type = typename std::tuple_element<1, _Pair>::type;
                               :    };
                               :
                               :  /// Partial specialization, __unique_keys set to true.
                               :  template<typename _Key, typename _Pair, typename _Alloc, typename _Equal,
                               :	   typename _H1, typename _H2, typename _Hash,
                               :	   typename _RehashPolicy, typename _Traits>
                               :    struct _Map_base<_Key, _Pair, _Alloc, _Select1st, _Equal,
                               :		     _H1, _H2, _Hash, _RehashPolicy, _Traits, true>
                               :    {
                               :    private:
                               :      using __hashtable_base = __detail::_Hashtable_base<_Key, _Pair,
                               :							 _Select1st,
                               :							_Equal, _H1, _H2, _Hash,
                               :							  _Traits>;
                               :
                               :      using __hashtable = _Hashtable<_Key, _Pair, _Alloc,
                               :				     _Select1st, _Equal,
                               :				     _H1, _H2, _Hash, _RehashPolicy, _Traits>;
                               :
                               :      using __hash_code = typename __hashtable_base::__hash_code;
                               :      using __node_type = typename __hashtable_base::__node_type;
                               :
                               :    public:
                               :      using key_type = typename __hashtable_base::key_type;
                               :      using iterator = typename __hashtable_base::iterator;
                               :      using mapped_type = typename std::tuple_element<1, _Pair>::type;
                               :
                               :      mapped_type&
                               :      operator[](const key_type& __k);
                               :
                               :      mapped_type&
                               :      operator[](key_type&& __k);
                               :
                               :      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                               :      // DR 761. unordered_map needs an at() member function.
                               :      mapped_type&
                               :      at(const key_type& __k);
                               :
                               :      const mapped_type&
                               :      at(const key_type& __k) const;
                               :    };
                               :
                               :  template<typename _Key, typename _Pair, typename _Alloc, typename _Equal,
                               :	   typename _H1, typename _H2, typename _Hash,
                               :	   typename _RehashPolicy, typename _Traits>
                               :    typename _Map_base<_Key, _Pair, _Alloc, _Select1st, _Equal,
                               :		       _H1, _H2, _Hash, _RehashPolicy, _Traits, true>
                               :		       ::mapped_type&
   285  0.2425     4  0.2363   :    _Map_base<_Key, _Pair, _Alloc, _Select1st, _Equal, /* std::__detail::_Map_base<std::pair<int, int>, std::pair<std::pair<int, int> const, std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>, std::allocator<std::pair<int, int> > >, pair_cmp> >, std::allocator<std::pair<std::pair<int, int> const, std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>, std::allocator<std::pair<int, int> > >, pair_cmp> > >, std::__detail::_Select1st, std::equal_to<std::pair<int, int> >, pair_hash, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<true, false, true>, true>::operator[](std::pair<int, int> const&) [clone .constprop.380]    305  0.2595     3  0.1772, std::__detail::_Map_base<std::pair<int, int>, std::pair<std::pair<int, int> const, std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>, std::allocator<std::pair<int, int> > >, pair_cmp> >, std::allocator<std::pair<std::pair<int, int> const, std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>, std::allocator<std::pair<int, int> > >, pair_cmp> > >, std::__detail::_Select1st, std::equal_to<std::pair<int, int> >, pair_hash, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<true, false, true>, true>::operator[](std::pair<int, int> const&) [clone .constprop.381]    204  0.1736     3  0.1772, std::__detail::_Map_base<int, std::pair<int const, std::vector<Path*, std::allocator<Path*> > >, std::allocator<std::pair<int const, std::vector<Path*, std::allocator<Path*> > > >, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>, true>::operator[](int const&)   3887  3.3070    75  4.4300, std::__detail::_Map_base<int, std::pair<int const, std::vector<bitset, std::allocator<bitset> > >, std::allocator<std::pair<int const, std::vector<bitset, std::allocator<bitset> > > >, std::__detail::_Select1st, std::equal_to<int>, std::hash<int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>, true>::operator[](int const&)   1478  1.2575    65  3.8393, total:   5874  4.9975   146  8.6237 */
                               :	      _H1, _H2, _Hash, _RehashPolicy, _Traits, true>::
   109  0.0927     1  0.0591   :    operator[](const key_type& __k)
                               :    {
   247  0.2101     6  0.3544   :      __hashtable* __h = static_cast<__hashtable*>(this);
                               :      __hash_code __code = __h->_M_hash_code(__k);
                               :      std::size_t __n = __h->_M_bucket_index(__k, __code);
                               :      __node_type* __p = __h->_M_find_node(__n, __k, __code);
                               :
                               :      if (!__p)
                               :	{
                               :	  __p = __h->_M_allocate_node(std::piecewise_construct,
                               :				      std::tuple<const key_type&>(__k),
                               :				      std::tuple<>());
    39  0.0332     0       0   :	  return __h->_M_insert_unique_node(__n, __code, __p)->second;
                               :	}
                               :
   205  0.1744     4  0.2363   :      return (__p->_M_v).second;
   152  0.1293     3  0.1772   :    }
                               :
                               :  template<typename _Key, typename _Pair, typename _Alloc, typename _Equal,
                               :	   typename _H1, typename _H2, typename _Hash,
                               :	   typename _RehashPolicy, typename _Traits>
                               :    typename _Map_base<_Key, _Pair, _Alloc, _Select1st, _Equal,
                               :		       _H1, _H2, _Hash, _RehashPolicy, _Traits, true>
                               :		       ::mapped_type&
     7  0.0060     0       0   :    _Map_base<_Key, _Pair, _Alloc, _Select1st, _Equal, /* std::__detail::_Map_base<std::pair<int, int>, std::pair<std::pair<int, int> const, std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>, std::allocator<std::pair<int, int> > >, pair_cmp> >, std::allocator<std::pair<std::pair<int, int> const, std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>, std::allocator<std::pair<int, int> > >, pair_cmp> > >, std::__detail::_Select1st, std::equal_to<std::pair<int, int> >, pair_hash, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<true, false, true>, true>::operator[](std::pair<int, int>&&) total:    936  0.7963    36  2.1264 */
                               :	      _H1, _H2, _Hash, _RehashPolicy, _Traits, true>::
                               :    operator[](key_type&& __k)
                               :    {
    26  0.0221     0       0   :      __hashtable* __h = static_cast<__hashtable*>(this);
                               :      __hash_code __code = __h->_M_hash_code(__k);
                               :      std::size_t __n = __h->_M_bucket_index(__k, __code);
                               :      __node_type* __p = __h->_M_find_node(__n, __k, __code);
                               :
                               :      if (!__p)
                               :	{
                               :	  __p = __h->_M_allocate_node(std::piecewise_construct,
                               :				      std::forward_as_tuple(std::move(__k)),
                               :				      std::tuple<>());
                               :	  return __h->_M_insert_unique_node(__n, __code, __p)->second;
                               :	}
                               :
    15  0.0128     0       0   :      return (__p->_M_v).second;
     3  0.0026     0       0   :    }
                               :
                               :  template<typename _Key, typename _Pair, typename _Alloc, typename _Equal,
                               :	   typename _H1, typename _H2, typename _Hash,
                               :	   typename _RehashPolicy, typename _Traits>
                               :    typename _Map_base<_Key, _Pair, _Alloc, _Select1st, _Equal,
                               :		       _H1, _H2, _Hash, _RehashPolicy, _Traits, true>
                               :		       ::mapped_type&
                               :    _Map_base<_Key, _Pair, _Alloc, _Select1st, _Equal,
                               :	      _H1, _H2, _Hash, _RehashPolicy, _Traits, true>::
                               :    at(const key_type& __k)
                               :    {
                               :      __hashtable* __h = static_cast<__hashtable*>(this);
                               :      __hash_code __code = __h->_M_hash_code(__k);
                               :      std::size_t __n = __h->_M_bucket_index(__k, __code);
                               :      __node_type* __p = __h->_M_find_node(__n, __k, __code);
                               :
                               :      if (!__p)
                               :	__throw_out_of_range(__N("_Map_base::at"));
                               :      return (__p->_M_v).second;
                               :    }
                               :
                               :  template<typename _Key, typename _Pair, typename _Alloc, typename _Equal,
                               :	   typename _H1, typename _H2, typename _Hash,
                               :	   typename _RehashPolicy, typename _Traits>
                               :    const typename _Map_base<_Key, _Pair, _Alloc, _Select1st,
                               :			     _Equal, _H1, _H2, _Hash, _RehashPolicy,
                               :			     _Traits, true>::mapped_type&
                               :    _Map_base<_Key, _Pair, _Alloc, _Select1st, _Equal,
                               :	      _H1, _H2, _Hash, _RehashPolicy, _Traits, true>::
                               :    at(const key_type& __k) const
                               :    {
                               :      const __hashtable* __h = static_cast<const __hashtable*>(this);
                               :      __hash_code __code = __h->_M_hash_code(__k);
                               :      std::size_t __n = __h->_M_bucket_index(__k, __code);
                               :      __node_type* __p = __h->_M_find_node(__n, __k, __code);
                               :
                               :      if (!__p)
                               :	__throw_out_of_range(__N("_Map_base::at"));
                               :      return (__p->_M_v).second;
                               :    }
                               :
                               :  /**
                               :   *  Primary class template _Insert_base.
                               :   *
                               :   *  insert member functions appropriate to all _Hashtables.
                               :   */
                               :  template<typename _Key, typename _Value, typename _Alloc,
                               :	   typename _ExtractKey, typename _Equal,
                               :	   typename _H1, typename _H2, typename _Hash,
                               :	   typename _RehashPolicy, typename _Traits>
                               :    struct _Insert_base
                               :    {
                               :      using __hashtable = _Hashtable<_Key, _Value, _Alloc, _ExtractKey,
                               :				     _Equal, _H1, _H2, _Hash,
                               :				     _RehashPolicy, _Traits>;
                               :
                               :      using __hashtable_base = _Hashtable_base<_Key, _Value, _ExtractKey,
                               :					       _Equal, _H1, _H2, _Hash,
                               :					       _Traits>;
                               :
                               :      using value_type = typename __hashtable_base::value_type;
                               :      using iterator = typename __hashtable_base::iterator;
                               :      using const_iterator =  typename __hashtable_base::const_iterator;
                               :      using size_type = typename __hashtable_base::size_type;
                               :
                               :      using __unique_keys = typename __hashtable_base::__unique_keys;
                               :      using __ireturn_type = typename __hashtable_base::__ireturn_type;
                               :      using __iconv_type = typename __hashtable_base::__iconv_type;
                               :
                               :      __hashtable&
                               :      _M_conjure_hashtable()
                               :      { return *(static_cast<__hashtable*>(this)); }
                               :
                               :      __ireturn_type
                               :      insert(const value_type& __v)
                               :      {
                               :	__hashtable& __h = _M_conjure_hashtable();
                               :	return __h._M_insert(__v, __unique_keys());
                               :      }
                               :
                               :      iterator
                               :      insert(const_iterator, const value_type& __v)
                               :      { return __iconv_type()(insert(__v)); }
                               :
                               :      void
                               :      insert(initializer_list<value_type> __l)
                               :      { this->insert(__l.begin(), __l.end()); }
                               :
                               :      template<typename _InputIterator>
                               :	void
                               :	insert(_InputIterator __first, _InputIterator __last);
                               :    };
                               :
                               :  template<typename _Key, typename _Value, typename _Alloc,
                               :	   typename _ExtractKey, typename _Equal,
                               :	   typename _H1, typename _H2, typename _Hash,
                               :	   typename _RehashPolicy, typename _Traits>
                               :    template<typename _InputIterator>
                               :      void
                               :      _Insert_base<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash,
                               :		    _RehashPolicy, _Traits>::
                               :      insert(_InputIterator __first, _InputIterator __last)
                               :      {
                               :	using __rehash_type = typename __hashtable::__rehash_type;
                               :	using __rehash_state = typename __hashtable::__rehash_state;
                               :	using pair_type = std::pair<bool, std::size_t>;
                               :
                               :	size_type __n_elt = __detail::__distance_fw(__first, __last);
                               :
                               :	__hashtable& __h = _M_conjure_hashtable();
                               :	__rehash_type& __rehash = __h._M_rehash_policy;
                               :	const __rehash_state& __saved_state = __rehash._M_state();
                               :	pair_type __do_rehash = __rehash._M_need_rehash(__h._M_bucket_count,
                               :							__h._M_element_count,
                               :							__n_elt);
                               :
                               :	if (__do_rehash.first)
                               :	  __h._M_rehash(__do_rehash.second, __saved_state);
                               :
                               :	for (; __first != __last; ++__first)
                               :	  __h._M_insert(*__first, __unique_keys());
                               :      }
                               :
                               :  /**
                               :   *  Primary class template _Insert.
                               :   *
                               :   *  Select insert member functions appropriate to _Hashtable policy choices.
                               :   */
                               :  template<typename _Key, typename _Value, typename _Alloc,
                               :	   typename _ExtractKey, typename _Equal,
                               :	   typename _H1, typename _H2, typename _Hash,
                               :	   typename _RehashPolicy, typename _Traits,
                               :	   bool _Constant_iterators = _Traits::__constant_iterators::value,
                               :	   bool _Unique_keys = _Traits::__unique_keys::value>
                               :    struct _Insert;
                               :
                               :  /// Specialization.
                               :  template<typename _Key, typename _Value, typename _Alloc,
                               :	   typename _ExtractKey, typename _Equal,
                               :	   typename _H1, typename _H2, typename _Hash,
                               :	   typename _RehashPolicy, typename _Traits>
                               :    struct _Insert<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash,
                               :		   _RehashPolicy, _Traits, true, true>
                               :    : public _Insert_base<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                               :			   _H1, _H2, _Hash, _RehashPolicy, _Traits>
                               :    {
                               :      using __base_type = _Insert_base<_Key, _Value, _Alloc, _ExtractKey,
                               :					_Equal, _H1, _H2, _Hash,
                               :					_RehashPolicy, _Traits>;
                               :      using value_type = typename __base_type::value_type;
                               :      using iterator = typename __base_type::iterator;
                               :      using const_iterator =  typename __base_type::const_iterator;
                               :
                               :      using __unique_keys = typename __base_type::__unique_keys;
                               :      using __hashtable = typename __base_type::__hashtable;
                               :
                               :      using __base_type::insert;
                               :
                               :      std::pair<iterator, bool>
                               :      insert(value_type&& __v)
                               :      {
                               :	__hashtable& __h = this->_M_conjure_hashtable();
                               :	return __h._M_insert(std::move(__v), __unique_keys());
                               :      }
                               :
                               :      iterator
                               :      insert(const_iterator, value_type&& __v)
                               :      { return insert(std::move(__v)).first; }
                               :    };
                               :
                               :  /// Specialization.
                               :  template<typename _Key, typename _Value, typename _Alloc,
                               :	   typename _ExtractKey, typename _Equal,
                               :	   typename _H1, typename _H2, typename _Hash,
                               :	   typename _RehashPolicy, typename _Traits>
                               :    struct _Insert<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash,
                               :		   _RehashPolicy, _Traits, true, false>
                               :    : public _Insert_base<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                               :			   _H1, _H2, _Hash, _RehashPolicy, _Traits>
                               :    {
                               :      using __base_type = _Insert_base<_Key, _Value, _Alloc, _ExtractKey,
                               :					_Equal, _H1, _H2, _Hash,
                               :					_RehashPolicy, _Traits>;
                               :      using value_type = typename __base_type::value_type;
                               :      using iterator = typename __base_type::iterator;
                               :      using const_iterator =  typename __base_type::const_iterator;
                               :
                               :      using __unique_keys = typename __base_type::__unique_keys;
                               :      using __hashtable = typename __base_type::__hashtable;
                               :
                               :      using __base_type::insert;
                               :
                               :      iterator
                               :      insert(value_type&& __v)
                               :      {
                               :	__hashtable& __h = this->_M_conjure_hashtable();
                               :	return __h._M_insert(std::move(__v), __unique_keys());
                               :      }
                               :
                               :      iterator
                               :      insert(const_iterator, value_type&& __v)
                               :      { return insert(std::move(__v)); }
                               :     };
                               :
                               :  /// Specialization.
                               :  template<typename _Key, typename _Value, typename _Alloc,
                               :	   typename _ExtractKey, typename _Equal,
                               :	   typename _H1, typename _H2, typename _Hash,
                               :	   typename _RehashPolicy, typename _Traits, bool _Unique_keys>
                               :    struct _Insert<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash,
                               :		   _RehashPolicy, _Traits, false, _Unique_keys>
                               :    : public _Insert_base<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                               :			   _H1, _H2, _Hash, _RehashPolicy, _Traits>
                               :    {
                               :      using __base_type = _Insert_base<_Key, _Value, _Alloc, _ExtractKey,
                               :				       _Equal, _H1, _H2, _Hash,
                               :				       _RehashPolicy, _Traits>;
                               :      using value_type = typename __base_type::value_type;
                               :      using iterator = typename __base_type::iterator;
                               :      using const_iterator =  typename __base_type::const_iterator;
                               :
                               :      using __unique_keys = typename __base_type::__unique_keys;
                               :      using __hashtable = typename __base_type::__hashtable;
                               :      using __ireturn_type = typename __base_type::__ireturn_type;
                               :      using __iconv_type = typename __base_type::__iconv_type;
                               :
                               :      using __base_type::insert;
                               :
                               :      template<typename _Pair>
                               :	using __is_cons = std::is_constructible<value_type, _Pair&&>;
                               :
                               :      template<typename _Pair>
                               :	using _IFcons = std::enable_if<__is_cons<_Pair>::value>;
                               :
                               :      template<typename _Pair>
                               :	using _IFconsp = typename _IFcons<_Pair>::type;
                               :
                               :      template<typename _Pair, typename = _IFconsp<_Pair>>
                               :	__ireturn_type
                               :	insert(_Pair&& __v)
                               :	{
                               :	  __hashtable& __h = this->_M_conjure_hashtable();
                               :	  return __h._M_emplace(__unique_keys(), std::forward<_Pair>(__v));
                               :	}
                               :
                               :      template<typename _Pair, typename = _IFconsp<_Pair>>
                               :	iterator
                               :	insert(const_iterator, _Pair&& __v)
                               :	{ return __iconv_type()(insert(std::forward<_Pair>(__v))); }
                               :   };
                               :
                               :  /**
                               :   *  Primary class template  _Rehash_base.
                               :   *
                               :   *  Give hashtable the max_load_factor functions and reserve iff the
                               :   *  rehash policy is _Prime_rehash_policy.
                               :  */
                               :  template<typename _Key, typename _Value, typename _Alloc,
                               :	   typename _ExtractKey, typename _Equal,
                               :	   typename _H1, typename _H2, typename _Hash,
                               :	   typename _RehashPolicy, typename _Traits>
                               :    struct _Rehash_base;
                               :
                               :  /// Specialization.
                               :  template<typename _Key, typename _Value, typename _Alloc,
                               :	   typename _ExtractKey, typename _Equal,
                               :	   typename _H1, typename _H2, typename _Hash, typename _Traits>
                               :    struct _Rehash_base<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                               :			_H1, _H2, _Hash, _Prime_rehash_policy, _Traits>
                               :    {
                               :      using __hashtable = _Hashtable<_Key, _Value, _Alloc, _ExtractKey,
                               :				     _Equal, _H1, _H2, _Hash,
                               :				     _Prime_rehash_policy, _Traits>;
                               :
                               :      float
                               :      max_load_factor() const noexcept
                               :      {
                               :	const __hashtable* __this = static_cast<const __hashtable*>(this);
                               :	return __this->__rehash_policy().max_load_factor();
                               :      }
                               :
                               :      void
                               :      max_load_factor(float __z)
                               :      {
                               :	__hashtable* __this = static_cast<__hashtable*>(this);
                               :	__this->__rehash_policy(_Prime_rehash_policy(__z));
                               :      }
                               :
                               :      void
                               :      reserve(std::size_t __n)
                               :      {
                               :	__hashtable* __this = static_cast<__hashtable*>(this);
                               :	__this->rehash(__builtin_ceil(__n / max_load_factor()));
                               :      }
                               :    };
                               :
                               :  /**
                               :   *  Primary class template _Hashtable_ebo_helper.
                               :   *
                               :   *  Helper class using EBO when it is not forbidden, type is not
                               :   *  final, and when it worth it, type is empty.
                               :   */
                               :  template<int _Nm, typename _Tp,
                               :	   bool __use_ebo = !__is_final(_Tp) && __is_empty(_Tp)>
                               :    struct _Hashtable_ebo_helper;
                               :
                               :  /// Specialization using EBO.
                               :  template<int _Nm, typename _Tp>
                               :    struct _Hashtable_ebo_helper<_Nm, _Tp, true>
                               :    : private _Tp
                               :    {
                               :      _Hashtable_ebo_helper() = default;
                               :
                               :      _Hashtable_ebo_helper(const _Tp& __tp) : _Tp(__tp)
                               :      { }
                               :
                               :      static const _Tp&
                               :      _S_cget(const _Hashtable_ebo_helper& __eboh)
                               :      { return static_cast<const _Tp&>(__eboh); }
                               :
                               :      static _Tp&
                               :      _S_get(_Hashtable_ebo_helper& __eboh)
                               :      { return static_cast<_Tp&>(__eboh); }
                               :    };
                               :
                               :  /// Specialization not using EBO.
                               :  template<int _Nm, typename _Tp>
                               :    struct _Hashtable_ebo_helper<_Nm, _Tp, false>
                               :    {
                               :      _Hashtable_ebo_helper() = default;
                               :
                               :      _Hashtable_ebo_helper(const _Tp& __tp) : _M_tp(__tp)
                               :      { }
                               :
                               :      static const _Tp&
                               :      _S_cget(const _Hashtable_ebo_helper& __eboh)
                               :      { return __eboh._M_tp; }
                               :
                               :      static _Tp&
                               :      _S_get(_Hashtable_ebo_helper& __eboh)
                               :      { return __eboh._M_tp; }
                               :
                               :    private:
                               :      _Tp _M_tp;
                               :    };
                               :
                               :  /**
                               :   *  Primary class template _Local_iterator_base.
                               :   *
                               :   *  Base class for local iterators, used to iterate within a bucket
                               :   *  but not between buckets.
                               :   */
                               :  template<typename _Key, typename _Value, typename _ExtractKey,
                               :	   typename _H1, typename _H2, typename _Hash,
                               :	   bool __cache_hash_code>
                               :    struct _Local_iterator_base;
                               :
                               :  /**
                               :   *  Primary class template _Hash_code_base.
                               :   *
                               :   *  Encapsulates two policy issues that aren't quite orthogonal.
                               :   *   (1) the difference between using a ranged hash function and using
                               :   *       the combination of a hash function and a range-hashing function.
                               :   *       In the former case we don't have such things as hash codes, so
                               :   *       we have a dummy type as placeholder.
                               :   *   (2) Whether or not we cache hash codes.  Caching hash codes is
                               :   *       meaningless if we have a ranged hash function.
                               :   *
                               :   *  We also put the key extraction objects here, for convenience.
                               :   *  Each specialization derives from one or more of the template
                               :   *  parameters to benefit from Ebo. This is important as this type
                               :   *  is inherited in some cases by the _Local_iterator_base type used
                               :   *  to implement local_iterator and const_local_iterator. As with
                               :   *  any iterator type we prefer to make it as small as possible.
                               :   *
                               :   *  Primary template is unused except as a hook for specializations.
                               :   */
                               :  template<typename _Key, typename _Value, typename _ExtractKey,
                               :	   typename _H1, typename _H2, typename _Hash,
                               :	   bool __cache_hash_code>
                               :    struct _Hash_code_base;
                               :
                               :  /// Specialization: ranged hash function, no caching hash codes.  H1
                               :  /// and H2 are provided but ignored.  We define a dummy hash code type.
                               :  template<typename _Key, typename _Value, typename _ExtractKey,
                               :	   typename _H1, typename _H2, typename _Hash>
                               :    struct _Hash_code_base<_Key, _Value, _ExtractKey, _H1, _H2, _Hash, false>
                               :    : private _Hashtable_ebo_helper<0, _ExtractKey>,
                               :      private _Hashtable_ebo_helper<1, _Hash>
                               :    {
                               :    private:
                               :      using __ebo_extract_key = _Hashtable_ebo_helper<0, _ExtractKey>;
                               :      using __ebo_hash = _Hashtable_ebo_helper<1, _Hash>;
                               :
                               :    protected:
                               :      typedef void* 					__hash_code;
                               :      typedef _Hash_node<_Value, false>			__node_type;
                               :
                               :      // We need the default constructor for the local iterators.
                               :      _Hash_code_base() = default;
                               :
                               :      _Hash_code_base(const _ExtractKey& __ex, const _H1&, const _H2&,
                               :		      const _Hash& __h)
                               :      : __ebo_extract_key(__ex), __ebo_hash(__h) { }
                               :
                               :      __hash_code
                               :      _M_hash_code(const _Key& __key) const
                               :      { return 0; }
                               :
                               :      std::size_t
                               :      _M_bucket_index(const _Key& __k, __hash_code, std::size_t __n) const
                               :      { return _M_ranged_hash()(__k, __n); }
                               :
                               :      std::size_t
                               :      _M_bucket_index(const __node_type* __p, std::size_t __n) const
                               :      { return _M_ranged_hash()(_M_extract()(__p->_M_v), __n); }
                               :
                               :      void
                               :      _M_store_code(__node_type*, __hash_code) const
                               :      { }
                               :
                               :      void
                               :      _M_copy_code(__node_type*, const __node_type*) const
                               :      { }
                               :
                               :      void
                               :      _M_swap(_Hash_code_base& __x)
                               :      {
                               :	std::swap(_M_extract(), __x._M_extract());
                               :	std::swap(_M_ranged_hash(), __x._M_ranged_hash());
                               :      }
                               :
                               :      const _ExtractKey&
                               :      _M_extract() const { return __ebo_extract_key::_S_cget(*this); }
                               :
                               :      _ExtractKey&
                               :      _M_extract() { return __ebo_extract_key::_S_get(*this); }
                               :
                               :      const _Hash&
                               :      _M_ranged_hash() const { return __ebo_hash::_S_cget(*this); }
                               :
                               :      _Hash&
                               :      _M_ranged_hash() { return __ebo_hash::_S_get(*this); }
                               :    };
                               :
                               :  // No specialization for ranged hash function while caching hash codes.
                               :  // That combination is meaningless, and trying to do it is an error.
                               :
                               :  /// Specialization: ranged hash function, cache hash codes.  This
                               :  /// combination is meaningless, so we provide only a declaration
                               :  /// and no definition.
                               :  template<typename _Key, typename _Value, typename _ExtractKey,
                               :	   typename _H1, typename _H2, typename _Hash>
                               :    struct _Hash_code_base<_Key, _Value, _ExtractKey, _H1, _H2, _Hash, true>;
                               :
                               :  /// Specialization: hash function and range-hashing function, no
                               :  /// caching of hash codes.
                               :  /// Provides typedef and accessor required by C++ 11.
                               :  template<typename _Key, typename _Value, typename _ExtractKey,
                               :	   typename _H1, typename _H2>
                               :    struct _Hash_code_base<_Key, _Value, _ExtractKey, _H1, _H2,
                               :			   _Default_ranged_hash, false>
                               :    : private _Hashtable_ebo_helper<0, _ExtractKey>,
                               :      private _Hashtable_ebo_helper<1, _H1>,
                               :      private _Hashtable_ebo_helper<2, _H2>
                               :    {
                               :    private:
                               :      using __ebo_extract_key = _Hashtable_ebo_helper<0, _ExtractKey>;
                               :      using __ebo_h1 = _Hashtable_ebo_helper<1, _H1>;
                               :      using __ebo_h2 = _Hashtable_ebo_helper<2, _H2>;
                               :
                               :    public:
                               :      typedef _H1 					hasher;
                               :
                               :      hasher
                               :      hash_function() const
                               :      { return _M_h1(); }
                               :
                               :    protected:
                               :      typedef std::size_t 				__hash_code;
                               :      typedef _Hash_node<_Value, false>			__node_type;
                               :
                               :      // We need the default constructor for the local iterators.
                               :      _Hash_code_base() = default;
                               :
                               :      _Hash_code_base(const _ExtractKey& __ex,
                               :		      const _H1& __h1, const _H2& __h2,
                               :		      const _Default_ranged_hash&)
                               :      : __ebo_extract_key(__ex), __ebo_h1(__h1), __ebo_h2(__h2) { }
                               :
                               :      __hash_code
                               :      _M_hash_code(const _Key& __k) const
                               :      { return _M_h1()(__k); }
                               :
                               :      std::size_t
                               :      _M_bucket_index(const _Key&, __hash_code __c, std::size_t __n) const
                               :      { return _M_h2()(__c, __n); }
                               :
                               :      std::size_t
                               :      _M_bucket_index(const __node_type* __p,
                               :		      std::size_t __n) const
    12  0.0102     0       0   :      { return _M_h2()(_M_h1()(_M_extract()(__p->_M_v)), __n); }
                               :
                               :      void
                               :      _M_store_code(__node_type*, __hash_code) const
                               :      { }
                               :
                               :      void
                               :      _M_copy_code(__node_type*, const __node_type*) const
                               :      { }
                               :
                               :      void
                               :      _M_swap(_Hash_code_base& __x)
                               :      {
                               :	std::swap(_M_extract(), __x._M_extract());
                               :	std::swap(_M_h1(), __x._M_h1());
                               :	std::swap(_M_h2(), __x._M_h2());
                               :      }
                               :
                               :      const _ExtractKey&
                               :      _M_extract() const { return __ebo_extract_key::_S_cget(*this); }
                               :
                               :      _ExtractKey&
                               :      _M_extract() { return __ebo_extract_key::_S_get(*this); }
                               :
                               :      const _H1&
                               :      _M_h1() const { return __ebo_h1::_S_cget(*this); }
                               :
                               :      _H1&
                               :      _M_h1() { return __ebo_h1::_S_get(*this); }
                               :
                               :      const _H2&
                               :      _M_h2() const { return __ebo_h2::_S_cget(*this); }
                               :
                               :      _H2&
                               :      _M_h2() { return __ebo_h2::_S_get(*this); }
                               :    };
                               :
                               :  /// Specialization: hash function and range-hashing function,
                               :  /// caching hash codes.  H is provided but ignored.  Provides
                               :  /// typedef and accessor required by C++ 11.
                               :  template<typename _Key, typename _Value, typename _ExtractKey,
                               :	   typename _H1, typename _H2>
                               :    struct _Hash_code_base<_Key, _Value, _ExtractKey, _H1, _H2,
                               :			   _Default_ranged_hash, true>
                               :    : private _Hashtable_ebo_helper<0, _ExtractKey>,
                               :      private _Hashtable_ebo_helper<1, _H1>,
                               :      private _Hashtable_ebo_helper<2, _H2>
                               :    {
                               :    private:
                               :      // Gives access to _M_h2() to the local iterator implementation.
                               :      friend struct _Local_iterator_base<_Key, _Value, _ExtractKey, _H1, _H2,
                               :					 _Default_ranged_hash, true>;
                               :
                               :      using __ebo_extract_key = _Hashtable_ebo_helper<0, _ExtractKey>;
                               :      using __ebo_h1 = _Hashtable_ebo_helper<1, _H1>;
                               :      using __ebo_h2 = _Hashtable_ebo_helper<2, _H2>;
                               :
                               :    public:
                               :      typedef _H1 					hasher;
                               :
                               :      hasher
                               :      hash_function() const
                               :      { return _M_h1(); }
                               :
                               :    protected:
                               :      typedef std::size_t 				__hash_code;
                               :      typedef _Hash_node<_Value, true>			__node_type;
                               :
                               :      _Hash_code_base(const _ExtractKey& __ex,
                               :		      const _H1& __h1, const _H2& __h2,
                               :		      const _Default_ranged_hash&)
                               :      : __ebo_extract_key(__ex), __ebo_h1(__h1), __ebo_h2(__h2) { }
                               :
                               :      __hash_code
                               :      _M_hash_code(const _Key& __k) const
                               :      { return _M_h1()(__k); }
                               :
                               :      std::size_t
                               :      _M_bucket_index(const _Key&, __hash_code __c,
                               :		      std::size_t __n) const
                               :      { return _M_h2()(__c, __n); }
                               :
                               :      std::size_t
                               :      _M_bucket_index(const __node_type* __p, std::size_t __n) const
                               :      { return _M_h2()(__p->_M_hash_code, __n); }
                               :
                               :      void
                               :      _M_store_code(__node_type* __n, __hash_code __c) const
                               :      { __n->_M_hash_code = __c; }
                               :
                               :      void
                               :      _M_copy_code(__node_type* __to, const __node_type* __from) const
                               :      { __to->_M_hash_code = __from->_M_hash_code; }
                               :
                               :      void
                               :      _M_swap(_Hash_code_base& __x)
                               :      {
                               :	std::swap(_M_extract(), __x._M_extract());
                               :	std::swap(_M_h1(), __x._M_h1());
                               :	std::swap(_M_h2(), __x._M_h2());
                               :      }
                               :
                               :      const _ExtractKey&
                               :      _M_extract() const { return __ebo_extract_key::_S_cget(*this); }
                               :
                               :      _ExtractKey&
                               :      _M_extract() { return __ebo_extract_key::_S_get(*this); }
                               :
                               :      const _H1&
                               :      _M_h1() const { return __ebo_h1::_S_cget(*this); }
                               :
                               :      _H1&
                               :      _M_h1() { return __ebo_h1::_S_get(*this); }
                               :
                               :      const _H2&
                               :      _M_h2() const { return __ebo_h2::_S_cget(*this); }
                               :
                               :      _H2&
                               :      _M_h2() { return __ebo_h2::_S_get(*this); }
                               :    };
                               :
                               :  /**
                               :   *  Primary class template _Equal_helper.
                               :   *
                               :   */
                               :  template <typename _Key, typename _Value, typename _ExtractKey,
                               :	    typename _Equal, typename _HashCodeType,
                               :	    bool __cache_hash_code>
                               :  struct _Equal_helper;
                               :
                               :  /// Specialization.
                               :  template<typename _Key, typename _Value, typename _ExtractKey,
                               :	   typename _Equal, typename _HashCodeType>
                               :  struct _Equal_helper<_Key, _Value, _ExtractKey, _Equal, _HashCodeType, true>
                               :  {
                               :    static bool
                               :    _S_equals(const _Equal& __eq, const _ExtractKey& __extract,
                               :	      const _Key& __k, _HashCodeType __c, _Hash_node<_Value, true>* __n)
     9  0.0077     0       0   :    { return __c == __n->_M_hash_code && __eq(__k, __extract(__n->_M_v)); }
                               :  };
                               :
                               :  /// Specialization.
                               :  template<typename _Key, typename _Value, typename _ExtractKey,
                               :	   typename _Equal, typename _HashCodeType>
                               :  struct _Equal_helper<_Key, _Value, _ExtractKey, _Equal, _HashCodeType, false>
                               :  {
                               :    static bool
                               :    _S_equals(const _Equal& __eq, const _ExtractKey& __extract,
                               :	      const _Key& __k, _HashCodeType, _Hash_node<_Value, false>* __n)
                               :    { return __eq(__k, __extract(__n->_M_v)); }
                               :  };
                               :
                               :
                               :  /// Specialization.
                               :  template<typename _Key, typename _Value, typename _ExtractKey,
                               :	   typename _H1, typename _H2, typename _Hash>
                               :    struct _Local_iterator_base<_Key, _Value, _ExtractKey,
                               :				_H1, _H2, _Hash, true>
                               :    : private _Hashtable_ebo_helper<0, _H2>
                               :    {
                               :    protected:
                               :      using __base_type = _Hashtable_ebo_helper<0, _H2>;
                               :      using __hash_code_base = _Hash_code_base<_Key, _Value, _ExtractKey,
                               :					       _H1, _H2, _Hash, true>;
                               :
                               :    public:
                               :      _Local_iterator_base() = default;
                               :      _Local_iterator_base(const __hash_code_base& __base,
                               :			   _Hash_node<_Value, true>* __p,
                               :			   std::size_t __bkt, std::size_t __bkt_count)
                               :      : __base_type(__base._M_h2()),
                               :	_M_cur(__p), _M_bucket(__bkt), _M_bucket_count(__bkt_count) { }
                               :
                               :      void
                               :      _M_incr()
                               :      {
                               :	_M_cur = _M_cur->_M_next();
                               :	if (_M_cur)
                               :	  {
                               :	    std::size_t __bkt
                               :	      = __base_type::_S_get(*this)(_M_cur->_M_hash_code,
                               :					   _M_bucket_count);
                               :	    if (__bkt != _M_bucket)
                               :	      _M_cur = nullptr;
                               :	  }
                               :      }
                               :
                               :      _Hash_node<_Value, true>*  _M_cur;
                               :      std::size_t _M_bucket;
                               :      std::size_t _M_bucket_count;
                               :    };
                               :
                               :  /// Specialization.
                               :  template<typename _Key, typename _Value, typename _ExtractKey,
                               :	   typename _H1, typename _H2, typename _Hash>
                               :    struct _Local_iterator_base<_Key, _Value, _ExtractKey,
                               :				_H1, _H2, _Hash, false>
                               :    : private _Hash_code_base<_Key, _Value, _ExtractKey,
                               :			      _H1, _H2, _Hash, false>
                               :    {
                               :    protected:
                               :      using __hash_code_base = _Hash_code_base<_Key, _Value, _ExtractKey,
                               :					       _H1, _H2, _Hash, false>;
                               :
                               :    public:
                               :      _Local_iterator_base() = default;
                               :      _Local_iterator_base(const __hash_code_base& __base,
                               :			   _Hash_node<_Value, false>* __p,
                               :			   std::size_t __bkt, std::size_t __bkt_count)
                               :	: __hash_code_base(__base),
                               :	  _M_cur(__p), _M_bucket(__bkt), _M_bucket_count(__bkt_count) { }
                               :
                               :      void
                               :      _M_incr()
                               :      {
                               :	_M_cur = _M_cur->_M_next();
                               :	if (_M_cur)
                               :	  {
                               :	    std::size_t __bkt = this->_M_bucket_index(_M_cur, _M_bucket_count);
                               :	    if (__bkt != _M_bucket)
                               :	      _M_cur = nullptr;
                               :	  }
                               :      }
                               :
                               :      _Hash_node<_Value, false>*  _M_cur;
                               :      std::size_t _M_bucket;
                               :      std::size_t _M_bucket_count;
                               :    };
                               :
                               :  template<typename _Key, typename _Value, typename _ExtractKey,
                               :	   typename _H1, typename _H2, typename _Hash, bool __cache>
                               :    inline bool
                               :    operator==(const _Local_iterator_base<_Key, _Value, _ExtractKey,
                               :					  _H1, _H2, _Hash, __cache>& __x,
                               :	       const _Local_iterator_base<_Key, _Value, _ExtractKey,
                               :					  _H1, _H2, _Hash, __cache>& __y)
                               :    { return __x._M_cur == __y._M_cur; }
                               :
                               :  template<typename _Key, typename _Value, typename _ExtractKey,
                               :	   typename _H1, typename _H2, typename _Hash, bool __cache>
                               :    inline bool
                               :    operator!=(const _Local_iterator_base<_Key, _Value, _ExtractKey,
                               :					  _H1, _H2, _Hash, __cache>& __x,
                               :	       const _Local_iterator_base<_Key, _Value, _ExtractKey,
                               :					  _H1, _H2, _Hash, __cache>& __y)
                               :    { return __x._M_cur != __y._M_cur; }
                               :
                               :  /// local iterators
                               :  template<typename _Key, typename _Value, typename _ExtractKey,
                               :	   typename _H1, typename _H2, typename _Hash,
                               :	   bool __constant_iterators, bool __cache>
                               :    struct _Local_iterator
                               :    : public _Local_iterator_base<_Key, _Value, _ExtractKey,
                               :				  _H1, _H2, _Hash, __cache>
                               :    {
                               :    private:
                               :      using __base_type = _Local_iterator_base<_Key, _Value, _ExtractKey,
                               :					       _H1, _H2, _Hash, __cache>;
                               :      using __hash_code_base = typename __base_type::__hash_code_base;
                               :    public:
                               :      typedef _Value                                   value_type;
                               :      typedef typename std::conditional<__constant_iterators,
                               :					const _Value*, _Value*>::type
                               :						       pointer;
                               :      typedef typename std::conditional<__constant_iterators,
                               :					const _Value&, _Value&>::type
                               :						       reference;
                               :      typedef std::ptrdiff_t                           difference_type;
                               :      typedef std::forward_iterator_tag                iterator_category;
                               :
                               :      _Local_iterator() = default;
                               :
                               :      _Local_iterator(const __hash_code_base& __base,
                               :		      _Hash_node<_Value, __cache>* __p,
                               :		      std::size_t __bkt, std::size_t __bkt_count)
                               :	: __base_type(__base, __p, __bkt, __bkt_count)
                               :      { }
                               :
                               :      reference
                               :      operator*() const
                               :      { return this->_M_cur->_M_v; }
                               :
                               :      pointer
                               :      operator->() const
                               :      { return std::__addressof(this->_M_cur->_M_v); }
                               :
                               :      _Local_iterator&
                               :      operator++()
                               :      {
                               :	this->_M_incr();
                               :	return *this;
                               :      }
                               :
                               :      _Local_iterator
                               :      operator++(int)
                               :      {
                               :	_Local_iterator __tmp(*this);
                               :	this->_M_incr();
                               :	return __tmp;
                               :      }
                               :    };
                               :
                               :  /// local const_iterators
                               :  template<typename _Key, typename _Value, typename _ExtractKey,
                               :	   typename _H1, typename _H2, typename _Hash,
                               :	   bool __constant_iterators, bool __cache>
                               :    struct _Local_const_iterator
                               :    : public _Local_iterator_base<_Key, _Value, _ExtractKey,
                               :				  _H1, _H2, _Hash, __cache>
                               :    {
                               :    private:
                               :      using __base_type = _Local_iterator_base<_Key, _Value, _ExtractKey,
                               :					       _H1, _H2, _Hash, __cache>;
                               :      using __hash_code_base = typename __base_type::__hash_code_base;
                               :
                               :    public:
                               :      typedef _Value                                   value_type;
                               :      typedef const _Value*                            pointer;
                               :      typedef const _Value&                            reference;
                               :      typedef std::ptrdiff_t                           difference_type;
                               :      typedef std::forward_iterator_tag                iterator_category;
                               :
                               :      _Local_const_iterator() = default;
                               :
                               :      _Local_const_iterator(const __hash_code_base& __base,
                               :			    _Hash_node<_Value, __cache>* __p,
                               :			    std::size_t __bkt, std::size_t __bkt_count)
                               :	: __base_type(__base, __p, __bkt, __bkt_count)
                               :      { }
                               :
                               :      _Local_const_iterator(const _Local_iterator<_Key, _Value, _ExtractKey,
                               :						  _H1, _H2, _Hash,
                               :						  __constant_iterators,
                               :						  __cache>& __x)
                               :	: __base_type(__x)
                               :      { }
                               :
                               :      reference
                               :      operator*() const
                               :      { return this->_M_cur->_M_v; }
                               :
                               :      pointer
                               :      operator->() const
                               :      { return std::__addressof(this->_M_cur->_M_v); }
                               :
                               :      _Local_const_iterator&
                               :      operator++()
                               :      {
                               :	this->_M_incr();
                               :	return *this;
                               :      }
                               :
                               :      _Local_const_iterator
                               :      operator++(int)
                               :      {
                               :	_Local_const_iterator __tmp(*this);
                               :	this->_M_incr();
                               :	return __tmp;
                               :      }
                               :    };
                               :
                               :  /**
                               :   *  Primary class template _Hashtable_base.
                               :   *
                               :   *  Helper class adding management of _Equal functor to
                               :   *  _Hash_code_base type.
                               :   *
                               :   *  Base class templates are:
                               :   *    - __detail::_Hash_code_base
                               :   *    - __detail::_Hashtable_ebo_helper
                               :   */
                               :  template<typename _Key, typename _Value,
                               :	   typename _ExtractKey, typename _Equal,
                               :	   typename _H1, typename _H2, typename _Hash, typename _Traits>
                               :  struct _Hashtable_base
                               :  : public _Hash_code_base<_Key, _Value, _ExtractKey, _H1, _H2, _Hash,
                               :			   _Traits::__hash_cached::value>,
                               :    private _Hashtable_ebo_helper<0, _Equal>
                               :  {
                               :  public:
                               :    typedef _Key                                    key_type;
                               :    typedef _Value                                  value_type;
                               :    typedef _Equal                                  key_equal;
                               :    typedef std::size_t                             size_type;
                               :    typedef std::ptrdiff_t                          difference_type;
                               :
                               :    using __traits_type = _Traits;
                               :    using __hash_cached = typename __traits_type::__hash_cached;
                               :    using __constant_iterators = typename __traits_type::__constant_iterators;
                               :    using __unique_keys = typename __traits_type::__unique_keys;
                               :
                               :    using __hash_code_base = _Hash_code_base<_Key, _Value, _ExtractKey,
                               :					     _H1, _H2, _Hash,
                               :					     __hash_cached::value>;
                               :
                               :    using __hash_code = typename __hash_code_base::__hash_code;
                               :    using __node_type = typename __hash_code_base::__node_type;
                               :
                               :    using iterator = __detail::_Node_iterator<value_type,
                               :					      __constant_iterators::value,
                               :					      __hash_cached::value>;
                               :
                               :    using const_iterator = __detail::_Node_const_iterator<value_type,
                               :						   __constant_iterators::value,
                               :						   __hash_cached::value>;
                               :
                               :    using local_iterator = __detail::_Local_iterator<key_type, value_type,
                               :						  _ExtractKey, _H1, _H2, _Hash,
                               :						  __constant_iterators::value,
                               :						     __hash_cached::value>;
                               :
                               :    using const_local_iterator = __detail::_Local_const_iterator<key_type,
                               :								 value_type,
                               :					_ExtractKey, _H1, _H2, _Hash,
                               :					__constant_iterators::value,
                               :					__hash_cached::value>;
                               :
                               :    using __ireturn_type = typename std::conditional<__unique_keys::value,
                               :						     std::pair<iterator, bool>,
                               :						     iterator>::type;
                               :
                               :    using __iconv_type = typename  std::conditional<__unique_keys::value,
                               :						    _Select1st, _Identity
                               :						    >::type;
                               :  private:
                               :    using _EqualEBO = _Hashtable_ebo_helper<0, _Equal>;
                               :    using _EqualHelper =  _Equal_helper<_Key, _Value, _ExtractKey, _Equal,
                               :					__hash_code, __hash_cached::value>;
                               :
                               :  protected:
                               :    using __node_base = __detail::_Hash_node_base;
                               :    using __bucket_type = __node_base*;
                               :
                               :    _Hashtable_base(const _ExtractKey& __ex, const _H1& __h1, const _H2& __h2,
                               :		    const _Hash& __hash, const _Equal& __eq)
                               :    : __hash_code_base(__ex, __h1, __h2, __hash), _EqualEBO(__eq)
                               :    { }
                               :
                               :    bool
                               :    _M_equals(const _Key& __k, __hash_code __c, __node_type* __n) const
                               :    {
                               :      return _EqualHelper::_S_equals(_M_eq(), this->_M_extract(),
                               :				     __k, __c, __n);
                               :    }
                               :
                               :    void
                               :    _M_swap(_Hashtable_base& __x)
                               :    {
                               :      __hash_code_base::_M_swap(__x);
                               :      std::swap(_M_eq(), __x._M_eq());
                               :    }
                               :
                               :    const _Equal&
                               :    _M_eq() const { return _EqualEBO::_S_cget(*this); }
                               :
                               :    _Equal&
                               :    _M_eq() { return _EqualEBO::_S_get(*this); }
                               :  };
                               :
                               :  /**
                               :   *  struct _Equality_base.
                               :   *
                               :   *  Common types and functions for class _Equality.
                               :   */
                               :  struct _Equality_base
                               :  {
                               :  protected:
                               :    template<typename _Uiterator>
                               :      static bool
                               :      _S_is_permutation(_Uiterator, _Uiterator, _Uiterator);
                               :  };
                               :
                               :  // See std::is_permutation in N3068.
                               :  template<typename _Uiterator>
                               :    bool
                               :    _Equality_base::
                               :    _S_is_permutation(_Uiterator __first1, _Uiterator __last1,
                               :		      _Uiterator __first2)
                               :    {
                               :      for (; __first1 != __last1; ++__first1, ++__first2)
                               :	if (!(*__first1 == *__first2))
                               :	  break;
                               :
                               :      if (__first1 == __last1)
                               :	return true;
                               :
                               :      _Uiterator __last2 = __first2;
                               :      std::advance(__last2, std::distance(__first1, __last1));
                               :
                               :      for (_Uiterator __it1 = __first1; __it1 != __last1; ++__it1)
                               :	{
                               :	  _Uiterator __tmp =  __first1;
                               :	  while (__tmp != __it1 && !bool(*__tmp == *__it1))
                               :	    ++__tmp;
                               :
                               :	  // We've seen this one before.
                               :	  if (__tmp != __it1)
                               :	    continue;
                               :
                               :	  std::ptrdiff_t __n2 = 0;
                               :	  for (__tmp = __first2; __tmp != __last2; ++__tmp)
                               :	    if (*__tmp == *__it1)
                               :	      ++__n2;
                               :
                               :	  if (!__n2)
                               :	    return false;
                               :
                               :	  std::ptrdiff_t __n1 = 0;
                               :	  for (__tmp = __it1; __tmp != __last1; ++__tmp)
                               :	    if (*__tmp == *__it1)
                               :	      ++__n1;
                               :
                               :	  if (__n1 != __n2)
                               :	    return false;
                               :	}
                               :      return true;
                               :    }
                               :
                               :  /**
                               :   *  Primary class template  _Equality.
                               :   *
                               :   *  This is for implementing equality comparison for unordered
                               :   *  containers, per N3068, by John Lakos and Pablo Halpern.
                               :   *  Algorithmically, we follow closely the reference implementations
                               :   *  therein.
                               :   */
                               :  template<typename _Key, typename _Value, typename _Alloc,
                               :	   typename _ExtractKey, typename _Equal,
                               :	   typename _H1, typename _H2, typename _Hash,
                               :	   typename _RehashPolicy, typename _Traits,
                               :	   bool _Unique_keys = _Traits::__unique_keys::value>
                               :    struct _Equality;
                               :
                               :  /// Specialization.
                               :  template<typename _Key, typename _Value, typename _Alloc,
                               :	   typename _ExtractKey, typename _Equal,
                               :	   typename _H1, typename _H2, typename _Hash,
                               :	   typename _RehashPolicy, typename _Traits>
                               :    struct _Equality<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                               :		     _H1, _H2, _Hash, _RehashPolicy, _Traits, true>
                               :    {
                               :      using __hashtable = _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                               :				     _H1, _H2, _Hash, _RehashPolicy, _Traits>;
                               :
                               :      bool
                               :      _M_equal(const __hashtable&) const;
                               :    };
                               :
                               :  template<typename _Key, typename _Value, typename _Alloc,
                               :	   typename _ExtractKey, typename _Equal,
                               :	   typename _H1, typename _H2, typename _Hash,
                               :	   typename _RehashPolicy, typename _Traits>
                               :    bool
                               :    _Equality<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                               :	      _H1, _H2, _Hash, _RehashPolicy, _Traits, true>::
                               :    _M_equal(const __hashtable& __other) const
                               :    {
                               :      const __hashtable* __this = static_cast<const __hashtable*>(this);
                               :
                               :      if (__this->size() != __other.size())
                               :	return false;
                               :
                               :      for (auto __itx = __this->begin(); __itx != __this->end(); ++__itx)
                               :	{
                               :	  const auto __ity = __other.find(_ExtractKey()(*__itx));
                               :	  if (__ity == __other.end() || !bool(*__ity == *__itx))
                               :	    return false;
                               :	}
                               :      return true;
                               :    }
                               :
                               :  /// Specialization.
                               :  template<typename _Key, typename _Value, typename _Alloc,
                               :	   typename _ExtractKey, typename _Equal,
                               :	   typename _H1, typename _H2, typename _Hash,
                               :	   typename _RehashPolicy, typename _Traits>
                               :    struct _Equality<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                               :		     _H1, _H2, _Hash, _RehashPolicy, _Traits, false>
                               :    : public _Equality_base
                               :    {
                               :      using __hashtable = _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                               :				     _H1, _H2, _Hash, _RehashPolicy, _Traits>;
                               :
                               :      bool
                               :      _M_equal(const __hashtable&) const;
                               :    };
                               :
                               :  template<typename _Key, typename _Value, typename _Alloc,
                               :	   typename _ExtractKey, typename _Equal,
                               :	   typename _H1, typename _H2, typename _Hash,
                               :	   typename _RehashPolicy, typename _Traits>
                               :    bool
                               :    _Equality<_Key, _Value, _Alloc, _ExtractKey, _Equal,
                               :	      _H1, _H2, _Hash, _RehashPolicy, _Traits, false>::
                               :    _M_equal(const __hashtable& __other) const
                               :    {
                               :      const __hashtable* __this = static_cast<const __hashtable*>(this);
                               :
                               :      if (__this->size() != __other.size())
                               :	return false;
                               :
                               :      for (auto __itx = __this->begin(); __itx != __this->end();)
                               :	{
                               :	  const auto __xrange = __this->equal_range(_ExtractKey()(*__itx));
                               :	  const auto __yrange = __other.equal_range(_ExtractKey()(*__itx));
                               :
                               :	  if (std::distance(__xrange.first, __xrange.second)
                               :	      != std::distance(__yrange.first, __yrange.second))
                               :	    return false;
                               :
                               :	  if (!_S_is_permutation(__xrange.first, __xrange.second,
                               :				 __yrange.first))
                               :	    return false;
                               :
                               :	  __itx = __xrange.second;
                               :	}
                               :      return true;
                               :    }
                               :
                               :  /**
                               :   * This type is to combine a _Hash_node_base instance with an allocator
                               :   * instance through inheritance to benefit from EBO when possible.
                               :   */
                               :  template<typename _NodeAlloc>
                               :    struct _Before_begin : public _NodeAlloc
                               :    {
                               :      _Hash_node_base _M_node;
                               :
                               :      _Before_begin(const _Before_begin&) = default;
                               :      _Before_begin(_Before_begin&&) = default;
                               :
                               :      template<typename _Alloc>
                               :	_Before_begin(_Alloc&& __a)
                               :	  : _NodeAlloc(std::forward<_Alloc>(__a))
                               :	{ }
                               :    };
                               :
                               : //@} hashtable-detail
                               :_GLIBCXX_END_NAMESPACE_VERSION
                               :} // namespace __detail
                               :} // namespace std
                               :
                               :#endif // _HASHTABLE_POLICY_H
/* 
 * Total samples for file : "/usr/include/c++/4.8/bits/stl_pair.h"
 * 
 *   2357  2.0053     1  0.0591
 */


                               :// Pair implementation -*- C++ -*-
                               :
                               :// Copyright (C) 2001-2013 Free Software Foundation, Inc.
                               ://
                               :// This file is part of the GNU ISO C++ Library.  This library is free
                               :// software; you can redistribute it and/or modify it under the
                               :// terms of the GNU General Public License as published by the
                               :// Free Software Foundation; either version 3, or (at your option)
                               :// any later version.
                               :
                               :// This library is distributed in the hope that it will be useful,
                               :// but WITHOUT ANY WARRANTY; without even the implied warranty of
                               :// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                               :// GNU General Public License for more details.
                               :
                               :// Under Section 7 of GPL version 3, you are granted additional
                               :// permissions described in the GCC Runtime Library Exception, version
                               :// 3.1, as published by the Free Software Foundation.
                               :
                               :// You should have received a copy of the GNU General Public License and
                               :// a copy of the GCC Runtime Library Exception along with this program;
                               :// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                               :// <http://www.gnu.org/licenses/>.
                               :
                               :/*
                               : *
                               : * Copyright (c) 1994
                               : * Hewlett-Packard Company
                               : *
                               : * Permission to use, copy, modify, distribute and sell this software
                               : * and its documentation for any purpose is hereby granted without fee,
                               : * provided that the above copyright notice appear in all copies and
                               : * that both that copyright notice and this permission notice appear
                               : * in supporting documentation.  Hewlett-Packard Company makes no
                               : * representations about the suitability of this software for any
                               : * purpose.  It is provided "as is" without express or implied warranty.
                               : *
                               : *
                               : * Copyright (c) 1996,1997
                               : * Silicon Graphics Computer Systems, Inc.
                               : *
                               : * Permission to use, copy, modify, distribute and sell this software
                               : * and its documentation for any purpose is hereby granted without fee,
                               : * provided that the above copyright notice appear in all copies and
                               : * that both that copyright notice and this permission notice appear
                               : * in supporting documentation.  Silicon Graphics makes no
                               : * representations about the suitability of this software for any
                               : * purpose.  It is provided "as is" without express or implied warranty.
                               : */
                               :
                               :/** @file bits/stl_pair.h
                               : *  This is an internal header file, included by other library headers.
                               : *  Do not attempt to use it directly. @headername{utility}
                               : */
                               :
                               :#ifndef _STL_PAIR_H
                               :#define _STL_PAIR_H 1
                               :
                               :#include <bits/move.h> // for std::move / std::forward, and std::swap
                               :
                               :#if __cplusplus >= 201103L
                               :#include <type_traits> // for std::__decay_and_strip too
                               :#endif
                               :
                               :namespace std _GLIBCXX_VISIBILITY(default)
                               :{
                               :_GLIBCXX_BEGIN_NAMESPACE_VERSION
                               :
                               :  /**
                               :   *  @addtogroup utilities
                               :   *  @{
                               :   */
                               :
                               :#if __cplusplus >= 201103L
                               :  /// piecewise_construct_t
                               :  struct piecewise_construct_t { };
                               :
                               :  /// piecewise_construct
                               :  constexpr piecewise_construct_t piecewise_construct = piecewise_construct_t();
                               :
                               :  // Forward declarations.
                               :  template<typename...>
                               :    class tuple;
                               :
                               :  template<std::size_t...>
                               :    struct _Index_tuple;
                               :#endif
                               :
                               : /**
                               :   *  @brief Struct holding two objects of arbitrary type.
                               :   *
                               :   *  @tparam _T1  Type of first object.
                               :   *  @tparam _T2  Type of second object.
                               :   */
                               :  template<class _T1, class _T2>
                               :    struct pair
                               :    {
                               :      typedef _T1 first_type;    /// @c first_type is the first bound type
                               :      typedef _T2 second_type;   /// @c second_type is the second bound type
                               :
                               :      _T1 first;                 /// @c first is a copy of the first object
                               :      _T2 second;                /// @c second is a copy of the second object
                               :
                               :      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                               :      // 265.  std::pair::pair() effects overly restrictive
                               :      /** The default constructor creates @c first and @c second using their
                               :       *  respective default constructors.  */
                               :      _GLIBCXX_CONSTEXPR pair()
                               :      : first(), second() { }
                               :
                               :      /** Two objects may be passed to a @c pair constructor to be copied.  */
                               :      _GLIBCXX_CONSTEXPR pair(const _T1& __a, const _T2& __b)
                               :      : first(__a), second(__b) { }
                               :
                               :      /** There is also a templated copy ctor for the @c pair class itself.  */
                               :#if __cplusplus < 201103L
                               :      template<class _U1, class _U2>
                               :	pair(const pair<_U1, _U2>& __p)
                               :	: first(__p.first), second(__p.second) { }
                               :#else
                               :      template<class _U1, class _U2, class = typename
                               :	       enable_if<__and_<is_convertible<const _U1&, _T1>,
                               :				is_convertible<const _U2&, _T2>>::value>::type>
                               :	constexpr pair(const pair<_U1, _U2>& __p)
                               :	: first(__p.first), second(__p.second) { }
                               :
                               :      constexpr pair(const pair&) = default;
                               :      constexpr pair(pair&&) = default;
                               :
                               :      // DR 811.
                               :      template<class _U1, class = typename
                               :	       enable_if<is_convertible<_U1, _T1>::value>::type>
                               :	constexpr pair(_U1&& __x, const _T2& __y)
    21  0.0179     1  0.0591   :	: first(std::forward<_U1>(__x)), second(__y) { }
                               :
                               :      template<class _U2, class = typename
                               :	       enable_if<is_convertible<_U2, _T2>::value>::type>
                               :	constexpr pair(const _T1& __x, _U2&& __y)
                               :	: first(__x), second(std::forward<_U2>(__y)) { }
                               :
                               :      template<class _U1, class _U2, class = typename
                               :	       enable_if<__and_<is_convertible<_U1, _T1>,
                               :				is_convertible<_U2, _T2>>::value>::type>
                               :	constexpr pair(_U1&& __x, _U2&& __y)
    26  0.0221     0       0   :	: first(std::forward<_U1>(__x)), second(std::forward<_U2>(__y)) { }
                               :
                               :      template<class _U1, class _U2, class = typename
                               :	       enable_if<__and_<is_convertible<_U1, _T1>,
                               :				is_convertible<_U2, _T2>>::value>::type>
                               :	constexpr pair(pair<_U1, _U2>&& __p)
                               :	: first(std::forward<_U1>(__p.first)),
                               :	  second(std::forward<_U2>(__p.second)) { }
                               :
                               :      template<typename... _Args1, typename... _Args2>
                               :        pair(piecewise_construct_t, tuple<_Args1...>, tuple<_Args2...>);
                               :
                               :      pair&
                               :      operator=(const pair& __p)
                               :      {
                               :	first = __p.first;
                               :	second = __p.second;
                               :	return *this;
                               :      }
                               :
                               :      pair&
                               :      operator=(pair&& __p)
                               :      noexcept(__and_<is_nothrow_move_assignable<_T1>,
                               :	              is_nothrow_move_assignable<_T2>>::value)
                               :      {
  1739  1.4795     0       0   :	first = std::forward<first_type>(__p.first);
   529  0.4501     0       0   :	second = std::forward<second_type>(__p.second);
                               :	return *this;
                               :      }
                               :
                               :      template<class _U1, class _U2>
                               :	pair&
                               :	operator=(const pair<_U1, _U2>& __p)
                               :	{
                               :	  first = __p.first;
                               :	  second = __p.second;
                               :	  return *this;
                               :	}
                               :
                               :      template<class _U1, class _U2>
                               :	pair&
                               :	operator=(pair<_U1, _U2>&& __p)
                               :	{
                               :	  first = std::forward<_U1>(__p.first);
                               :	  second = std::forward<_U2>(__p.second);
                               :	  return *this;
                               :	}
                               :
                               :      void
                               :      swap(pair& __p)
                               :      noexcept(noexcept(swap(first, __p.first))
                               :	       && noexcept(swap(second, __p.second)))
                               :      {
                               :	using std::swap;
                               :	swap(first, __p.first);
                               :	swap(second, __p.second);
                               :      }
                               :
                               :    private:
                               :      template<typename... _Args1, std::size_t... _Indexes1,
                               :               typename... _Args2, std::size_t... _Indexes2>
                               :        pair(tuple<_Args1...>&, tuple<_Args2...>&,
                               :             _Index_tuple<_Indexes1...>, _Index_tuple<_Indexes2...>);
                               :#endif
                               :    };
                               :
                               :  /// Two pairs of the same type are equal iff their members are equal.
                               :  template<class _T1, class _T2>
                               :    inline _GLIBCXX_CONSTEXPR bool
                               :    operator==(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    42  0.0357     0       0   :    { return __x.first == __y.first && __x.second == __y.second; }
                               :
                               :  /// <http://gcc.gnu.org/onlinedocs/libstdc++/manual/utilities.html>
                               :  template<class _T1, class _T2>
                               :    inline _GLIBCXX_CONSTEXPR bool
                               :    operator<(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
                               :    { return __x.first < __y.first
                               :	     || (!(__y.first < __x.first) && __x.second < __y.second); }
                               :
                               :  /// Uses @c operator== to find the result.
                               :  template<class _T1, class _T2>
                               :    inline _GLIBCXX_CONSTEXPR bool
                               :    operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
                               :    { return !(__x == __y); }
                               :
                               :  /// Uses @c operator< to find the result.
                               :  template<class _T1, class _T2>
                               :    inline _GLIBCXX_CONSTEXPR bool
                               :    operator>(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
                               :    { return __y < __x; }
                               :
                               :  /// Uses @c operator< to find the result.
                               :  template<class _T1, class _T2>
                               :    inline _GLIBCXX_CONSTEXPR bool
                               :    operator<=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
                               :    { return !(__y < __x); }
                               :
                               :  /// Uses @c operator< to find the result.
                               :  template<class _T1, class _T2>
                               :    inline _GLIBCXX_CONSTEXPR bool
                               :    operator>=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
                               :    { return !(__x < __y); }
                               :
                               :#if __cplusplus >= 201103L
                               :  /// See std::pair::swap().
                               :  // Note:  no std::swap overloads in C++03 mode, this has performance
                               :  //        implications, see, eg, libstdc++/38466.
                               :  template<class _T1, class _T2>
                               :    inline void
                               :    swap(pair<_T1, _T2>& __x, pair<_T1, _T2>& __y)
                               :    noexcept(noexcept(__x.swap(__y)))
                               :    { __x.swap(__y); }
                               :#endif
                               :
                               :  /**
                               :   *  @brief A convenience wrapper for creating a pair from two objects.
                               :   *  @param  __x  The first object.
                               :   *  @param  __y  The second object.
                               :   *  @return   A newly-constructed pair<> object of the appropriate type.
                               :   *
                               :   *  The standard requires that the objects be passed by reference-to-const,
                               :   *  but LWG issue #181 says they should be passed by const value.  We follow
                               :   *  the LWG by default.
                               :   */
                               :  // _GLIBCXX_RESOLVE_LIB_DEFECTS
                               :  // 181.  make_pair() unintended behavior
                               :#if __cplusplus >= 201103L
                               :  // NB: DR 706.
                               :  template<class _T1, class _T2>
                               :    constexpr pair<typename __decay_and_strip<_T1>::__type,
                               :                   typename __decay_and_strip<_T2>::__type>
                               :    make_pair(_T1&& __x, _T2&& __y)
                               :    {
                               :      typedef typename __decay_and_strip<_T1>::__type __ds_type1;
                               :      typedef typename __decay_and_strip<_T2>::__type __ds_type2;
                               :      typedef pair<__ds_type1, __ds_type2> 	      __pair_type;
                               :      return __pair_type(std::forward<_T1>(__x), std::forward<_T2>(__y));
                               :    }
                               :#else
                               :  template<class _T1, class _T2>
                               :    inline pair<_T1, _T2>
                               :    make_pair(_T1 __x, _T2 __y)
                               :    { return pair<_T1, _T2>(__x, __y); }
                               :#endif
                               :
                               :  /// @}
                               :
                               :_GLIBCXX_END_NAMESPACE_VERSION
                               :} // namespace std
                               :
                               :#endif /* _STL_PAIR_H */
/* 
 * Total samples for file : "/usr/include/c++/4.8/bits/stl_construct.h"
 * 
 *   1043  0.8874     1  0.0591
 */


                               :// nonstandard construct and destroy functions -*- C++ -*-
                               :
                               :// Copyright (C) 2001-2013 Free Software Foundation, Inc.
                               ://
                               :// This file is part of the GNU ISO C++ Library.  This library is free
                               :// software; you can redistribute it and/or modify it under the
                               :// terms of the GNU General Public License as published by the
                               :// Free Software Foundation; either version 3, or (at your option)
                               :// any later version.
                               :
                               :// This library is distributed in the hope that it will be useful,
                               :// but WITHOUT ANY WARRANTY; without even the implied warranty of
                               :// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                               :// GNU General Public License for more details.
                               :
                               :// Under Section 7 of GPL version 3, you are granted additional
                               :// permissions described in the GCC Runtime Library Exception, version
                               :// 3.1, as published by the Free Software Foundation.
                               :
                               :// You should have received a copy of the GNU General Public License and
                               :// a copy of the GCC Runtime Library Exception along with this program;
                               :// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                               :// <http://www.gnu.org/licenses/>.
                               :
                               :/*
                               : *
                               : * Copyright (c) 1994
                               : * Hewlett-Packard Company
                               : *
                               : * Permission to use, copy, modify, distribute and sell this software
                               : * and its documentation for any purpose is hereby granted without fee,
                               : * provided that the above copyright notice appear in all copies and
                               : * that both that copyright notice and this permission notice appear
                               : * in supporting documentation.  Hewlett-Packard Company makes no
                               : * representations about the suitability of this software for any
                               : * purpose.  It is provided "as is" without express or implied warranty.
                               : *
                               : *
                               : * Copyright (c) 1996,1997
                               : * Silicon Graphics Computer Systems, Inc.
                               : *
                               : * Permission to use, copy, modify, distribute and sell this software
                               : * and its documentation for any purpose is hereby granted without fee,
                               : * provided that the above copyright notice appear in all copies and
                               : * that both that copyright notice and this permission notice appear
                               : * in supporting documentation.  Silicon Graphics makes no
                               : * representations about the suitability of this software for any
                               : * purpose.  It is provided "as is" without express or implied warranty.
                               : */
                               :
                               :/** @file bits/stl_construct.h
                               : *  This is an internal header file, included by other library headers.
                               : *  Do not attempt to use it directly. @headername{memory}
                               : */
                               :
                               :#ifndef _STL_CONSTRUCT_H
                               :#define _STL_CONSTRUCT_H 1
                               :
                               :#include <new>
                               :#include <bits/move.h>
                               :#include <ext/alloc_traits.h>
                               :
                               :namespace std _GLIBCXX_VISIBILITY(default)
                               :{
                               :_GLIBCXX_BEGIN_NAMESPACE_VERSION
                               :
                               :  /**
                               :   * Constructs an object in existing memory by invoking an allocated
                               :   * object's constructor with an initializer.
                               :   */
                               :#if __cplusplus >= 201103L
                               :  template<typename _T1, typename... _Args>
                               :    inline void
                               :    _Construct(_T1* __p, _Args&&... __args)
  1036  0.8814     1  0.0591   :    { ::new(static_cast<void*>(__p)) _T1(std::forward<_Args>(__args)...); }
                               :#else
                               :  template<typename _T1, typename _T2>
                               :    inline void
                               :    _Construct(_T1* __p, const _T2& __value)
                               :    {
                               :      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                               :      // 402. wrong new expression in [some_]allocator::construct
                               :      ::new(static_cast<void*>(__p)) _T1(__value);
                               :    }
                               :#endif
                               :
                               :  /**
                               :   * Destroy the object pointed to by a pointer type.
                               :   */
                               :  template<typename _Tp>
                               :    inline void
                               :    _Destroy(_Tp* __pointer)
                               :    { __pointer->~_Tp(); }
                               :
                               :  template<bool>
                               :    struct _Destroy_aux
                               :    {
                               :      template<typename _ForwardIterator>
                               :        static void
                               :        __destroy(_ForwardIterator __first, _ForwardIterator __last)
                               :	{
     7  0.0060     0       0   :	  for (; __first != __last; ++__first)
                               :	    std::_Destroy(std::__addressof(*__first));
                               :	}
                               :    };
                               :
                               :  template<>
                               :    struct _Destroy_aux<true>
                               :    {
                               :      template<typename _ForwardIterator>
                               :        static void
                               :        __destroy(_ForwardIterator, _ForwardIterator) { }
                               :    };
                               :
                               :  /**
                               :   * Destroy a range of objects.  If the value_type of the object has
                               :   * a trivial destructor, the compiler should optimize all of this
                               :   * away, otherwise the objects' destructors must be invoked.
                               :   */
                               :  template<typename _ForwardIterator>
                               :    inline void
                               :    _Destroy(_ForwardIterator __first, _ForwardIterator __last)
                               :    {
                               :      typedef typename iterator_traits<_ForwardIterator>::value_type
                               :                       _Value_type;
                               :      std::_Destroy_aux<__has_trivial_destructor(_Value_type)>::
                               :	__destroy(__first, __last);
                               :    }
                               :
                               :  /**
                               :   * Destroy a range of objects using the supplied allocator.  For
                               :   * nondefault allocators we do not optimize away invocation of 
                               :   * destroy() even if _Tp has a trivial destructor.
                               :   */
                               :
                               :  template<typename _ForwardIterator, typename _Allocator>
                               :    void
                               :    _Destroy(_ForwardIterator __first, _ForwardIterator __last,
                               :	     _Allocator& __alloc)
                               :    {
                               :      typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
                               :      for (; __first != __last; ++__first)
                               :	__traits::destroy(__alloc, std::__addressof(*__first));
                               :    }
                               :
                               :  template<typename _ForwardIterator, typename _Tp>
                               :    inline void
                               :    _Destroy(_ForwardIterator __first, _ForwardIterator __last,
                               :	     allocator<_Tp>&)
                               :    {
                               :      _Destroy(__first, __last);
                               :    }
                               :
                               :_GLIBCXX_END_NAMESPACE_VERSION
                               :} // namespace std
                               :
                               :#endif /* _STL_CONSTRUCT_H */
                               :
/* 
 * Total samples for file : "/usr/include/i386-linux-gnu/bits/string3.h"
 * 
 *    959  0.8159     1  0.0591
 */


                               :/* Copyright (C) 2004-2014 Free Software Foundation, Inc.
                               :   This file is part of the GNU C Library.
                               :
                               :   The GNU C Library is free software; you can redistribute it and/or
                               :   modify it under the terms of the GNU Lesser General Public
                               :   License as published by the Free Software Foundation; either
                               :   version 2.1 of the License, or (at your option) any later version.
                               :
                               :   The GNU C Library is distributed in the hope that it will be useful,
                               :   but WITHOUT ANY WARRANTY; without even the implied warranty of
                               :   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
                               :   Lesser General Public License for more details.
                               :
                               :   You should have received a copy of the GNU Lesser General Public
                               :   License along with the GNU C Library; if not, see
                               :   <http://www.gnu.org/licenses/>.  */
                               :
                               :#ifndef _STRING_H
                               :# error "Never use <bits/string3.h> directly; include <string.h> instead."
                               :#endif
                               :
                               :__warndecl (__warn_memset_zero_len,
                               :	    "memset used with constant zero length parameter; this could be due to transposed parameters");
                               :
                               :#ifndef __cplusplus
                               :/* XXX This is temporarily.  We should not redefine any of the symbols
                               :   and instead integrate the error checking into the original
                               :   definitions.  */
                               :# undef memcpy
                               :# undef memmove
                               :# undef memset
                               :# undef strcat
                               :# undef strcpy
                               :# undef strncat
                               :# undef strncpy
                               :# ifdef __USE_GNU
                               :#  undef mempcpy
                               :#  undef stpcpy
                               :# endif
                               :# ifdef __USE_BSD
                               :#  undef bcopy
                               :#  undef bzero
                               :# endif
                               :#endif
                               :
                               :
                               :__fortify_function void *
                               :__NTH (memcpy (void *__restrict __dest, const void *__restrict __src,
                               :	       size_t __len))
                               :{
                               :  return __builtin___memcpy_chk (__dest, __src, __len, __bos0 (__dest));
                               :}
                               :
                               :__fortify_function void *
                               :__NTH (memmove (void *__dest, const void *__src, size_t __len))
                               :{
                               :  return __builtin___memmove_chk (__dest, __src, __len, __bos0 (__dest));
                               :}
                               :
                               :#ifdef __USE_GNU
                               :__fortify_function void *
                               :__NTH (mempcpy (void *__restrict __dest, const void *__restrict __src,
                               :		size_t __len))
                               :{
                               :  return __builtin___mempcpy_chk (__dest, __src, __len, __bos0 (__dest));
                               :}
                               :#endif
                               :
                               :
                               :/* The first two tests here help to catch a somewhat common problem
                               :   where the second and third parameter are transposed.  This is
                               :   especially problematic if the intended fill value is zero.  In this
                               :   case no work is done at all.  We detect these problems by referring
                               :   non-existing functions.  */
                               :__fortify_function void *
                               :__NTH (memset (void *__dest, int __ch, size_t __len))
                               :{
                               :  if (__builtin_constant_p (__len) && __len == 0
                               :      && (!__builtin_constant_p (__ch) || __ch != 0))
                               :    {
                               :      __warn_memset_zero_len ();
                               :      return __dest;
                               :    }
   956  0.8134     1  0.0591   :  return __builtin___memset_chk (__dest, __ch, __len, __bos0 (__dest));
                               :}
                               :
                               :#ifdef __USE_BSD
                               :__fortify_function void
                               :__NTH (bcopy (const void *__src, void *__dest, size_t __len))
                               :{
                               :  (void) __builtin___memmove_chk (__dest, __src, __len, __bos0 (__dest));
                               :}
                               :
                               :__fortify_function void
                               :__NTH (bzero (void *__dest, size_t __len))
                               :{
                               :  (void) __builtin___memset_chk (__dest, '\0', __len, __bos0 (__dest));
                               :}
                               :#endif
                               :
                               :__fortify_function char *
                               :__NTH (strcpy (char *__restrict __dest, const char *__restrict __src))
                               :{
                               :  return __builtin___strcpy_chk (__dest, __src, __bos (__dest));
                               :}
                               :
                               :#ifdef __USE_GNU
                               :__fortify_function char *
                               :__NTH (stpcpy (char *__restrict __dest, const char *__restrict __src))
                               :{
                               :  return __builtin___stpcpy_chk (__dest, __src, __bos (__dest));
                               :}
                               :#endif
                               :
                               :
                               :__fortify_function char *
                               :__NTH (strncpy (char *__restrict __dest, const char *__restrict __src,
                               :		size_t __len))
                               :{
     3  0.0026     0       0   :  return __builtin___strncpy_chk (__dest, __src, __len, __bos (__dest));
                               :}
                               :
                               :// XXX We have no corresponding builtin yet.
                               :extern char *__stpncpy_chk (char *__dest, const char *__src, size_t __n,
                               :			    size_t __destlen) __THROW;
                               :extern char *__REDIRECT_NTH (__stpncpy_alias, (char *__dest, const char *__src,
                               :					       size_t __n), stpncpy);
                               :
                               :__fortify_function char *
                               :__NTH (stpncpy (char *__dest, const char *__src, size_t __n))
                               :{
                               :  if (__bos (__dest) != (size_t) -1
                               :      && (!__builtin_constant_p (__n) || __n <= __bos (__dest)))
                               :    return __stpncpy_chk (__dest, __src, __n, __bos (__dest));
                               :  return __stpncpy_alias (__dest, __src, __n);
                               :}
                               :
                               :
                               :__fortify_function char *
                               :__NTH (strcat (char *__restrict __dest, const char *__restrict __src))
                               :{
                               :  return __builtin___strcat_chk (__dest, __src, __bos (__dest));
                               :}
                               :
                               :
                               :__fortify_function char *
                               :__NTH (strncat (char *__restrict __dest, const char *__restrict __src,
                               :		size_t __len))
                               :{
                               :  return __builtin___strncat_chk (__dest, __src, __len, __bos (__dest));
                               :}
/* 
 * Total samples for file : "/usr/include/c++/4.8/bits/stl_algobase.h"
 * 
 *    717  0.6100     5  0.2953
 */


                               :// Core algorithmic facilities -*- C++ -*-
                               :
                               :// Copyright (C) 2001-2013 Free Software Foundation, Inc.
                               ://
                               :// This file is part of the GNU ISO C++ Library.  This library is free
                               :// software; you can redistribute it and/or modify it under the
                               :// terms of the GNU General Public License as published by the
                               :// Free Software Foundation; either version 3, or (at your option)
                               :// any later version.
                               :
                               :// This library is distributed in the hope that it will be useful,
                               :// but WITHOUT ANY WARRANTY; without even the implied warranty of
                               :// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                               :// GNU General Public License for more details.
                               :
                               :// Under Section 7 of GPL version 3, you are granted additional
                               :// permissions described in the GCC Runtime Library Exception, version
                               :// 3.1, as published by the Free Software Foundation.
                               :
                               :// You should have received a copy of the GNU General Public License and
                               :// a copy of the GCC Runtime Library Exception along with this program;
                               :// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                               :// <http://www.gnu.org/licenses/>.
                               :
                               :/*
                               : *
                               : * Copyright (c) 1994
                               : * Hewlett-Packard Company
                               : *
                               : * Permission to use, copy, modify, distribute and sell this software
                               : * and its documentation for any purpose is hereby granted without fee,
                               : * provided that the above copyright notice appear in all copies and
                               : * that both that copyright notice and this permission notice appear
                               : * in supporting documentation.  Hewlett-Packard Company makes no
                               : * representations about the suitability of this software for any
                               : * purpose.  It is provided "as is" without express or implied warranty.
                               : *
                               : *
                               : * Copyright (c) 1996-1998
                               : * Silicon Graphics Computer Systems, Inc.
                               : *
                               : * Permission to use, copy, modify, distribute and sell this software
                               : * and its documentation for any purpose is hereby granted without fee,
                               : * provided that the above copyright notice appear in all copies and
                               : * that both that copyright notice and this permission notice appear
                               : * in supporting documentation.  Silicon Graphics makes no
                               : * representations about the suitability of this software for any
                               : * purpose.  It is provided "as is" without express or implied warranty.
                               : */
                               :
                               :/** @file bits/stl_algobase.h
                               : *  This is an internal header file, included by other library headers.
                               : *  Do not attempt to use it directly. @headername{algorithm}
                               : */
                               :
                               :#ifndef _STL_ALGOBASE_H
                               :#define _STL_ALGOBASE_H 1
                               :
                               :#include <bits/c++config.h>
                               :#include <bits/functexcept.h>
                               :#include <bits/cpp_type_traits.h>
                               :#include <ext/type_traits.h>
                               :#include <ext/numeric_traits.h>
                               :#include <bits/stl_pair.h>
                               :#include <bits/stl_iterator_base_types.h>
                               :#include <bits/stl_iterator_base_funcs.h>
                               :#include <bits/stl_iterator.h>
                               :#include <bits/concept_check.h>
                               :#include <debug/debug.h>
                               :#include <bits/move.h> // For std::swap and _GLIBCXX_MOVE
                               :
                               :namespace std _GLIBCXX_VISIBILITY(default)
                               :{
                               :_GLIBCXX_BEGIN_NAMESPACE_VERSION
                               :
                               :#if __cplusplus < 201103L
                               :  // See http://gcc.gnu.org/ml/libstdc++/2004-08/msg00167.html: in a
                               :  // nutshell, we are partially implementing the resolution of DR 187,
                               :  // when it's safe, i.e., the value_types are equal.
                               :  template<bool _BoolType>
                               :    struct __iter_swap
                               :    {
                               :      template<typename _ForwardIterator1, typename _ForwardIterator2>
                               :        static void
                               :        iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
                               :        {
                               :          typedef typename iterator_traits<_ForwardIterator1>::value_type
                               :            _ValueType1;
                               :          _ValueType1 __tmp = _GLIBCXX_MOVE(*__a);
                               :          *__a = _GLIBCXX_MOVE(*__b);
                               :          *__b = _GLIBCXX_MOVE(__tmp);
                               :	}
                               :    };
                               :
                               :  template<>
                               :    struct __iter_swap<true>
                               :    {
                               :      template<typename _ForwardIterator1, typename _ForwardIterator2>
                               :        static void 
                               :        iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
                               :        {
                               :          swap(*__a, *__b);
                               :        }
                               :    };
                               :#endif
                               :
                               :  /**
                               :   *  @brief Swaps the contents of two iterators.
                               :   *  @ingroup mutating_algorithms
                               :   *  @param  __a  An iterator.
                               :   *  @param  __b  Another iterator.
                               :   *  @return   Nothing.
                               :   *
                               :   *  This function swaps the values pointed to by two iterators, not the
                               :   *  iterators themselves.
                               :  */
                               :  template<typename _ForwardIterator1, typename _ForwardIterator2>
                               :    inline void
                               :    iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
                               :    {
                               :      // concept requirements
                               :      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
                               :				  _ForwardIterator1>)
                               :      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
                               :				  _ForwardIterator2>)
                               :
                               :#if __cplusplus < 201103L
                               :      typedef typename iterator_traits<_ForwardIterator1>::value_type
                               :	_ValueType1;
                               :      typedef typename iterator_traits<_ForwardIterator2>::value_type
                               :	_ValueType2;
                               :
                               :      __glibcxx_function_requires(_ConvertibleConcept<_ValueType1,
                               :				  _ValueType2>)
                               :      __glibcxx_function_requires(_ConvertibleConcept<_ValueType2,
                               :				  _ValueType1>)
                               :
                               :      typedef typename iterator_traits<_ForwardIterator1>::reference
                               :	_ReferenceType1;
                               :      typedef typename iterator_traits<_ForwardIterator2>::reference
                               :	_ReferenceType2;
                               :      std::__iter_swap<__are_same<_ValueType1, _ValueType2>::__value
                               :	&& __are_same<_ValueType1&, _ReferenceType1>::__value
                               :	&& __are_same<_ValueType2&, _ReferenceType2>::__value>::
                               :	iter_swap(__a, __b);
                               :#else
                               :      swap(*__a, *__b);
                               :#endif
                               :    }
                               :
                               :  /**
                               :   *  @brief Swap the elements of two sequences.
                               :   *  @ingroup mutating_algorithms
                               :   *  @param  __first1  A forward iterator.
                               :   *  @param  __last1   A forward iterator.
                               :   *  @param  __first2  A forward iterator.
                               :   *  @return   An iterator equal to @p first2+(last1-first1).
                               :   *
                               :   *  Swaps each element in the range @p [first1,last1) with the
                               :   *  corresponding element in the range @p [first2,(last1-first1)).
                               :   *  The ranges must not overlap.
                               :  */
                               :  template<typename _ForwardIterator1, typename _ForwardIterator2>
                               :    _ForwardIterator2
                               :    swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
                               :		_ForwardIterator2 __first2)
                               :    {
                               :      // concept requirements
                               :      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
                               :				  _ForwardIterator1>)
                               :      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
                               :				  _ForwardIterator2>)
                               :      __glibcxx_requires_valid_range(__first1, __last1);
                               :
                               :      for (; __first1 != __last1; ++__first1, ++__first2)
                               :	std::iter_swap(__first1, __first2);
                               :      return __first2;
                               :    }
                               :
                               :  /**
                               :   *  @brief This does what you think it does.
                               :   *  @ingroup sorting_algorithms
                               :   *  @param  __a  A thing of arbitrary type.
                               :   *  @param  __b  Another thing of arbitrary type.
                               :   *  @return   The lesser of the parameters.
                               :   *
                               :   *  This is the simple classic generic implementation.  It will work on
                               :   *  temporary expressions, since they are only evaluated once, unlike a
                               :   *  preprocessor macro.
                               :  */
                               :  template<typename _Tp>
                               :    inline const _Tp&
                               :    min(const _Tp& __a, const _Tp& __b)
                               :    {
                               :      // concept requirements
                               :      __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)
                               :      //return __b < __a ? __b : __a;
                               :      if (__b < __a)
                               :	return __b;
                               :      return __a;
                               :    }
                               :
                               :  /**
                               :   *  @brief This does what you think it does.
                               :   *  @ingroup sorting_algorithms
                               :   *  @param  __a  A thing of arbitrary type.
                               :   *  @param  __b  Another thing of arbitrary type.
                               :   *  @return   The greater of the parameters.
                               :   *
                               :   *  This is the simple classic generic implementation.  It will work on
                               :   *  temporary expressions, since they are only evaluated once, unlike a
                               :   *  preprocessor macro.
                               :  */
                               :  template<typename _Tp>
                               :    inline const _Tp&
                               :    max(const _Tp& __a, const _Tp& __b)
                               :    {
                               :      // concept requirements
                               :      __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)
                               :      //return  __a < __b ? __b : __a;
    10  0.0085     0       0   :      if (__a < __b)
                               :	return __b;
                               :      return __a;
                               :    }
                               :
                               :  /**
                               :   *  @brief This does what you think it does.
                               :   *  @ingroup sorting_algorithms
                               :   *  @param  __a  A thing of arbitrary type.
                               :   *  @param  __b  Another thing of arbitrary type.
                               :   *  @param  __comp  A @link comparison_functors comparison functor@endlink.
                               :   *  @return   The lesser of the parameters.
                               :   *
                               :   *  This will work on temporary expressions, since they are only evaluated
                               :   *  once, unlike a preprocessor macro.
                               :  */
                               :  template<typename _Tp, typename _Compare>
                               :    inline const _Tp&
                               :    min(const _Tp& __a, const _Tp& __b, _Compare __comp)
                               :    {
                               :      //return __comp(__b, __a) ? __b : __a;
                               :      if (__comp(__b, __a))
                               :	return __b;
                               :      return __a;
                               :    }
                               :
                               :  /**
                               :   *  @brief This does what you think it does.
                               :   *  @ingroup sorting_algorithms
                               :   *  @param  __a  A thing of arbitrary type.
                               :   *  @param  __b  Another thing of arbitrary type.
                               :   *  @param  __comp  A @link comparison_functors comparison functor@endlink.
                               :   *  @return   The greater of the parameters.
                               :   *
                               :   *  This will work on temporary expressions, since they are only evaluated
                               :   *  once, unlike a preprocessor macro.
                               :  */
                               :  template<typename _Tp, typename _Compare>
                               :    inline const _Tp&
                               :    max(const _Tp& __a, const _Tp& __b, _Compare __comp)
                               :    {
                               :      //return __comp(__a, __b) ? __b : __a;
                               :      if (__comp(__a, __b))
                               :	return __b;
                               :      return __a;
                               :    }
                               :
                               :  // If _Iterator is a __normal_iterator return its base (a plain pointer,
                               :  // normally) otherwise return it untouched.  See copy, fill, ... 
                               :  template<typename _Iterator>
                               :    struct _Niter_base
                               :    : _Iter_base<_Iterator, __is_normal_iterator<_Iterator>::__value>
                               :    { };
                               :
                               :  template<typename _Iterator>
                               :    inline typename _Niter_base<_Iterator>::iterator_type
                               :    __niter_base(_Iterator __it)
                               :    { return std::_Niter_base<_Iterator>::_S_base(__it); }
                               :
                               :  // Likewise, for move_iterator.
                               :  template<typename _Iterator>
                               :    struct _Miter_base
                               :    : _Iter_base<_Iterator, __is_move_iterator<_Iterator>::__value>
                               :    { };
                               :
                               :  template<typename _Iterator>
                               :    inline typename _Miter_base<_Iterator>::iterator_type
                               :    __miter_base(_Iterator __it)
                               :    { return std::_Miter_base<_Iterator>::_S_base(__it); }
                               :
                               :  // All of these auxiliary structs serve two purposes.  (1) Replace
                               :  // calls to copy with memmove whenever possible.  (Memmove, not memcpy,
                               :  // because the input and output ranges are permitted to overlap.)
                               :  // (2) If we're using random access iterators, then write the loop as
                               :  // a for loop with an explicit count.
                               :
                               :  template<bool, bool, typename>
                               :    struct __copy_move
                               :    {
                               :      template<typename _II, typename _OI>
                               :        static _OI
                               :        __copy_m(_II __first, _II __last, _OI __result)
                               :        {
                               :	  for (; __first != __last; ++__result, ++__first)
                               :	    *__result = *__first;
                               :	  return __result;
                               :	}
                               :    };
                               :
                               :#if __cplusplus >= 201103L
                               :  template<typename _Category>
                               :    struct __copy_move<true, false, _Category>
                               :    {
                               :      template<typename _II, typename _OI>
                               :        static _OI
                               :        __copy_m(_II __first, _II __last, _OI __result)
                               :        {
                               :	  for (; __first != __last; ++__result, ++__first)
                               :	    *__result = std::move(*__first);
                               :	  return __result;
                               :	}
                               :    };
                               :#endif
                               :
                               :  template<>
                               :    struct __copy_move<false, false, random_access_iterator_tag>
                               :    {
                               :      template<typename _II, typename _OI>
                               :        static _OI
                               :        __copy_m(_II __first, _II __last, _OI __result)
                               :        { 
                               :	  typedef typename iterator_traits<_II>::difference_type _Distance;
     1 8.5e-04     0       0   :	  for(_Distance __n = __last - __first; __n > 0; --__n)
                               :	    {
                               :	      *__result = *__first;
                               :	      ++__first;
                               :	      ++__result;
                               :	    }
                               :	  return __result;
                               :	}
                               :    };
                               :
                               :#if __cplusplus >= 201103L
                               :  template<>
                               :    struct __copy_move<true, false, random_access_iterator_tag>
                               :    {
                               :      template<typename _II, typename _OI>
                               :        static _OI
                               :        __copy_m(_II __first, _II __last, _OI __result)
                               :        { 
                               :	  typedef typename iterator_traits<_II>::difference_type _Distance;
                               :	  for(_Distance __n = __last - __first; __n > 0; --__n)
                               :	    {
                               :	      *__result = std::move(*__first);
                               :	      ++__first;
                               :	      ++__result;
                               :	    }
                               :	  return __result;
                               :	}
                               :    };
                               :#endif
                               :
                               :  template<bool _IsMove>
                               :    struct __copy_move<_IsMove, true, random_access_iterator_tag>
                               :    {
                               :      template<typename _Tp>
                               :        static _Tp*
                               :        __copy_m(const _Tp* __first, const _Tp* __last, _Tp* __result)
                               :        {
    75  0.0638     0       0   :	  const ptrdiff_t _Num = __last - __first;
   130  0.1106     2  0.1181   :	  if (_Num)
   292  0.2484     0       0   :	    __builtin_memmove(__result, __first, sizeof(_Tp) * _Num);
    55  0.0468     0       0   :	  return __result + _Num;
                               :	}
                               :    };
                               :
                               :  template<bool _IsMove, typename _II, typename _OI>
                               :    inline _OI
                               :    __copy_move_a(_II __first, _II __last, _OI __result)
                               :    {
                               :      typedef typename iterator_traits<_II>::value_type _ValueTypeI;
                               :      typedef typename iterator_traits<_OI>::value_type _ValueTypeO;
                               :      typedef typename iterator_traits<_II>::iterator_category _Category;
                               :      const bool __simple = (__is_trivial(_ValueTypeI)
                               :	                     && __is_pointer<_II>::__value
                               :	                     && __is_pointer<_OI>::__value
                               :			     && __are_same<_ValueTypeI, _ValueTypeO>::__value);
                               :
                               :      return std::__copy_move<_IsMove, __simple,
                               :	                      _Category>::__copy_m(__first, __last, __result);
                               :    }
                               :
                               :  // Helpers for streambuf iterators (either istream or ostream).
                               :  // NB: avoid including <iosfwd>, relatively large.
                               :  template<typename _CharT>
                               :    struct char_traits;
                               :
                               :  template<typename _CharT, typename _Traits>
                               :    class istreambuf_iterator;
                               :
                               :  template<typename _CharT, typename _Traits>
                               :    class ostreambuf_iterator;
                               :
                               :  template<bool _IsMove, typename _CharT>
                               :    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, 
                               :	     ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
                               :    __copy_move_a2(_CharT*, _CharT*,
                               :		   ostreambuf_iterator<_CharT, char_traits<_CharT> >);
                               :
                               :  template<bool _IsMove, typename _CharT>
                               :    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, 
                               :	     ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
                               :    __copy_move_a2(const _CharT*, const _CharT*,
                               :		   ostreambuf_iterator<_CharT, char_traits<_CharT> >);
                               :
                               :  template<bool _IsMove, typename _CharT>
                               :    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
                               :				    _CharT*>::__type
                               :    __copy_move_a2(istreambuf_iterator<_CharT, char_traits<_CharT> >,
                               :		   istreambuf_iterator<_CharT, char_traits<_CharT> >, _CharT*);
                               :
                               :  template<bool _IsMove, typename _II, typename _OI>
                               :    inline _OI
                               :    __copy_move_a2(_II __first, _II __last, _OI __result)
                               :    {
                               :      return _OI(std::__copy_move_a<_IsMove>(std::__niter_base(__first),
                               :					     std::__niter_base(__last),
                               :					     std::__niter_base(__result)));
                               :    }
                               :
                               :  /**
                               :   *  @brief Copies the range [first,last) into result.
                               :   *  @ingroup mutating_algorithms
                               :   *  @param  __first  An input iterator.
                               :   *  @param  __last   An input iterator.
                               :   *  @param  __result An output iterator.
                               :   *  @return   result + (first - last)
                               :   *
                               :   *  This inline function will boil down to a call to @c memmove whenever
                               :   *  possible.  Failing that, if random access iterators are passed, then the
                               :   *  loop count will be known (and therefore a candidate for compiler
                               :   *  optimizations such as unrolling).  Result may not be contained within
                               :   *  [first,last); the copy_backward function should be used instead.
                               :   *
                               :   *  Note that the end of the output range is permitted to be contained
                               :   *  within [first,last).
                               :  */
                               :  template<typename _II, typename _OI>
                               :    inline _OI
                               :    copy(_II __first, _II __last, _OI __result)
                               :    {
                               :      // concept requirements
                               :      __glibcxx_function_requires(_InputIteratorConcept<_II>)
                               :      __glibcxx_function_requires(_OutputIteratorConcept<_OI,
                               :	    typename iterator_traits<_II>::value_type>)
                               :      __glibcxx_requires_valid_range(__first, __last);
                               :
                               :      return (std::__copy_move_a2<__is_move_iterator<_II>::__value>
                               :	      (std::__miter_base(__first), std::__miter_base(__last),
                               :	       __result));
                               :    }
                               :
                               :#if __cplusplus >= 201103L
                               :  /**
                               :   *  @brief Moves the range [first,last) into result.
                               :   *  @ingroup mutating_algorithms
                               :   *  @param  __first  An input iterator.
                               :   *  @param  __last   An input iterator.
                               :   *  @param  __result An output iterator.
                               :   *  @return   result + (first - last)
                               :   *
                               :   *  This inline function will boil down to a call to @c memmove whenever
                               :   *  possible.  Failing that, if random access iterators are passed, then the
                               :   *  loop count will be known (and therefore a candidate for compiler
                               :   *  optimizations such as unrolling).  Result may not be contained within
                               :   *  [first,last); the move_backward function should be used instead.
                               :   *
                               :   *  Note that the end of the output range is permitted to be contained
                               :   *  within [first,last).
                               :  */
                               :  template<typename _II, typename _OI>
                               :    inline _OI
                               :    move(_II __first, _II __last, _OI __result)
                               :    {
                               :      // concept requirements
                               :      __glibcxx_function_requires(_InputIteratorConcept<_II>)
                               :      __glibcxx_function_requires(_OutputIteratorConcept<_OI,
                               :	    typename iterator_traits<_II>::value_type>)
                               :      __glibcxx_requires_valid_range(__first, __last);
                               :
                               :      return std::__copy_move_a2<true>(std::__miter_base(__first),
                               :				       std::__miter_base(__last), __result);
                               :    }
                               :
                               :#define _GLIBCXX_MOVE3(_Tp, _Up, _Vp) std::move(_Tp, _Up, _Vp)
                               :#else
                               :#define _GLIBCXX_MOVE3(_Tp, _Up, _Vp) std::copy(_Tp, _Up, _Vp)
                               :#endif
                               :
                               :  template<bool, bool, typename>
                               :    struct __copy_move_backward
                               :    {
                               :      template<typename _BI1, typename _BI2>
                               :        static _BI2
                               :        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
                               :        {
                               :	  while (__first != __last)
                               :	    *--__result = *--__last;
                               :	  return __result;
                               :	}
                               :    };
                               :
                               :#if __cplusplus >= 201103L
                               :  template<typename _Category>
                               :    struct __copy_move_backward<true, false, _Category>
                               :    {
                               :      template<typename _BI1, typename _BI2>
                               :        static _BI2
                               :        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
                               :        {
                               :	  while (__first != __last)
                               :	    *--__result = std::move(*--__last);
                               :	  return __result;
                               :	}
                               :    };
                               :#endif
                               :
                               :  template<>
                               :    struct __copy_move_backward<false, false, random_access_iterator_tag>
                               :    {
                               :      template<typename _BI1, typename _BI2>
                               :        static _BI2
                               :        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
                               :        {
                               :	  typename iterator_traits<_BI1>::difference_type __n;
                               :	  for (__n = __last - __first; __n > 0; --__n)
                               :	    *--__result = *--__last;
                               :	  return __result;
                               :	}
                               :    };
                               :
                               :#if __cplusplus >= 201103L
                               :  template<>
                               :    struct __copy_move_backward<true, false, random_access_iterator_tag>
                               :    {
                               :      template<typename _BI1, typename _BI2>
                               :        static _BI2
                               :        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
                               :        {
                               :	  typename iterator_traits<_BI1>::difference_type __n;
                               :	  for (__n = __last - __first; __n > 0; --__n)
                               :	    *--__result = std::move(*--__last);
                               :	  return __result;
                               :	}
                               :    };
                               :#endif
                               :
                               :  template<bool _IsMove>
                               :    struct __copy_move_backward<_IsMove, true, random_access_iterator_tag>
                               :    {
                               :      template<typename _Tp>
                               :        static _Tp*
                               :        __copy_move_b(const _Tp* __first, const _Tp* __last, _Tp* __result)
                               :        {
     9  0.0077     1  0.0591   :	  const ptrdiff_t _Num = __last - __first;
     2  0.0017     0       0   :	  if (_Num)
    13  0.0111     0       0   :	    __builtin_memmove(__result - _Num, __first, sizeof(_Tp) * _Num);
                               :	  return __result - _Num;
                               :	}
                               :    };
                               :
                               :  template<bool _IsMove, typename _BI1, typename _BI2>
                               :    inline _BI2
                               :    __copy_move_backward_a(_BI1 __first, _BI1 __last, _BI2 __result)
                               :    {
                               :      typedef typename iterator_traits<_BI1>::value_type _ValueType1;
                               :      typedef typename iterator_traits<_BI2>::value_type _ValueType2;
                               :      typedef typename iterator_traits<_BI1>::iterator_category _Category;
                               :      const bool __simple = (__is_trivial(_ValueType1)
                               :	                     && __is_pointer<_BI1>::__value
                               :	                     && __is_pointer<_BI2>::__value
                               :			     && __are_same<_ValueType1, _ValueType2>::__value);
                               :
                               :      return std::__copy_move_backward<_IsMove, __simple,
                               :	                               _Category>::__copy_move_b(__first,
                               :								 __last,
                               :								 __result);
                               :    }
                               :
                               :  template<bool _IsMove, typename _BI1, typename _BI2>
                               :    inline _BI2
                               :    __copy_move_backward_a2(_BI1 __first, _BI1 __last, _BI2 __result)
                               :    {
                               :      return _BI2(std::__copy_move_backward_a<_IsMove>
                               :		  (std::__niter_base(__first), std::__niter_base(__last),
                               :		   std::__niter_base(__result)));
                               :    }
                               :
                               :  /**
                               :   *  @brief Copies the range [first,last) into result.
                               :   *  @ingroup mutating_algorithms
                               :   *  @param  __first  A bidirectional iterator.
                               :   *  @param  __last   A bidirectional iterator.
                               :   *  @param  __result A bidirectional iterator.
                               :   *  @return   result - (first - last)
                               :   *
                               :   *  The function has the same effect as copy, but starts at the end of the
                               :   *  range and works its way to the start, returning the start of the result.
                               :   *  This inline function will boil down to a call to @c memmove whenever
                               :   *  possible.  Failing that, if random access iterators are passed, then the
                               :   *  loop count will be known (and therefore a candidate for compiler
                               :   *  optimizations such as unrolling).
                               :   *
                               :   *  Result may not be in the range (first,last].  Use copy instead.  Note
                               :   *  that the start of the output range may overlap [first,last).
                               :  */
                               :  template<typename _BI1, typename _BI2>
                               :    inline _BI2
                               :    copy_backward(_BI1 __first, _BI1 __last, _BI2 __result)
                               :    {
                               :      // concept requirements
                               :      __glibcxx_function_requires(_BidirectionalIteratorConcept<_BI1>)
                               :      __glibcxx_function_requires(_Mutable_BidirectionalIteratorConcept<_BI2>)
                               :      __glibcxx_function_requires(_ConvertibleConcept<
                               :	    typename iterator_traits<_BI1>::value_type,
                               :	    typename iterator_traits<_BI2>::value_type>)
                               :      __glibcxx_requires_valid_range(__first, __last);
                               :
                               :      return (std::__copy_move_backward_a2<__is_move_iterator<_BI1>::__value>
                               :	      (std::__miter_base(__first), std::__miter_base(__last),
                               :	       __result));
                               :    }
                               :
                               :#if __cplusplus >= 201103L
                               :  /**
                               :   *  @brief Moves the range [first,last) into result.
                               :   *  @ingroup mutating_algorithms
                               :   *  @param  __first  A bidirectional iterator.
                               :   *  @param  __last   A bidirectional iterator.
                               :   *  @param  __result A bidirectional iterator.
                               :   *  @return   result - (first - last)
                               :   *
                               :   *  The function has the same effect as move, but starts at the end of the
                               :   *  range and works its way to the start, returning the start of the result.
                               :   *  This inline function will boil down to a call to @c memmove whenever
                               :   *  possible.  Failing that, if random access iterators are passed, then the
                               :   *  loop count will be known (and therefore a candidate for compiler
                               :   *  optimizations such as unrolling).
                               :   *
                               :   *  Result may not be in the range (first,last].  Use move instead.  Note
                               :   *  that the start of the output range may overlap [first,last).
                               :  */
                               :  template<typename _BI1, typename _BI2>
                               :    inline _BI2
                               :    move_backward(_BI1 __first, _BI1 __last, _BI2 __result)
                               :    {
                               :      // concept requirements
                               :      __glibcxx_function_requires(_BidirectionalIteratorConcept<_BI1>)
                               :      __glibcxx_function_requires(_Mutable_BidirectionalIteratorConcept<_BI2>)
                               :      __glibcxx_function_requires(_ConvertibleConcept<
                               :	    typename iterator_traits<_BI1>::value_type,
                               :	    typename iterator_traits<_BI2>::value_type>)
                               :      __glibcxx_requires_valid_range(__first, __last);
                               :
                               :      return std::__copy_move_backward_a2<true>(std::__miter_base(__first),
                               :						std::__miter_base(__last),
                               :						__result);
                               :    }
                               :
                               :#define _GLIBCXX_MOVE_BACKWARD3(_Tp, _Up, _Vp) std::move_backward(_Tp, _Up, _Vp)
                               :#else
                               :#define _GLIBCXX_MOVE_BACKWARD3(_Tp, _Up, _Vp) std::copy_backward(_Tp, _Up, _Vp)
                               :#endif
                               :
                               :  template<typename _ForwardIterator, typename _Tp>
                               :    inline typename
                               :    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, void>::__type
                               :    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
                               : 	     const _Tp& __value)
                               :    {
                               :      for (; __first != __last; ++__first)
                               :	*__first = __value;
                               :    }
                               :    
                               :  template<typename _ForwardIterator, typename _Tp>
                               :    inline typename
                               :    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
                               :    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
                               :	     const _Tp& __value)
                               :    {
                               :      const _Tp __tmp = __value;
                               :      for (; __first != __last; ++__first)
                               :	*__first = __tmp;
                               :    }
                               :
                               :  // Specialization: for char types we can use memset.
                               :  template<typename _Tp>
                               :    inline typename
                               :    __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, void>::__type
                               :    __fill_a(_Tp* __first, _Tp* __last, const _Tp& __c)
                               :    {
                               :      const _Tp __tmp = __c;
                               :      __builtin_memset(__first, static_cast<unsigned char>(__tmp),
                               :		       __last - __first);
                               :    }
                               :
                               :  /**
                               :   *  @brief Fills the range [first,last) with copies of value.
                               :   *  @ingroup mutating_algorithms
                               :   *  @param  __first  A forward iterator.
                               :   *  @param  __last   A forward iterator.
                               :   *  @param  __value  A reference-to-const of arbitrary type.
                               :   *  @return   Nothing.
                               :   *
                               :   *  This function fills a range with copies of the same value.  For char
                               :   *  types filling contiguous areas of memory, this becomes an inline call
                               :   *  to @c memset or @c wmemset.
                               :  */
                               :  template<typename _ForwardIterator, typename _Tp>
                               :    inline void
                               :    fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value)
                               :    {
                               :      // concept requirements
                               :      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
                               :				  _ForwardIterator>)
                               :      __glibcxx_requires_valid_range(__first, __last);
                               :
                               :      std::__fill_a(std::__niter_base(__first), std::__niter_base(__last),
                               :		    __value);
                               :    }
                               :
                               :  template<typename _OutputIterator, typename _Size, typename _Tp>
                               :    inline typename
                               :    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, _OutputIterator>::__type
                               :    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value)
                               :    {
                               :      for (__decltype(__n + 0) __niter = __n;
                               :	   __niter > 0; --__niter, ++__first)
                               :	*__first = __value;
                               :      return __first;
                               :    }
                               :
                               :  template<typename _OutputIterator, typename _Size, typename _Tp>
                               :    inline typename
                               :    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, _OutputIterator>::__type
                               :    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value)
                               :    {
                               :      const _Tp __tmp = __value;
    20  0.0170     0       0   :      for (__decltype(__n + 0) __niter = __n;
                               :	   __niter > 0; --__niter, ++__first)
    29  0.0247     0       0   :	*__first = __tmp;
                               :      return __first;
                               :    }
                               :
                               :  template<typename _Size, typename _Tp>
                               :    inline typename
                               :    __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, _Tp*>::__type
                               :    __fill_n_a(_Tp* __first, _Size __n, const _Tp& __c)
                               :    {
                               :      std::__fill_a(__first, __first + __n, __c);
                               :      return __first + __n;
                               :    }
                               :
                               :  /**
                               :   *  @brief Fills the range [first,first+n) with copies of value.
                               :   *  @ingroup mutating_algorithms
                               :   *  @param  __first  An output iterator.
                               :   *  @param  __n      The count of copies to perform.
                               :   *  @param  __value  A reference-to-const of arbitrary type.
                               :   *  @return   The iterator at first+n.
                               :   *
                               :   *  This function fills a range with copies of the same value.  For char
                               :   *  types filling contiguous areas of memory, this becomes an inline call
                               :   *  to @c memset or @ wmemset.
                               :   *
                               :   *  _GLIBCXX_RESOLVE_LIB_DEFECTS
                               :   *  DR 865. More algorithms that throw away information
                               :  */
                               :  template<typename _OI, typename _Size, typename _Tp>
                               :    inline _OI
                               :    fill_n(_OI __first, _Size __n, const _Tp& __value)
                               :    {
                               :      // concept requirements
                               :      __glibcxx_function_requires(_OutputIteratorConcept<_OI, _Tp>)
                               :
                               :      return _OI(std::__fill_n_a(std::__niter_base(__first), __n, __value));
                               :    }
                               :
                               :  template<bool _BoolType>
                               :    struct __equal
                               :    {
                               :      template<typename _II1, typename _II2>
                               :        static bool
                               :        equal(_II1 __first1, _II1 __last1, _II2 __first2)
                               :        {
                               :	  for (; __first1 != __last1; ++__first1, ++__first2)
                               :	    if (!(*__first1 == *__first2))
                               :	      return false;
                               :	  return true;
                               :	}
                               :    };
                               :
                               :  template<>
                               :    struct __equal<true>
                               :    {
                               :      template<typename _Tp>
                               :        static bool
                               :        equal(const _Tp* __first1, const _Tp* __last1, const _Tp* __first2)
                               :        {
                               :	  return !__builtin_memcmp(__first1, __first2, sizeof(_Tp)
    81  0.0689     2  0.1181   :				   * (__last1 - __first1));
                               :	}
                               :    };
                               :
                               :  template<typename _II1, typename _II2>
                               :    inline bool
                               :    __equal_aux(_II1 __first1, _II1 __last1, _II2 __first2)
                               :    {
                               :      typedef typename iterator_traits<_II1>::value_type _ValueType1;
                               :      typedef typename iterator_traits<_II2>::value_type _ValueType2;
                               :      const bool __simple = ((__is_integer<_ValueType1>::__value
                               :			      || __is_pointer<_ValueType1>::__value)
                               :	                     && __is_pointer<_II1>::__value
                               :	                     && __is_pointer<_II2>::__value
                               :			     && __are_same<_ValueType1, _ValueType2>::__value);
                               :
                               :      return std::__equal<__simple>::equal(__first1, __last1, __first2);
                               :    }
                               :
                               :
                               :  template<typename, typename>
                               :    struct __lc_rai
                               :    {
                               :      template<typename _II1, typename _II2>
                               :        static _II1
                               :        __newlast1(_II1, _II1 __last1, _II2, _II2)
                               :        { return __last1; }
                               :
                               :      template<typename _II>
                               :        static bool
                               :        __cnd2(_II __first, _II __last)
                               :        { return __first != __last; }
                               :    };
                               :
                               :  template<>
                               :    struct __lc_rai<random_access_iterator_tag, random_access_iterator_tag>
                               :    {
                               :      template<typename _RAI1, typename _RAI2>
                               :        static _RAI1
                               :        __newlast1(_RAI1 __first1, _RAI1 __last1,
                               :		   _RAI2 __first2, _RAI2 __last2)
                               :        {
                               :	  const typename iterator_traits<_RAI1>::difference_type
                               :	    __diff1 = __last1 - __first1;
                               :	  const typename iterator_traits<_RAI2>::difference_type
                               :	    __diff2 = __last2 - __first2;
                               :	  return __diff2 < __diff1 ? __first1 + __diff2 : __last1;
                               :	}
                               :
                               :      template<typename _RAI>
                               :        static bool
                               :        __cnd2(_RAI, _RAI)
                               :        { return true; }
                               :    };
                               :
                               :  template<bool _BoolType>
                               :    struct __lexicographical_compare
                               :    {
                               :      template<typename _II1, typename _II2>
                               :        static bool __lc(_II1, _II1, _II2, _II2);
                               :    };
                               :
                               :  template<bool _BoolType>
                               :    template<typename _II1, typename _II2>
                               :      bool
                               :      __lexicographical_compare<_BoolType>::
                               :      __lc(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
                               :      {
                               :	typedef typename iterator_traits<_II1>::iterator_category _Category1;
                               :	typedef typename iterator_traits<_II2>::iterator_category _Category2;
                               :	typedef std::__lc_rai<_Category1, _Category2> 	__rai_type;
                               :	
                               :	__last1 = __rai_type::__newlast1(__first1, __last1,
                               :					 __first2, __last2);
                               :	for (; __first1 != __last1 && __rai_type::__cnd2(__first2, __last2);
                               :	     ++__first1, ++__first2)
                               :	  {
                               :	    if (*__first1 < *__first2)
                               :	      return true;
                               :	    if (*__first2 < *__first1)
                               :	      return false;
                               :	  }
                               :	return __first1 == __last1 && __first2 != __last2;
                               :      }
                               :
                               :  template<>
                               :    struct __lexicographical_compare<true>
                               :    {
                               :      template<typename _Tp, typename _Up>
                               :        static bool
                               :        __lc(const _Tp* __first1, const _Tp* __last1,
                               :	     const _Up* __first2, const _Up* __last2)
                               :	{
                               :	  const size_t __len1 = __last1 - __first1;
                               :	  const size_t __len2 = __last2 - __first2;
                               :	  const int __result = __builtin_memcmp(__first1, __first2,
                               :						std::min(__len1, __len2));
                               :	  return __result != 0 ? __result < 0 : __len1 < __len2;
                               :	}
                               :    };
                               :
                               :  template<typename _II1, typename _II2>
                               :    inline bool
                               :    __lexicographical_compare_aux(_II1 __first1, _II1 __last1,
                               :				  _II2 __first2, _II2 __last2)
                               :    {
                               :      typedef typename iterator_traits<_II1>::value_type _ValueType1;
                               :      typedef typename iterator_traits<_II2>::value_type _ValueType2;
                               :      const bool __simple =
                               :	(__is_byte<_ValueType1>::__value && __is_byte<_ValueType2>::__value
                               :	 && !__gnu_cxx::__numeric_traits<_ValueType1>::__is_signed
                               :	 && !__gnu_cxx::__numeric_traits<_ValueType2>::__is_signed
                               :	 && __is_pointer<_II1>::__value
                               :	 && __is_pointer<_II2>::__value);
                               :
                               :      return std::__lexicographical_compare<__simple>::__lc(__first1, __last1,
                               :							    __first2, __last2);
                               :    }
                               :
                               :  /**
                               :   *  @brief Finds the first position in which @a val could be inserted
                               :   *         without changing the ordering.
                               :   *  @param  __first   An iterator.
                               :   *  @param  __last    Another iterator.
                               :   *  @param  __val     The search term.
                               :   *  @return         An iterator pointing to the first element <em>not less
                               :   *                  than</em> @a val, or end() if every element is less than 
                               :   *                  @a val.
                               :   *  @ingroup binary_search_algorithms
                               :  */
                               :  template<typename _ForwardIterator, typename _Tp>
                               :    _ForwardIterator
                               :    lower_bound(_ForwardIterator __first, _ForwardIterator __last,
                               :		const _Tp& __val)
                               :    {
                               :#ifdef _GLIBCXX_CONCEPT_CHECKS
                               :      typedef typename iterator_traits<_ForwardIterator>::value_type
                               :	_ValueType;
                               :#endif
                               :      typedef typename iterator_traits<_ForwardIterator>::difference_type
                               :	_DistanceType;
                               :
                               :      // concept requirements
                               :      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                               :      __glibcxx_function_requires(_LessThanOpConcept<_ValueType, _Tp>)
                               :      __glibcxx_requires_partitioned_lower(__first, __last, __val);
                               :
                               :      _DistanceType __len = std::distance(__first, __last);
                               :
                               :      while (__len > 0)
                               :	{
                               :	  _DistanceType __half = __len >> 1;
                               :	  _ForwardIterator __middle = __first;
                               :	  std::advance(__middle, __half);
                               :	  if (*__middle < __val)
                               :	    {
                               :	      __first = __middle;
                               :	      ++__first;
                               :	      __len = __len - __half - 1;
                               :	    }
                               :	  else
                               :	    __len = __half;
                               :	}
                               :      return __first;
                               :    }
                               :
                               :  /// This is a helper function for the sort routines and for random.tcc.
                               :  //  Precondition: __n > 0.
                               :  inline _GLIBCXX_CONSTEXPR int
                               :  __lg(int __n)
                               :  { return sizeof(int) * __CHAR_BIT__  - 1 - __builtin_clz(__n); }
                               :
                               :  inline _GLIBCXX_CONSTEXPR unsigned
                               :  __lg(unsigned __n)
                               :  { return sizeof(int) * __CHAR_BIT__  - 1 - __builtin_clz(__n); }
                               :
                               :  inline _GLIBCXX_CONSTEXPR long
                               :  __lg(long __n)
                               :  { return sizeof(long) * __CHAR_BIT__ - 1 - __builtin_clzl(__n); }
                               :
                               :  inline _GLIBCXX_CONSTEXPR unsigned long
                               :  __lg(unsigned long __n)
                               :  { return sizeof(long) * __CHAR_BIT__ - 1 - __builtin_clzl(__n); }
                               :
                               :  inline _GLIBCXX_CONSTEXPR long long
                               :  __lg(long long __n)
                               :  { return sizeof(long long) * __CHAR_BIT__ - 1 - __builtin_clzll(__n); }
                               :
                               :  inline _GLIBCXX_CONSTEXPR unsigned long long
                               :  __lg(unsigned long long __n)
                               :  { return sizeof(long long) * __CHAR_BIT__ - 1 - __builtin_clzll(__n); }
                               :
                               :_GLIBCXX_END_NAMESPACE_VERSION
                               :
                               :_GLIBCXX_BEGIN_NAMESPACE_ALGO
                               :
                               :  /**
                               :   *  @brief Tests a range for element-wise equality.
                               :   *  @ingroup non_mutating_algorithms
                               :   *  @param  __first1  An input iterator.
                               :   *  @param  __last1   An input iterator.
                               :   *  @param  __first2  An input iterator.
                               :   *  @return   A boolean true or false.
                               :   *
                               :   *  This compares the elements of two ranges using @c == and returns true or
                               :   *  false depending on whether all of the corresponding elements of the
                               :   *  ranges are equal.
                               :  */
                               :  template<typename _II1, typename _II2>
                               :    inline bool
                               :    equal(_II1 __first1, _II1 __last1, _II2 __first2)
                               :    {
                               :      // concept requirements
                               :      __glibcxx_function_requires(_InputIteratorConcept<_II1>)
                               :      __glibcxx_function_requires(_InputIteratorConcept<_II2>)
                               :      __glibcxx_function_requires(_EqualOpConcept<
                               :	    typename iterator_traits<_II1>::value_type,
                               :	    typename iterator_traits<_II2>::value_type>)
                               :      __glibcxx_requires_valid_range(__first1, __last1);
                               :
                               :      return std::__equal_aux(std::__niter_base(__first1),
                               :			      std::__niter_base(__last1),
                               :			      std::__niter_base(__first2));
                               :    }
                               :
                               :  /**
                               :   *  @brief Tests a range for element-wise equality.
                               :   *  @ingroup non_mutating_algorithms
                               :   *  @param  __first1  An input iterator.
                               :   *  @param  __last1   An input iterator.
                               :   *  @param  __first2  An input iterator.
                               :   *  @param __binary_pred A binary predicate @link functors
                               :   *                  functor@endlink.
                               :   *  @return         A boolean true or false.
                               :   *
                               :   *  This compares the elements of two ranges using the binary_pred
                               :   *  parameter, and returns true or
                               :   *  false depending on whether all of the corresponding elements of the
                               :   *  ranges are equal.
                               :  */
                               :  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
                               :    inline bool
                               :    equal(_IIter1 __first1, _IIter1 __last1,
                               :	  _IIter2 __first2, _BinaryPredicate __binary_pred)
                               :    {
                               :      // concept requirements
                               :      __glibcxx_function_requires(_InputIteratorConcept<_IIter1>)
                               :      __glibcxx_function_requires(_InputIteratorConcept<_IIter2>)
                               :      __glibcxx_requires_valid_range(__first1, __last1);
                               :
                               :      for (; __first1 != __last1; ++__first1, ++__first2)
                               :	if (!bool(__binary_pred(*__first1, *__first2)))
                               :	  return false;
                               :      return true;
                               :    }
                               :
                               :  /**
                               :   *  @brief Performs @b dictionary comparison on ranges.
                               :   *  @ingroup sorting_algorithms
                               :   *  @param  __first1  An input iterator.
                               :   *  @param  __last1   An input iterator.
                               :   *  @param  __first2  An input iterator.
                               :   *  @param  __last2   An input iterator.
                               :   *  @return   A boolean true or false.
                               :   *
                               :   *  <em>Returns true if the sequence of elements defined by the range
                               :   *  [first1,last1) is lexicographically less than the sequence of elements
                               :   *  defined by the range [first2,last2).  Returns false otherwise.</em>
                               :   *  (Quoted from [25.3.8]/1.)  If the iterators are all character pointers,
                               :   *  then this is an inline call to @c memcmp.
                               :  */
                               :  template<typename _II1, typename _II2>
                               :    inline bool
                               :    lexicographical_compare(_II1 __first1, _II1 __last1,
                               :			    _II2 __first2, _II2 __last2)
                               :    {
                               :#ifdef _GLIBCXX_CONCEPT_CHECKS
                               :      // concept requirements
                               :      typedef typename iterator_traits<_II1>::value_type _ValueType1;
                               :      typedef typename iterator_traits<_II2>::value_type _ValueType2;
                               :#endif
                               :      __glibcxx_function_requires(_InputIteratorConcept<_II1>)
                               :      __glibcxx_function_requires(_InputIteratorConcept<_II2>)
                               :      __glibcxx_function_requires(_LessThanOpConcept<_ValueType1, _ValueType2>)
                               :      __glibcxx_function_requires(_LessThanOpConcept<_ValueType2, _ValueType1>)
                               :      __glibcxx_requires_valid_range(__first1, __last1);
                               :      __glibcxx_requires_valid_range(__first2, __last2);
                               :
                               :      return std::__lexicographical_compare_aux(std::__niter_base(__first1),
                               :						std::__niter_base(__last1),
                               :						std::__niter_base(__first2),
                               :						std::__niter_base(__last2));
                               :    }
                               :
                               :  /**
                               :   *  @brief Performs @b dictionary comparison on ranges.
                               :   *  @ingroup sorting_algorithms
                               :   *  @param  __first1  An input iterator.
                               :   *  @param  __last1   An input iterator.
                               :   *  @param  __first2  An input iterator.
                               :   *  @param  __last2   An input iterator.
                               :   *  @param  __comp  A @link comparison_functors comparison functor@endlink.
                               :   *  @return   A boolean true or false.
                               :   *
                               :   *  The same as the four-parameter @c lexicographical_compare, but uses the
                               :   *  comp parameter instead of @c <.
                               :  */
                               :  template<typename _II1, typename _II2, typename _Compare>
                               :    bool
                               :    lexicographical_compare(_II1 __first1, _II1 __last1,
                               :			    _II2 __first2, _II2 __last2, _Compare __comp)
                               :    {
                               :      typedef typename iterator_traits<_II1>::iterator_category _Category1;
                               :      typedef typename iterator_traits<_II2>::iterator_category _Category2;
                               :      typedef std::__lc_rai<_Category1, _Category2> 	__rai_type;
                               :
                               :      // concept requirements
                               :      __glibcxx_function_requires(_InputIteratorConcept<_II1>)
                               :      __glibcxx_function_requires(_InputIteratorConcept<_II2>)
                               :      __glibcxx_requires_valid_range(__first1, __last1);
                               :      __glibcxx_requires_valid_range(__first2, __last2);
                               :
                               :      __last1 = __rai_type::__newlast1(__first1, __last1, __first2, __last2);
                               :      for (; __first1 != __last1 && __rai_type::__cnd2(__first2, __last2);
                               :	   ++__first1, ++__first2)
                               :	{
                               :	  if (__comp(*__first1, *__first2))
                               :	    return true;
                               :	  if (__comp(*__first2, *__first1))
                               :	    return false;
                               :	}
                               :      return __first1 == __last1 && __first2 != __last2;
                               :    }
                               :
                               :  /**
                               :   *  @brief Finds the places in ranges which don't match.
                               :   *  @ingroup non_mutating_algorithms
                               :   *  @param  __first1  An input iterator.
                               :   *  @param  __last1   An input iterator.
                               :   *  @param  __first2  An input iterator.
                               :   *  @return   A pair of iterators pointing to the first mismatch.
                               :   *
                               :   *  This compares the elements of two ranges using @c == and returns a pair
                               :   *  of iterators.  The first iterator points into the first range, the
                               :   *  second iterator points into the second range, and the elements pointed
                               :   *  to by the iterators are not equal.
                               :  */
                               :  template<typename _InputIterator1, typename _InputIterator2>
                               :    pair<_InputIterator1, _InputIterator2>
                               :    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
                               :	     _InputIterator2 __first2)
                               :    {
                               :      // concept requirements
                               :      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
                               :      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
                               :      __glibcxx_function_requires(_EqualOpConcept<
                               :	    typename iterator_traits<_InputIterator1>::value_type,
                               :	    typename iterator_traits<_InputIterator2>::value_type>)
                               :      __glibcxx_requires_valid_range(__first1, __last1);
                               :
                               :      while (__first1 != __last1 && *__first1 == *__first2)
                               :        {
                               :	  ++__first1;
                               :	  ++__first2;
                               :        }
                               :      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
                               :    }
                               :
                               :  /**
                               :   *  @brief Finds the places in ranges which don't match.
                               :   *  @ingroup non_mutating_algorithms
                               :   *  @param  __first1  An input iterator.
                               :   *  @param  __last1   An input iterator.
                               :   *  @param  __first2  An input iterator.
                               :   *  @param __binary_pred A binary predicate @link functors
                               :   *         functor@endlink.
                               :   *  @return   A pair of iterators pointing to the first mismatch.
                               :   *
                               :   *  This compares the elements of two ranges using the binary_pred
                               :   *  parameter, and returns a pair
                               :   *  of iterators.  The first iterator points into the first range, the
                               :   *  second iterator points into the second range, and the elements pointed
                               :   *  to by the iterators are not equal.
                               :  */
                               :  template<typename _InputIterator1, typename _InputIterator2,
                               :	   typename _BinaryPredicate>
                               :    pair<_InputIterator1, _InputIterator2>
                               :    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
                               :	     _InputIterator2 __first2, _BinaryPredicate __binary_pred)
                               :    {
                               :      // concept requirements
                               :      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
                               :      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
                               :      __glibcxx_requires_valid_range(__first1, __last1);
                               :
                               :      while (__first1 != __last1 && bool(__binary_pred(*__first1, *__first2)))
                               :        {
                               :	  ++__first1;
                               :	  ++__first2;
                               :        }
                               :      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
                               :    }
                               :
                               :_GLIBCXX_END_NAMESPACE_ALGO
                               :} // namespace std
                               :
                               :// NB: This file is included within many other C++ includes, as a way
                               :// of getting the base algorithms. So, make sure that parallel bits
                               :// come in too if requested. 
                               :#ifdef _GLIBCXX_PARALLEL
                               :# include <parallel/algobase.h>
                               :#endif
                               :
                               :#endif
/* 
 * Total samples for file : "/usr/include/c++/4.8/bits/stl_tree.h"
 * 
 *    640  0.5445    11  0.6497
 */


                               :// RB tree implementation -*- C++ -*-
                               :
                               :// Copyright (C) 2001-2013 Free Software Foundation, Inc.
                               ://
                               :// This file is part of the GNU ISO C++ Library.  This library is free
                               :// software; you can redistribute it and/or modify it under the
                               :// terms of the GNU General Public License as published by the
                               :// Free Software Foundation; either version 3, or (at your option)
                               :// any later version.
                               :
                               :// This library is distributed in the hope that it will be useful,
                               :// but WITHOUT ANY WARRANTY; without even the implied warranty of
                               :// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                               :// GNU General Public License for more details.
                               :
                               :// Under Section 7 of GPL version 3, you are granted additional
                               :// permissions described in the GCC Runtime Library Exception, version
                               :// 3.1, as published by the Free Software Foundation.
                               :
                               :// You should have received a copy of the GNU General Public License and
                               :// a copy of the GCC Runtime Library Exception along with this program;
                               :// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                               :// <http://www.gnu.org/licenses/>.
                               :
                               :/*
                               : *
                               : * Copyright (c) 1996,1997
                               : * Silicon Graphics Computer Systems, Inc.
                               : *
                               : * Permission to use, copy, modify, distribute and sell this software
                               : * and its documentation for any purpose is hereby granted without fee,
                               : * provided that the above copyright notice appear in all copies and
                               : * that both that copyright notice and this permission notice appear
                               : * in supporting documentation.  Silicon Graphics makes no
                               : * representations about the suitability of this software for any
                               : * purpose.  It is provided "as is" without express or implied warranty.
                               : *
                               : *
                               : * Copyright (c) 1994
                               : * Hewlett-Packard Company
                               : *
                               : * Permission to use, copy, modify, distribute and sell this software
                               : * and its documentation for any purpose is hereby granted without fee,
                               : * provided that the above copyright notice appear in all copies and
                               : * that both that copyright notice and this permission notice appear
                               : * in supporting documentation.  Hewlett-Packard Company makes no
                               : * representations about the suitability of this software for any
                               : * purpose.  It is provided "as is" without express or implied warranty.
                               : *
                               : *
                               : */
                               :
                               :/** @file bits/stl_tree.h
                               : *  This is an internal header file, included by other library headers.
                               : *  Do not attempt to use it directly. @headername{map,set}
                               : */
                               :
                               :#ifndef _STL_TREE_H
                               :#define _STL_TREE_H 1
                               :
                               :#include <bits/stl_algobase.h>
                               :#include <bits/allocator.h>
                               :#include <bits/stl_function.h>
                               :#include <bits/cpp_type_traits.h>
                               :#if __cplusplus >= 201103L
                               :#include <bits/alloc_traits.h>
                               :#endif
                               :
                               :namespace std _GLIBCXX_VISIBILITY(default)
                               :{
                               :_GLIBCXX_BEGIN_NAMESPACE_VERSION
                               :
                               :  // Red-black tree class, designed for use in implementing STL
                               :  // associative containers (set, multiset, map, and multimap). The
                               :  // insertion and deletion algorithms are based on those in Cormen,
                               :  // Leiserson, and Rivest, Introduction to Algorithms (MIT Press,
                               :  // 1990), except that
                               :  //
                               :  // (1) the header cell is maintained with links not only to the root
                               :  // but also to the leftmost node of the tree, to enable constant
                               :  // time begin(), and to the rightmost node of the tree, to enable
                               :  // linear time performance when used with the generic set algorithms
                               :  // (set_union, etc.)
                               :  // 
                               :  // (2) when a node being deleted has two children its successor node
                               :  // is relinked into its place, rather than copied, so that the only
                               :  // iterators invalidated are those referring to the deleted node.
                               :
                               :  enum _Rb_tree_color { _S_red = false, _S_black = true };
                               :
                               :  struct _Rb_tree_node_base
                               :  {
                               :    typedef _Rb_tree_node_base* _Base_ptr;
                               :    typedef const _Rb_tree_node_base* _Const_Base_ptr;
                               :
                               :    _Rb_tree_color	_M_color;
                               :    _Base_ptr		_M_parent;
                               :    _Base_ptr		_M_left;
                               :    _Base_ptr		_M_right;
                               :
                               :    static _Base_ptr
                               :    _S_minimum(_Base_ptr __x)
                               :    {
                               :      while (__x->_M_left != 0) __x = __x->_M_left;
                               :      return __x;
                               :    }
                               :
                               :    static _Const_Base_ptr
                               :    _S_minimum(_Const_Base_ptr __x)
                               :    {
                               :      while (__x->_M_left != 0) __x = __x->_M_left;
                               :      return __x;
                               :    }
                               :
                               :    static _Base_ptr
                               :    _S_maximum(_Base_ptr __x)
                               :    {
                               :      while (__x->_M_right != 0) __x = __x->_M_right;
                               :      return __x;
                               :    }
                               :
                               :    static _Const_Base_ptr
                               :    _S_maximum(_Const_Base_ptr __x)
                               :    {
                               :      while (__x->_M_right != 0) __x = __x->_M_right;
                               :      return __x;
                               :    }
                               :  };
                               :
                               :  template<typename _Val>
                               :    struct _Rb_tree_node : public _Rb_tree_node_base
                               :    {
                               :      typedef _Rb_tree_node<_Val>* _Link_type;
                               :      _Val _M_value_field;
                               :
                               :#if __cplusplus >= 201103L
                               :      template<typename... _Args>
                               :        _Rb_tree_node(_Args&&... __args)
                               :	: _Rb_tree_node_base(),
     4  0.0034     0       0   :	  _M_value_field(std::forward<_Args>(__args)...) { }
                               :#endif
                               :    };
                               :
                               :  _GLIBCXX_PURE _Rb_tree_node_base*
                               :  _Rb_tree_increment(_Rb_tree_node_base* __x) throw ();
                               :
                               :  _GLIBCXX_PURE const _Rb_tree_node_base*
                               :  _Rb_tree_increment(const _Rb_tree_node_base* __x) throw ();
                               :
                               :  _GLIBCXX_PURE _Rb_tree_node_base*
                               :  _Rb_tree_decrement(_Rb_tree_node_base* __x) throw ();
                               :
                               :  _GLIBCXX_PURE const _Rb_tree_node_base*
                               :  _Rb_tree_decrement(const _Rb_tree_node_base* __x) throw ();
                               :
                               :  template<typename _Tp>
                               :    struct _Rb_tree_iterator
                               :    {
                               :      typedef _Tp  value_type;
                               :      typedef _Tp& reference;
                               :      typedef _Tp* pointer;
                               :
                               :      typedef bidirectional_iterator_tag iterator_category;
                               :      typedef ptrdiff_t                  difference_type;
                               :
                               :      typedef _Rb_tree_iterator<_Tp>        _Self;
                               :      typedef _Rb_tree_node_base::_Base_ptr _Base_ptr;
                               :      typedef _Rb_tree_node<_Tp>*           _Link_type;
                               :
                               :      _Rb_tree_iterator()
                               :      : _M_node() { }
                               :
                               :      explicit
                               :      _Rb_tree_iterator(_Link_type __x)
                               :      : _M_node(__x) { }
                               :
                               :      reference
                               :      operator*() const
                               :      { return static_cast<_Link_type>(_M_node)->_M_value_field; }
                               :
                               :      pointer
                               :      operator->() const
                               :      { return std::__addressof(static_cast<_Link_type>
                               :				(_M_node)->_M_value_field); }
                               :
                               :      _Self&
                               :      operator++()
                               :      {
                               :	_M_node = _Rb_tree_increment(_M_node);
                               :	return *this;
                               :      }
                               :
                               :      _Self
                               :      operator++(int)
                               :      {
                               :	_Self __tmp = *this;
                               :	_M_node = _Rb_tree_increment(_M_node);
                               :	return __tmp;
                               :      }
                               :
                               :      _Self&
                               :      operator--()
                               :      {
                               :	_M_node = _Rb_tree_decrement(_M_node);
                               :	return *this;
                               :      }
                               :
                               :      _Self
                               :      operator--(int)
                               :      {
                               :	_Self __tmp = *this;
                               :	_M_node = _Rb_tree_decrement(_M_node);
                               :	return __tmp;
                               :      }
                               :
                               :      bool
                               :      operator==(const _Self& __x) const
                               :      { return _M_node == __x._M_node; }
                               :
                               :      bool
                               :      operator!=(const _Self& __x) const
                               :      { return _M_node != __x._M_node; }
                               :
                               :      _Base_ptr _M_node;
                               :  };
                               :
                               :  template<typename _Tp>
                               :    struct _Rb_tree_const_iterator
                               :    {
                               :      typedef _Tp        value_type;
                               :      typedef const _Tp& reference;
                               :      typedef const _Tp* pointer;
                               :
                               :      typedef _Rb_tree_iterator<_Tp> iterator;
                               :
                               :      typedef bidirectional_iterator_tag iterator_category;
                               :      typedef ptrdiff_t                  difference_type;
                               :
                               :      typedef _Rb_tree_const_iterator<_Tp>        _Self;
                               :      typedef _Rb_tree_node_base::_Const_Base_ptr _Base_ptr;
                               :      typedef const _Rb_tree_node<_Tp>*           _Link_type;
                               :
                               :      _Rb_tree_const_iterator()
                               :      : _M_node() { }
                               :
                               :      explicit
                               :      _Rb_tree_const_iterator(_Link_type __x)
                               :      : _M_node(__x) { }
                               :
                               :      _Rb_tree_const_iterator(const iterator& __it)
                               :      : _M_node(__it._M_node) { }
                               :
                               :      iterator
                               :      _M_const_cast() const
                               :      { return iterator(static_cast<typename iterator::_Link_type>
                               :			(const_cast<typename iterator::_Base_ptr>(_M_node))); }
                               :
                               :      reference
                               :      operator*() const
                               :      { return static_cast<_Link_type>(_M_node)->_M_value_field; }
                               :
                               :      pointer
                               :      operator->() const
                               :      { return std::__addressof(static_cast<_Link_type>
                               :				(_M_node)->_M_value_field); }
                               :
                               :      _Self&
                               :      operator++()
                               :      {
     3  0.0026     0       0   :	_M_node = _Rb_tree_increment(_M_node);
                               :	return *this;
                               :      }
                               :
                               :      _Self
                               :      operator++(int)
                               :      {
                               :	_Self __tmp = *this;
     5  0.0043     0       0   :	_M_node = _Rb_tree_increment(_M_node);
                               :	return __tmp;
                               :      }
                               :
                               :      _Self&
                               :      operator--()
                               :      {
                               :	_M_node = _Rb_tree_decrement(_M_node);
                               :	return *this;
                               :      }
                               :
                               :      _Self
                               :      operator--(int)
                               :      {
                               :	_Self __tmp = *this;
                               :	_M_node = _Rb_tree_decrement(_M_node);
                               :	return __tmp;
                               :      }
                               :
                               :      bool
                               :      operator==(const _Self& __x) const
                               :      { return _M_node == __x._M_node; }
                               :
                               :      bool
                               :      operator!=(const _Self& __x) const
                               :      { return _M_node != __x._M_node; }
                               :
                               :      _Base_ptr _M_node;
                               :    };
                               :
                               :  template<typename _Val>
                               :    inline bool
                               :    operator==(const _Rb_tree_iterator<_Val>& __x,
                               :               const _Rb_tree_const_iterator<_Val>& __y)
                               :    { return __x._M_node == __y._M_node; }
                               :
                               :  template<typename _Val>
                               :    inline bool
                               :    operator!=(const _Rb_tree_iterator<_Val>& __x,
                               :               const _Rb_tree_const_iterator<_Val>& __y)
                               :    { return __x._M_node != __y._M_node; }
                               :
                               :  void
                               :  _Rb_tree_insert_and_rebalance(const bool __insert_left,
                               :                                _Rb_tree_node_base* __x,
                               :                                _Rb_tree_node_base* __p,
                               :                                _Rb_tree_node_base& __header) throw ();
                               :
                               :  _Rb_tree_node_base*
                               :  _Rb_tree_rebalance_for_erase(_Rb_tree_node_base* const __z,
                               :			       _Rb_tree_node_base& __header) throw ();
                               :
                               :
                               :  template<typename _Key, typename _Val, typename _KeyOfValue,
                               :           typename _Compare, typename _Alloc = allocator<_Val> >
                               :    class _Rb_tree
                               :    {
                               :      typedef typename _Alloc::template rebind<_Rb_tree_node<_Val> >::other
                               :              _Node_allocator;
                               :
                               :    protected:
                               :      typedef _Rb_tree_node_base* 		_Base_ptr;
                               :      typedef const _Rb_tree_node_base* 	_Const_Base_ptr;
                               :
                               :    public:
                               :      typedef _Key 				key_type;
                               :      typedef _Val 				value_type;
                               :      typedef value_type* 			pointer;
                               :      typedef const value_type* 		const_pointer;
                               :      typedef value_type& 			reference;
                               :      typedef const value_type& 		const_reference;
                               :      typedef _Rb_tree_node<_Val>* 		_Link_type;
                               :      typedef const _Rb_tree_node<_Val>*	_Const_Link_type;
                               :      typedef size_t 				size_type;
                               :      typedef ptrdiff_t 			difference_type;
                               :      typedef _Alloc 				allocator_type;
                               :
                               :      _Node_allocator&
                               :      _M_get_Node_allocator() _GLIBCXX_NOEXCEPT
                               :      { return *static_cast<_Node_allocator*>(&this->_M_impl); }
                               :      
                               :      const _Node_allocator&
                               :      _M_get_Node_allocator() const _GLIBCXX_NOEXCEPT
                               :      { return *static_cast<const _Node_allocator*>(&this->_M_impl); }
                               :
                               :      allocator_type
                               :      get_allocator() const _GLIBCXX_NOEXCEPT
                               :      { return allocator_type(_M_get_Node_allocator()); }
                               :
                               :    protected:
                               :      _Link_type
                               :      _M_get_node()
                               :      { return _M_impl._Node_allocator::allocate(1); }
                               :
                               :      void
                               :      _M_put_node(_Link_type __p)
                               :      { _M_impl._Node_allocator::deallocate(__p, 1); }
                               :
                               :#if __cplusplus < 201103L
                               :      _Link_type
                               :      _M_create_node(const value_type& __x)
                               :      {
                               :	_Link_type __tmp = _M_get_node();
                               :	__try
                               :	  { get_allocator().construct
                               :	      (std::__addressof(__tmp->_M_value_field), __x); }
                               :	__catch(...)
                               :	  {
                               :	    _M_put_node(__tmp);
                               :	    __throw_exception_again;
                               :	  }
                               :	return __tmp;
                               :      }
                               :
                               :      void
                               :      _M_destroy_node(_Link_type __p)
                               :      {
                               :	get_allocator().destroy(std::__addressof(__p->_M_value_field));
                               :	_M_put_node(__p);
                               :      }
                               :#else
                               :      template<typename... _Args>
                               :        _Link_type
                               :        _M_create_node(_Args&&... __args)
                               :	{
                               :	  _Link_type __tmp = _M_get_node();
                               :	  __try
                               :	    {
                               :	      allocator_traits<_Node_allocator>::
                               :		construct(_M_get_Node_allocator(), __tmp,
                               :			  std::forward<_Args>(__args)...);
                               :	    }
                               :	  __catch(...)
                               :	    {
                               :	      _M_put_node(__tmp);
                               :	      __throw_exception_again;
                               :	    }
                               :	  return __tmp;
                               :	}
                               :
                               :      void
                               :      _M_destroy_node(_Link_type __p)
                               :      {
                               :	_M_get_Node_allocator().destroy(__p);
                               :	_M_put_node(__p);
                               :      }
                               :#endif
                               :
                               :      _Link_type
                               :      _M_clone_node(_Const_Link_type __x)
                               :      {
                               :	_Link_type __tmp = _M_create_node(__x->_M_value_field);
                               :	__tmp->_M_color = __x->_M_color;
                               :	__tmp->_M_left = 0;
                               :	__tmp->_M_right = 0;
                               :	return __tmp;
                               :      }
                               :
                               :    protected:
                               :      template<typename _Key_compare, 
                               :	       bool _Is_pod_comparator = __is_pod(_Key_compare)>
                               :        struct _Rb_tree_impl : public _Node_allocator
                               :        {
                               :	  _Key_compare		_M_key_compare;
                               :	  _Rb_tree_node_base 	_M_header;
                               :	  size_type 		_M_node_count; // Keeps track of size of tree.
                               :
                               :	  _Rb_tree_impl()
                               :	  : _Node_allocator(), _M_key_compare(), _M_header(),
                               :	    _M_node_count(0)
                               :	  { _M_initialize(); }
                               :
                               :	  _Rb_tree_impl(const _Key_compare& __comp, const _Node_allocator& __a)
                               :	  : _Node_allocator(__a), _M_key_compare(__comp), _M_header(),
                               :	    _M_node_count(0)
                               :	  { _M_initialize(); }
                               :
                               :#if __cplusplus >= 201103L
                               :	  _Rb_tree_impl(const _Key_compare& __comp, _Node_allocator&& __a)
                               :	  : _Node_allocator(std::move(__a)), _M_key_compare(__comp),
                               :	    _M_header(), _M_node_count(0)
                               :	  { _M_initialize(); }
                               :#endif
                               :
                               :	private:
                               :	  void
                               :	  _M_initialize()
                               :	  {
                               :	    this->_M_header._M_color = _S_red;
                               :	    this->_M_header._M_parent = 0;
                               :	    this->_M_header._M_left = &this->_M_header;
                               :	    this->_M_header._M_right = &this->_M_header;
                               :	  }	    
                               :	};
                               :
                               :      _Rb_tree_impl<_Compare> _M_impl;
                               :
                               :    protected:
                               :      _Base_ptr&
                               :      _M_root()
                               :      { return this->_M_impl._M_header._M_parent; }
                               :
                               :      _Const_Base_ptr
                               :      _M_root() const
                               :      { return this->_M_impl._M_header._M_parent; }
                               :
                               :      _Base_ptr&
                               :      _M_leftmost()
                               :      { return this->_M_impl._M_header._M_left; }
                               :
                               :      _Const_Base_ptr
                               :      _M_leftmost() const
                               :      { return this->_M_impl._M_header._M_left; }
                               :
                               :      _Base_ptr&
                               :      _M_rightmost()
                               :      { return this->_M_impl._M_header._M_right; }
                               :
                               :      _Const_Base_ptr
                               :      _M_rightmost() const
                               :      { return this->_M_impl._M_header._M_right; }
                               :
                               :      _Link_type
                               :      _M_begin()
                               :      { return static_cast<_Link_type>(this->_M_impl._M_header._M_parent); }
                               :
                               :      _Const_Link_type
                               :      _M_begin() const
                               :      {
                               :	return static_cast<_Const_Link_type>
                               :	  (this->_M_impl._M_header._M_parent);
                               :      }
                               :
                               :      _Link_type
                               :      _M_end()
                               :      { return static_cast<_Link_type>(&this->_M_impl._M_header); }
                               :
                               :      _Const_Link_type
                               :      _M_end() const
                               :      { return static_cast<_Const_Link_type>(&this->_M_impl._M_header); }
                               :
                               :      static const_reference
                               :      _S_value(_Const_Link_type __x)
                               :      { return __x->_M_value_field; }
                               :
                               :      static const _Key&
                               :      _S_key(_Const_Link_type __x)
                               :      { return _KeyOfValue()(_S_value(__x)); }
                               :
                               :      static _Link_type
                               :      _S_left(_Base_ptr __x)
                               :      { return static_cast<_Link_type>(__x->_M_left); }
                               :
                               :      static _Const_Link_type
                               :      _S_left(_Const_Base_ptr __x)
                               :      { return static_cast<_Const_Link_type>(__x->_M_left); }
                               :
                               :      static _Link_type
                               :      _S_right(_Base_ptr __x)
                               :      { return static_cast<_Link_type>(__x->_M_right); }
                               :
                               :      static _Const_Link_type
                               :      _S_right(_Const_Base_ptr __x)
                               :      { return static_cast<_Const_Link_type>(__x->_M_right); }
                               :
                               :      static const_reference
                               :      _S_value(_Const_Base_ptr __x)
                               :      { return static_cast<_Const_Link_type>(__x)->_M_value_field; }
                               :
                               :      static const _Key&
                               :      _S_key(_Const_Base_ptr __x)
                               :      { return _KeyOfValue()(_S_value(__x)); }
                               :
                               :      static _Base_ptr
                               :      _S_minimum(_Base_ptr __x)
                               :      { return _Rb_tree_node_base::_S_minimum(__x); }
                               :
                               :      static _Const_Base_ptr
                               :      _S_minimum(_Const_Base_ptr __x)
                               :      { return _Rb_tree_node_base::_S_minimum(__x); }
                               :
                               :      static _Base_ptr
                               :      _S_maximum(_Base_ptr __x)
                               :      { return _Rb_tree_node_base::_S_maximum(__x); }
                               :
                               :      static _Const_Base_ptr
                               :      _S_maximum(_Const_Base_ptr __x)
                               :      { return _Rb_tree_node_base::_S_maximum(__x); }
                               :
                               :    public:
                               :      typedef _Rb_tree_iterator<value_type>       iterator;
                               :      typedef _Rb_tree_const_iterator<value_type> const_iterator;
                               :
                               :      typedef std::reverse_iterator<iterator>       reverse_iterator;
                               :      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
                               :
                               :    private:
                               :      pair<_Base_ptr, _Base_ptr>
                               :      _M_get_insert_unique_pos(const key_type& __k);
                               :
                               :      pair<_Base_ptr, _Base_ptr>
                               :      _M_get_insert_equal_pos(const key_type& __k);
                               :
                               :      pair<_Base_ptr, _Base_ptr>
                               :      _M_get_insert_hint_unique_pos(const_iterator __pos,
                               :				    const key_type& __k);
                               :
                               :      pair<_Base_ptr, _Base_ptr>
                               :      _M_get_insert_hint_equal_pos(const_iterator __pos,
                               :				   const key_type& __k);
                               :
                               :#if __cplusplus >= 201103L
                               :      template<typename _Arg>
                               :        iterator
                               :        _M_insert_(_Base_ptr __x, _Base_ptr __y, _Arg&& __v);
                               :
                               :      iterator
                               :      _M_insert_node(_Base_ptr __x, _Base_ptr __y, _Link_type __z);
                               :
                               :      template<typename _Arg>
                               :        iterator
                               :        _M_insert_lower(_Base_ptr __y, _Arg&& __v);
                               :
                               :      template<typename _Arg>
                               :        iterator
                               :        _M_insert_equal_lower(_Arg&& __x);
                               :
                               :      iterator
                               :      _M_insert_lower_node(_Base_ptr __p, _Link_type __z);
                               :
                               :      iterator
                               :      _M_insert_equal_lower_node(_Link_type __z);
                               :#else
                               :      iterator
                               :      _M_insert_(_Base_ptr __x, _Base_ptr __y,
                               :		 const value_type& __v);
                               :
                               :      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                               :      // 233. Insertion hints in associative containers.
                               :      iterator
                               :      _M_insert_lower(_Base_ptr __y, const value_type& __v);
                               :
                               :      iterator
                               :      _M_insert_equal_lower(const value_type& __x);
                               :#endif
                               :
                               :      _Link_type
                               :      _M_copy(_Const_Link_type __x, _Link_type __p);
                               :
                               :      void
                               :      _M_erase(_Link_type __x);
                               :
                               :      iterator
                               :      _M_lower_bound(_Link_type __x, _Link_type __y,
                               :		     const _Key& __k);
                               :
                               :      const_iterator
                               :      _M_lower_bound(_Const_Link_type __x, _Const_Link_type __y,
                               :		     const _Key& __k) const;
                               :
                               :      iterator
                               :      _M_upper_bound(_Link_type __x, _Link_type __y,
                               :		     const _Key& __k);
                               :
                               :      const_iterator
                               :      _M_upper_bound(_Const_Link_type __x, _Const_Link_type __y,
                               :		     const _Key& __k) const;
                               :
                               :    public:
                               :      // allocation/deallocation
                               :      _Rb_tree() { }
                               :
                               :      _Rb_tree(const _Compare& __comp,
                               :	       const allocator_type& __a = allocator_type())
                               :      : _M_impl(__comp, _Node_allocator(__a)) { }
                               :
                               :      _Rb_tree(const _Rb_tree& __x)
                               :      : _M_impl(__x._M_impl._M_key_compare, __x._M_get_Node_allocator())
                               :      {
                               :	if (__x._M_root() != 0)
                               :	  {
                               :	    _M_root() = _M_copy(__x._M_begin(), _M_end());
                               :	    _M_leftmost() = _S_minimum(_M_root());
                               :	    _M_rightmost() = _S_maximum(_M_root());
                               :	    _M_impl._M_node_count = __x._M_impl._M_node_count;
                               :	  }
                               :      }
                               :
                               :#if __cplusplus >= 201103L
                               :      _Rb_tree(_Rb_tree&& __x);
                               :#endif
                               :
                               :      ~_Rb_tree() _GLIBCXX_NOEXCEPT
                               :      { _M_erase(_M_begin()); }
                               :
                               :      _Rb_tree&
                               :      operator=(const _Rb_tree& __x);
                               :
                               :      // Accessors.
                               :      _Compare
                               :      key_comp() const
                               :      { return _M_impl._M_key_compare; }
                               :
                               :      iterator
                               :      begin() _GLIBCXX_NOEXCEPT
                               :      { 
                               :	return iterator(static_cast<_Link_type>
                               :			(this->_M_impl._M_header._M_left));
                               :      }
                               :
                               :      const_iterator
                               :      begin() const _GLIBCXX_NOEXCEPT
                               :      { 
                               :	return const_iterator(static_cast<_Const_Link_type>
                               :			      (this->_M_impl._M_header._M_left));
                               :      }
                               :
                               :      iterator
                               :      end() _GLIBCXX_NOEXCEPT
                               :      { return iterator(static_cast<_Link_type>(&this->_M_impl._M_header)); }
                               :
                               :      const_iterator
                               :      end() const _GLIBCXX_NOEXCEPT
                               :      { 
                               :	return const_iterator(static_cast<_Const_Link_type>
     9  0.0077     0       0   :			      (&this->_M_impl._M_header));
                               :      }
                               :
                               :      reverse_iterator
                               :      rbegin() _GLIBCXX_NOEXCEPT
                               :      { return reverse_iterator(end()); }
                               :
                               :      const_reverse_iterator
                               :      rbegin() const _GLIBCXX_NOEXCEPT
                               :      { return const_reverse_iterator(end()); }
                               :
                               :      reverse_iterator
                               :      rend() _GLIBCXX_NOEXCEPT
                               :      { return reverse_iterator(begin()); }
                               :
                               :      const_reverse_iterator
                               :      rend() const _GLIBCXX_NOEXCEPT
                               :      { return const_reverse_iterator(begin()); }
                               :
                               :      bool
                               :      empty() const _GLIBCXX_NOEXCEPT
                               :      { return _M_impl._M_node_count == 0; }
                               :
                               :      size_type
                               :      size() const _GLIBCXX_NOEXCEPT 
                               :      { return _M_impl._M_node_count; }
                               :
                               :      size_type
                               :      max_size() const _GLIBCXX_NOEXCEPT
                               :      { return _M_get_Node_allocator().max_size(); }
                               :
                               :      void
                               :      swap(_Rb_tree& __t);      
                               :
                               :      // Insert/erase.
                               :#if __cplusplus >= 201103L
                               :      template<typename _Arg>
                               :        pair<iterator, bool>
                               :        _M_insert_unique(_Arg&& __x);
                               :
                               :      template<typename _Arg>
                               :        iterator
                               :        _M_insert_equal(_Arg&& __x);
                               :
                               :      template<typename _Arg>
                               :        iterator
                               :        _M_insert_unique_(const_iterator __position, _Arg&& __x);
                               :
                               :      template<typename _Arg>
                               :        iterator
                               :        _M_insert_equal_(const_iterator __position, _Arg&& __x);
                               :
                               :      template<typename... _Args>
                               :	pair<iterator, bool>
                               :	_M_emplace_unique(_Args&&... __args);
                               :
                               :      template<typename... _Args>
                               :	iterator
                               :	_M_emplace_equal(_Args&&... __args);
                               :
                               :      template<typename... _Args>
                               :	iterator
                               :	_M_emplace_hint_unique(const_iterator __pos, _Args&&... __args);
                               :
                               :      template<typename... _Args>
                               :	iterator
                               :	_M_emplace_hint_equal(const_iterator __pos, _Args&&... __args);
                               :#else
                               :      pair<iterator, bool>
                               :      _M_insert_unique(const value_type& __x);
                               :
                               :      iterator
                               :      _M_insert_equal(const value_type& __x);
                               :
                               :      iterator
                               :      _M_insert_unique_(const_iterator __position, const value_type& __x);
                               :
                               :      iterator
                               :      _M_insert_equal_(const_iterator __position, const value_type& __x);
                               :#endif
                               :
                               :      template<typename _InputIterator>
                               :        void
                               :        _M_insert_unique(_InputIterator __first, _InputIterator __last);
                               :
                               :      template<typename _InputIterator>
                               :        void
                               :        _M_insert_equal(_InputIterator __first, _InputIterator __last);
                               :
                               :    private:
                               :      void
                               :      _M_erase_aux(const_iterator __position);
                               :
                               :      void
                               :      _M_erase_aux(const_iterator __first, const_iterator __last);
                               :
                               :    public:
                               :#if __cplusplus >= 201103L
                               :      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                               :      // DR 130. Associative erase should return an iterator.
                               :      _GLIBCXX_ABI_TAG_CXX11
                               :      iterator
                               :      erase(const_iterator __position)
                               :      {
                               :	const_iterator __result = __position;
                               :	++__result;
                               :	_M_erase_aux(__position);
                               :	return __result._M_const_cast();
                               :      }
                               :
                               :      // LWG 2059.
                               :      _GLIBCXX_ABI_TAG_CXX11
                               :      iterator
                               :      erase(iterator __position)
                               :      {
                               :	iterator __result = __position;
                               :	++__result;
                               :	_M_erase_aux(__position);
                               :	return __result;
                               :      }
                               :#else
                               :      void
                               :      erase(iterator __position)
                               :      { _M_erase_aux(__position); }
                               :
                               :      void
                               :      erase(const_iterator __position)
                               :      { _M_erase_aux(__position); }
                               :#endif
                               :      size_type
                               :      erase(const key_type& __x);
                               :
                               :#if __cplusplus >= 201103L
                               :      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                               :      // DR 130. Associative erase should return an iterator.
                               :      _GLIBCXX_ABI_TAG_CXX11
                               :      iterator
                               :      erase(const_iterator __first, const_iterator __last)
                               :      {
                               :	_M_erase_aux(__first, __last);
                               :	return __last._M_const_cast();
                               :      }
                               :#else
                               :      void
                               :      erase(iterator __first, iterator __last)
                               :      { _M_erase_aux(__first, __last); }
                               :
                               :      void
                               :      erase(const_iterator __first, const_iterator __last)
                               :      { _M_erase_aux(__first, __last); }
                               :#endif
                               :      void
                               :      erase(const key_type* __first, const key_type* __last);
                               :
                               :      void
                               :      clear() _GLIBCXX_NOEXCEPT
                               :      {
                               :        _M_erase(_M_begin());
                               :        _M_leftmost() = _M_end();
                               :        _M_root() = 0;
                               :        _M_rightmost() = _M_end();
                               :        _M_impl._M_node_count = 0;
                               :      }
                               :
                               :      // Set operations.
                               :      iterator
                               :      find(const key_type& __k);
                               :
                               :      const_iterator
                               :      find(const key_type& __k) const;
                               :
                               :      size_type
                               :      count(const key_type& __k) const;
                               :
                               :      iterator
                               :      lower_bound(const key_type& __k)
                               :      { return _M_lower_bound(_M_begin(), _M_end(), __k); }
                               :
                               :      const_iterator
                               :      lower_bound(const key_type& __k) const
                               :      { return _M_lower_bound(_M_begin(), _M_end(), __k); }
                               :
                               :      iterator
                               :      upper_bound(const key_type& __k)
                               :      { return _M_upper_bound(_M_begin(), _M_end(), __k); }
                               :
                               :      const_iterator
                               :      upper_bound(const key_type& __k) const
                               :      { return _M_upper_bound(_M_begin(), _M_end(), __k); }
                               :
                               :      pair<iterator, iterator>
                               :      equal_range(const key_type& __k);
                               :
                               :      pair<const_iterator, const_iterator>
                               :      equal_range(const key_type& __k) const;
                               :
                               :      // Debugging.
                               :      bool
                               :      __rb_verify() const;
                               :    };
                               :
                               :  template<typename _Key, typename _Val, typename _KeyOfValue,
                               :           typename _Compare, typename _Alloc>
                               :    inline bool
                               :    operator==(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
                               :	       const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
                               :    {
                               :      return __x.size() == __y.size()
                               :	     && std::equal(__x.begin(), __x.end(), __y.begin());
                               :    }
                               :
                               :  template<typename _Key, typename _Val, typename _KeyOfValue,
                               :           typename _Compare, typename _Alloc>
                               :    inline bool
                               :    operator<(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
                               :	      const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
                               :    {
                               :      return std::lexicographical_compare(__x.begin(), __x.end(), 
                               :					  __y.begin(), __y.end());
                               :    }
                               :
                               :  template<typename _Key, typename _Val, typename _KeyOfValue,
                               :           typename _Compare, typename _Alloc>
                               :    inline bool
                               :    operator!=(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
                               :	       const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
                               :    { return !(__x == __y); }
                               :
                               :  template<typename _Key, typename _Val, typename _KeyOfValue,
                               :           typename _Compare, typename _Alloc>
                               :    inline bool
                               :    operator>(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
                               :	      const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
                               :    { return __y < __x; }
                               :
                               :  template<typename _Key, typename _Val, typename _KeyOfValue,
                               :           typename _Compare, typename _Alloc>
                               :    inline bool
                               :    operator<=(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
                               :	       const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
                               :    { return !(__y < __x); }
                               :
                               :  template<typename _Key, typename _Val, typename _KeyOfValue,
                               :           typename _Compare, typename _Alloc>
                               :    inline bool
                               :    operator>=(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
                               :	       const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
                               :    { return !(__x < __y); }
                               :
                               :  template<typename _Key, typename _Val, typename _KeyOfValue,
                               :           typename _Compare, typename _Alloc>
                               :    inline void
                               :    swap(_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
                               :	 _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
                               :    { __x.swap(__y); }
                               :
                               :#if __cplusplus >= 201103L
                               :  template<typename _Key, typename _Val, typename _KeyOfValue,
                               :           typename _Compare, typename _Alloc>
                               :    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                               :    _Rb_tree(_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>&& __x)
                               :    : _M_impl(__x._M_impl._M_key_compare,
                               :	      std::move(__x._M_get_Node_allocator()))
                               :    {
                               :      if (__x._M_root() != 0)
                               :	{
                               :	  _M_root() = __x._M_root();
                               :	  _M_leftmost() = __x._M_leftmost();
                               :	  _M_rightmost() = __x._M_rightmost();
                               :	  _M_root()->_M_parent = _M_end();
                               :
                               :	  __x._M_root() = 0;
                               :	  __x._M_leftmost() = __x._M_end();
                               :	  __x._M_rightmost() = __x._M_end();
                               :
                               :	  this->_M_impl._M_node_count = __x._M_impl._M_node_count;
                               :	  __x._M_impl._M_node_count = 0;
                               :	}
                               :    }
                               :#endif
                               :
                               :  template<typename _Key, typename _Val, typename _KeyOfValue,
                               :           typename _Compare, typename _Alloc>
                               :    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>&
                               :    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                               :    operator=(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x)
                               :    {
                               :      if (this != &__x)
                               :	{
                               :	  // Note that _Key may be a constant type.
                               :	  clear();
                               :	  _M_impl._M_key_compare = __x._M_impl._M_key_compare;
                               :	  if (__x._M_root() != 0)
                               :	    {
                               :	      _M_root() = _M_copy(__x._M_begin(), _M_end());
                               :	      _M_leftmost() = _S_minimum(_M_root());
                               :	      _M_rightmost() = _S_maximum(_M_root());
                               :	      _M_impl._M_node_count = __x._M_impl._M_node_count;
                               :	    }
                               :	}
                               :      return *this;
                               :    }
                               :
                               :  template<typename _Key, typename _Val, typename _KeyOfValue,
                               :           typename _Compare, typename _Alloc>
                               :#if __cplusplus >= 201103L
                               :    template<typename _Arg>
                               :#endif
                               :    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
                               :    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                               :#if __cplusplus >= 201103L
                               :    _M_insert_(_Base_ptr __x, _Base_ptr __p, _Arg&& __v)
                               :#else
                               :    _M_insert_(_Base_ptr __x, _Base_ptr __p, const _Val& __v)
                               :#endif
                               :    {
                               :      bool __insert_left = (__x != 0 || __p == _M_end()
                               :			    || _M_impl._M_key_compare(_KeyOfValue()(__v),
     6  0.0051     0       0   :						      _S_key(__p)));
                               :
                               :      _Link_type __z = _M_create_node(_GLIBCXX_FORWARD(_Arg, __v));
                               :
     2  0.0017     0       0   :      _Rb_tree_insert_and_rebalance(__insert_left, __z, __p,
                               :				    this->_M_impl._M_header);
                               :      ++_M_impl._M_node_count;
                               :      return iterator(__z);
                               :    }
                               :
                               :  template<typename _Key, typename _Val, typename _KeyOfValue,
                               :           typename _Compare, typename _Alloc>
                               :#if __cplusplus >= 201103L
                               :    template<typename _Arg>
                               :#endif
                               :    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
                               :    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                               :#if __cplusplus >= 201103L
                               :    _M_insert_lower(_Base_ptr __p, _Arg&& __v)
                               :#else
                               :    _M_insert_lower(_Base_ptr __p, const _Val& __v)
                               :#endif
                               :    {
                               :      bool __insert_left = (__p == _M_end()
                               :			    || !_M_impl._M_key_compare(_S_key(__p),
                               :						       _KeyOfValue()(__v)));
                               :
                               :      _Link_type __z = _M_create_node(_GLIBCXX_FORWARD(_Arg, __v));
                               :
                               :      _Rb_tree_insert_and_rebalance(__insert_left, __z, __p,
                               :				    this->_M_impl._M_header);
                               :      ++_M_impl._M_node_count;
                               :      return iterator(__z);
                               :    }
                               :
                               :  template<typename _Key, typename _Val, typename _KeyOfValue,
                               :           typename _Compare, typename _Alloc>
                               :#if __cplusplus >= 201103L
                               :    template<typename _Arg>
                               :#endif
                               :    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
                               :    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                               :#if __cplusplus >= 201103L
                               :    _M_insert_equal_lower(_Arg&& __v)
                               :#else
                               :    _M_insert_equal_lower(const _Val& __v)
                               :#endif
                               :    {
                               :      _Link_type __x = _M_begin();
                               :      _Link_type __y = _M_end();
                               :      while (__x != 0)
                               :	{
                               :	  __y = __x;
                               :	  __x = !_M_impl._M_key_compare(_S_key(__x), _KeyOfValue()(__v)) ?
                               :	        _S_left(__x) : _S_right(__x);
                               :	}
                               :      return _M_insert_lower(__y, _GLIBCXX_FORWARD(_Arg, __v));
                               :    }
                               :
                               :  template<typename _Key, typename _Val, typename _KoV,
                               :           typename _Compare, typename _Alloc>
                               :    typename _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::_Link_type
                               :    _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::
                               :    _M_copy(_Const_Link_type __x, _Link_type __p)
                               :    {
                               :      // Structural copy.  __x and __p must be non-null.
                               :      _Link_type __top = _M_clone_node(__x);
                               :      __top->_M_parent = __p;
                               :
                               :      __try
                               :	{
                               :	  if (__x->_M_right)
                               :	    __top->_M_right = _M_copy(_S_right(__x), __top);
                               :	  __p = __top;
                               :	  __x = _S_left(__x);
                               :
                               :	  while (__x != 0)
                               :	    {
                               :	      _Link_type __y = _M_clone_node(__x);
                               :	      __p->_M_left = __y;
                               :	      __y->_M_parent = __p;
                               :	      if (__x->_M_right)
                               :		__y->_M_right = _M_copy(_S_right(__x), __y);
                               :	      __p = __y;
                               :	      __x = _S_left(__x);
                               :	    }
                               :	}
                               :      __catch(...)
                               :	{
                               :	  _M_erase(__top);
                               :	  __throw_exception_again;
                               :	}
                               :      return __top;
                               :    }
                               :
                               :  template<typename _Key, typename _Val, typename _KeyOfValue,
                               :           typename _Compare, typename _Alloc>
                               :    void
     2  0.0017     0       0   :    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>:: /* std::_Rb_tree<int, int, std::_Identity<int>, std::less<int>, std::allocator<int> >::_M_erase(std::_Rb_tree_node<int>*) total:    108  0.0919     5  0.2953 */
     3  0.0026     0       0   :    _M_erase(_Link_type __x)
                               :    {
                               :      // Erase without rebalancing.
   100  0.0851     4  0.2363   :      while (__x != 0)
                               :	{
    35  0.0298     2  0.1181   :	  _M_erase(_S_right(__x));
                               :	  _Link_type __y = _S_left(__x);
                               :	  _M_destroy_node(__x);
     2  0.0017     0       0   :	  __x = __y;
                               :	}
     2  0.0017     1  0.0591   :    }
                               :
                               :  template<typename _Key, typename _Val, typename _KeyOfValue,
                               :           typename _Compare, typename _Alloc>
                               :    typename _Rb_tree<_Key, _Val, _KeyOfValue,
                               :		      _Compare, _Alloc>::iterator
                               :    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
   175  0.1489     0       0   :    _M_lower_bound(_Link_type __x, _Link_type __y,
                               :		   const _Key& __k)
                               :    {
    30  0.0255     0       0   :      while (__x != 0)
    16  0.0136     0       0   :	if (!_M_impl._M_key_compare(_S_key(__x), __k))
    11  0.0094     0       0   :	  __y = __x, __x = _S_left(__x);
                               :	else
                               :	  __x = _S_right(__x);
                               :      return iterator(__y);
                               :    }
                               :
                               :  template<typename _Key, typename _Val, typename _KeyOfValue,
                               :           typename _Compare, typename _Alloc>
                               :    typename _Rb_tree<_Key, _Val, _KeyOfValue,
                               :		      _Compare, _Alloc>::const_iterator
                               :    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                               :    _M_lower_bound(_Const_Link_type __x, _Const_Link_type __y,
                               :		   const _Key& __k) const
                               :    {
                               :      while (__x != 0)
                               :	if (!_M_impl._M_key_compare(_S_key(__x), __k))
                               :	  __y = __x, __x = _S_left(__x);
                               :	else
                               :	  __x = _S_right(__x);
                               :      return const_iterator(__y);
                               :    }
                               :
                               :  template<typename _Key, typename _Val, typename _KeyOfValue,
                               :           typename _Compare, typename _Alloc>
                               :    typename _Rb_tree<_Key, _Val, _KeyOfValue,
                               :		      _Compare, _Alloc>::iterator
                               :    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                               :    _M_upper_bound(_Link_type __x, _Link_type __y,
                               :		   const _Key& __k)
                               :    {
                               :      while (__x != 0)
                               :	if (_M_impl._M_key_compare(__k, _S_key(__x)))
                               :	  __y = __x, __x = _S_left(__x);
                               :	else
                               :	  __x = _S_right(__x);
                               :      return iterator(__y);
                               :    }
                               :
                               :  template<typename _Key, typename _Val, typename _KeyOfValue,
                               :           typename _Compare, typename _Alloc>
                               :    typename _Rb_tree<_Key, _Val, _KeyOfValue,
                               :		      _Compare, _Alloc>::const_iterator
                               :    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                               :    _M_upper_bound(_Const_Link_type __x, _Const_Link_type __y,
                               :		   const _Key& __k) const
                               :    {
                               :      while (__x != 0)
                               :	if (_M_impl._M_key_compare(__k, _S_key(__x)))
                               :	  __y = __x, __x = _S_left(__x);
                               :	else
                               :	  __x = _S_right(__x);
                               :      return const_iterator(__y);
                               :    }
                               :
                               :  template<typename _Key, typename _Val, typename _KeyOfValue,
                               :           typename _Compare, typename _Alloc>
                               :    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
                               :			   _Compare, _Alloc>::iterator,
                               :	 typename _Rb_tree<_Key, _Val, _KeyOfValue,
                               :			   _Compare, _Alloc>::iterator>
                               :    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                               :    equal_range(const _Key& __k)
                               :    {
                               :      _Link_type __x = _M_begin();
                               :      _Link_type __y = _M_end();
                               :      while (__x != 0)
                               :	{
                               :	  if (_M_impl._M_key_compare(_S_key(__x), __k))
                               :	    __x = _S_right(__x);
                               :	  else if (_M_impl._M_key_compare(__k, _S_key(__x)))
                               :	    __y = __x, __x = _S_left(__x);
                               :	  else
                               :	    {
                               :	      _Link_type __xu(__x), __yu(__y);
                               :	      __y = __x, __x = _S_left(__x);
                               :	      __xu = _S_right(__xu);
                               :	      return pair<iterator,
                               :		          iterator>(_M_lower_bound(__x, __y, __k),
                               :				    _M_upper_bound(__xu, __yu, __k));
                               :	    }
                               :	}
                               :      return pair<iterator, iterator>(iterator(__y),
                               :				      iterator(__y));
                               :    }
                               :
                               :  template<typename _Key, typename _Val, typename _KeyOfValue,
                               :           typename _Compare, typename _Alloc>
                               :    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
                               :			   _Compare, _Alloc>::const_iterator,
                               :	 typename _Rb_tree<_Key, _Val, _KeyOfValue,
                               :			   _Compare, _Alloc>::const_iterator>
                               :    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                               :    equal_range(const _Key& __k) const
                               :    {
                               :      _Const_Link_type __x = _M_begin();
                               :      _Const_Link_type __y = _M_end();
                               :      while (__x != 0)
                               :	{
                               :	  if (_M_impl._M_key_compare(_S_key(__x), __k))
                               :	    __x = _S_right(__x);
                               :	  else if (_M_impl._M_key_compare(__k, _S_key(__x)))
                               :	    __y = __x, __x = _S_left(__x);
                               :	  else
                               :	    {
                               :	      _Const_Link_type __xu(__x), __yu(__y);
                               :	      __y = __x, __x = _S_left(__x);
                               :	      __xu = _S_right(__xu);
                               :	      return pair<const_iterator,
                               :		          const_iterator>(_M_lower_bound(__x, __y, __k),
                               :					  _M_upper_bound(__xu, __yu, __k));
                               :	    }
                               :	}
                               :      return pair<const_iterator, const_iterator>(const_iterator(__y),
                               :						  const_iterator(__y));
                               :    }
                               :
                               :  template<typename _Key, typename _Val, typename _KeyOfValue,
                               :           typename _Compare, typename _Alloc>
                               :    void
                               :    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                               :    swap(_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __t)
                               :    {
                               :      if (_M_root() == 0)
                               :	{
                               :	  if (__t._M_root() != 0)
                               :	    {
                               :	      _M_root() = __t._M_root();
                               :	      _M_leftmost() = __t._M_leftmost();
                               :	      _M_rightmost() = __t._M_rightmost();
                               :	      _M_root()->_M_parent = _M_end();
                               :	      
                               :	      __t._M_root() = 0;
                               :	      __t._M_leftmost() = __t._M_end();
                               :	      __t._M_rightmost() = __t._M_end();
                               :	    }
                               :	}
                               :      else if (__t._M_root() == 0)
                               :	{
                               :	  __t._M_root() = _M_root();
                               :	  __t._M_leftmost() = _M_leftmost();
                               :	  __t._M_rightmost() = _M_rightmost();
                               :	  __t._M_root()->_M_parent = __t._M_end();
                               :	  
                               :	  _M_root() = 0;
                               :	  _M_leftmost() = _M_end();
                               :	  _M_rightmost() = _M_end();
                               :	}
                               :      else
                               :	{
                               :	  std::swap(_M_root(),__t._M_root());
                               :	  std::swap(_M_leftmost(),__t._M_leftmost());
                               :	  std::swap(_M_rightmost(),__t._M_rightmost());
                               :	  
                               :	  _M_root()->_M_parent = _M_end();
                               :	  __t._M_root()->_M_parent = __t._M_end();
                               :	}
                               :      // No need to swap header's color as it does not change.
                               :      std::swap(this->_M_impl._M_node_count, __t._M_impl._M_node_count);
                               :      std::swap(this->_M_impl._M_key_compare, __t._M_impl._M_key_compare);
                               :      
                               :      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                               :      // 431. Swapping containers with unequal allocators.
                               :      std::__alloc_swap<_Node_allocator>::
                               :	_S_do_it(_M_get_Node_allocator(), __t._M_get_Node_allocator());
                               :    }
                               :
                               :  template<typename _Key, typename _Val, typename _KeyOfValue,
                               :           typename _Compare, typename _Alloc>
                               :    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
                               :			   _Compare, _Alloc>::_Base_ptr,
                               :	 typename _Rb_tree<_Key, _Val, _KeyOfValue,
                               :			   _Compare, _Alloc>::_Base_ptr>
                               :    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
     2  0.0017     0       0   :    _M_get_insert_unique_pos(const key_type& __k)
                               :    {
                               :      typedef pair<_Base_ptr, _Base_ptr> _Res;
                               :      _Link_type __x = _M_begin();
    26  0.0221     1  0.0591   :      _Link_type __y = _M_end();
                               :      bool __comp = true;
     9  0.0077     0       0   :      while (__x != 0)
                               :	{
    27  0.0230     0       0   :	  __y = __x;
    10  0.0085     1  0.0591   :	  __comp = _M_impl._M_key_compare(__k, _S_key(__x));
   130  0.1106     2  0.1181   :	  __x = __comp ? _S_left(__x) : _S_right(__x);
                               :	}
                               :      iterator __j = iterator(__y);
     5  0.0043     0       0   :      if (__comp)
                               :	{
     1 8.5e-04     0       0   :	  if (__j == begin())
                               :	    return _Res(__x, __y);
                               :	  else
                               :	    --__j;
                               :	}
                               :      if (_M_impl._M_key_compare(_S_key(__j._M_node), __k))
                               :	return _Res(__x, __y);
                               :      return _Res(__j._M_node, 0);
                               :    }
                               :
                               :  template<typename _Key, typename _Val, typename _KeyOfValue,
                               :           typename _Compare, typename _Alloc>
                               :    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
                               :			   _Compare, _Alloc>::_Base_ptr,
                               :	 typename _Rb_tree<_Key, _Val, _KeyOfValue,
                               :			   _Compare, _Alloc>::_Base_ptr>
                               :    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                               :    _M_get_insert_equal_pos(const key_type& __k)
                               :    {
                               :      typedef pair<_Base_ptr, _Base_ptr> _Res;
                               :      _Link_type __x = _M_begin();
                               :      _Link_type __y = _M_end();
                               :      while (__x != 0)
                               :	{
                               :	  __y = __x;
                               :	  __x = _M_impl._M_key_compare(__k, _S_key(__x)) ?
                               :	        _S_left(__x) : _S_right(__x);
                               :	}
                               :      return _Res(__x, __y);
                               :    }
                               :
                               :  template<typename _Key, typename _Val, typename _KeyOfValue,
                               :           typename _Compare, typename _Alloc>
                               :#if __cplusplus >= 201103L
                               :    template<typename _Arg>
                               :#endif
                               :    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
                               :			   _Compare, _Alloc>::iterator, bool>
     2  0.0017     0       0   :    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>:: /* std::pair<std::_Rb_tree_iterator<int>, bool> std::_Rb_tree<int, int, std::_Identity<int>, std::less<int>, std::allocator<int> >::_M_insert_unique<int const&>(int const&) total:    232  0.1974     4  0.2363 */
                               :#if __cplusplus >= 201103L
                               :    _M_insert_unique(_Arg&& __v)
                               :#else
                               :    _M_insert_unique(const _Val& __v)
                               :#endif
                               :    {
                               :      typedef pair<iterator, bool> _Res;
                               :      pair<_Base_ptr, _Base_ptr> __res
                               :	= _M_get_insert_unique_pos(_KeyOfValue()(__v));
                               :
     2  0.0017     0       0   :      if (__res.second)
                               :	return _Res(_M_insert_(__res.first, __res.second,
                               :			       _GLIBCXX_FORWARD(_Arg, __v)),
                               :		    true);
                               :
                               :      return _Res(iterator(static_cast<_Link_type>(__res.first)), false);
     4  0.0034     0       0   :    }
                               :
                               :  template<typename _Key, typename _Val, typename _KeyOfValue,
                               :           typename _Compare, typename _Alloc>
                               :#if __cplusplus >= 201103L
                               :    template<typename _Arg>
                               :#endif
                               :    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
                               :    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                               :#if __cplusplus >= 201103L
                               :    _M_insert_equal(_Arg&& __v)
                               :#else
                               :    _M_insert_equal(const _Val& __v)
                               :#endif
                               :    {
                               :      pair<_Base_ptr, _Base_ptr> __res
                               :	= _M_get_insert_equal_pos(_KeyOfValue()(__v));
                               :      return _M_insert_(__res.first, __res.second, _GLIBCXX_FORWARD(_Arg, __v));
                               :    }
                               :
                               :  template<typename _Key, typename _Val, typename _KeyOfValue,
                               :           typename _Compare, typename _Alloc>
                               :    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
                               :			   _Compare, _Alloc>::_Base_ptr,
                               :         typename _Rb_tree<_Key, _Val, _KeyOfValue,
                               :			   _Compare, _Alloc>::_Base_ptr>
                               :    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                               :    _M_get_insert_hint_unique_pos(const_iterator __position,
                               :				  const key_type& __k)
                               :    {
                               :      iterator __pos = __position._M_const_cast();
                               :      typedef pair<_Base_ptr, _Base_ptr> _Res;
                               :
                               :      // end()
                               :      if (__pos._M_node == _M_end())
                               :	{
                               :	  if (size() > 0
                               :	      && _M_impl._M_key_compare(_S_key(_M_rightmost()), __k))
                               :	    return _Res(0, _M_rightmost());
                               :	  else
                               :	    return _M_get_insert_unique_pos(__k);
                               :	}
                               :      else if (_M_impl._M_key_compare(__k, _S_key(__pos._M_node)))
                               :	{
                               :	  // First, try before...
                               :	  iterator __before = __pos;
                               :	  if (__pos._M_node == _M_leftmost()) // begin()
                               :	    return _Res(_M_leftmost(), _M_leftmost());
                               :	  else if (_M_impl._M_key_compare(_S_key((--__before)._M_node), __k))
                               :	    {
                               :	      if (_S_right(__before._M_node) == 0)
                               :		return _Res(0, __before._M_node);
                               :	      else
                               :		return _Res(__pos._M_node, __pos._M_node);
                               :	    }
                               :	  else
                               :	    return _M_get_insert_unique_pos(__k);
                               :	}
                               :      else if (_M_impl._M_key_compare(_S_key(__pos._M_node), __k))
                               :	{
                               :	  // ... then try after.
                               :	  iterator __after = __pos;
                               :	  if (__pos._M_node == _M_rightmost())
                               :	    return _Res(0, _M_rightmost());
                               :	  else if (_M_impl._M_key_compare(__k, _S_key((++__after)._M_node)))
                               :	    {
                               :	      if (_S_right(__pos._M_node) == 0)
                               :		return _Res(0, __pos._M_node);
                               :	      else
                               :		return _Res(__after._M_node, __after._M_node);
                               :	    }
                               :	  else
                               :	    return _M_get_insert_unique_pos(__k);
                               :	}
                               :      else
                               :	// Equivalent keys.
                               :	return _Res(__pos._M_node, 0);
                               :    }
                               :
                               :  template<typename _Key, typename _Val, typename _KeyOfValue,
                               :           typename _Compare, typename _Alloc>
                               :#if __cplusplus >= 201103L
                               :    template<typename _Arg>
                               :#endif
                               :    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
                               :    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                               :#if __cplusplus >= 201103L
                               :    _M_insert_unique_(const_iterator __position, _Arg&& __v)
                               :#else
                               :    _M_insert_unique_(const_iterator __position, const _Val& __v)
                               :#endif
                               :    {
                               :      pair<_Base_ptr, _Base_ptr> __res
                               :	= _M_get_insert_hint_unique_pos(__position, _KeyOfValue()(__v));
                               :
                               :      if (__res.second)
                               :	return _M_insert_(__res.first, __res.second,
                               :			  _GLIBCXX_FORWARD(_Arg, __v));
                               :      return iterator(static_cast<_Link_type>(__res.first));
                               :    }
                               :
                               :  template<typename _Key, typename _Val, typename _KeyOfValue,
                               :           typename _Compare, typename _Alloc>
                               :    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
                               :			   _Compare, _Alloc>::_Base_ptr,
                               :         typename _Rb_tree<_Key, _Val, _KeyOfValue,
                               :			   _Compare, _Alloc>::_Base_ptr>
                               :    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                               :    _M_get_insert_hint_equal_pos(const_iterator __position, const key_type& __k)
                               :    {
                               :      iterator __pos = __position._M_const_cast();
                               :      typedef pair<_Base_ptr, _Base_ptr> _Res;
                               :
                               :      // end()
                               :      if (__pos._M_node == _M_end())
                               :	{
                               :	  if (size() > 0
                               :	      && !_M_impl._M_key_compare(__k, _S_key(_M_rightmost())))
                               :	    return _Res(0, _M_rightmost());
                               :	  else
                               :	    return _M_get_insert_equal_pos(__k);
                               :	}
                               :      else if (!_M_impl._M_key_compare(_S_key(__pos._M_node), __k))
                               :	{
                               :	  // First, try before...
                               :	  iterator __before = __pos;
                               :	  if (__pos._M_node == _M_leftmost()) // begin()
                               :	    return _Res(_M_leftmost(), _M_leftmost());
                               :	  else if (!_M_impl._M_key_compare(__k, _S_key((--__before)._M_node)))
                               :	    {
                               :	      if (_S_right(__before._M_node) == 0)
                               :		return _Res(0, __before._M_node);
                               :	      else
                               :		return _Res(__pos._M_node, __pos._M_node);
                               :	    }
                               :	  else
                               :	    return _M_get_insert_equal_pos(__k);
                               :	}
                               :      else
                               :	{
                               :	  // ... then try after.  
                               :	  iterator __after = __pos;
                               :	  if (__pos._M_node == _M_rightmost())
                               :	    return _Res(0, _M_rightmost());
                               :	  else if (!_M_impl._M_key_compare(_S_key((++__after)._M_node), __k))
                               :	    {
                               :	      if (_S_right(__pos._M_node) == 0)
                               :		return _Res(0, __pos._M_node);
                               :	      else
                               :		return _Res(__after._M_node, __after._M_node);
                               :	    }
                               :	  else
                               :	    return _Res(0, 0);
                               :	}
                               :    }
                               :
                               :  template<typename _Key, typename _Val, typename _KeyOfValue,
                               :           typename _Compare, typename _Alloc>
                               :#if __cplusplus >= 201103L
                               :    template<typename _Arg>
                               :#endif
                               :    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
                               :    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                               :#if __cplusplus >= 201103L
                               :    _M_insert_equal_(const_iterator __position, _Arg&& __v)
                               :#else
                               :    _M_insert_equal_(const_iterator __position, const _Val& __v)
                               :#endif
                               :    {
                               :      pair<_Base_ptr, _Base_ptr> __res
                               :	= _M_get_insert_hint_equal_pos(__position, _KeyOfValue()(__v));
                               :
                               :      if (__res.second)
                               :	return _M_insert_(__res.first, __res.second,
                               :			  _GLIBCXX_FORWARD(_Arg, __v));
                               :
                               :      return _M_insert_equal_lower(_GLIBCXX_FORWARD(_Arg, __v));
                               :    }
                               :
                               :#if __cplusplus >= 201103L
                               :  template<typename _Key, typename _Val, typename _KeyOfValue,
                               :           typename _Compare, typename _Alloc>
                               :    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
                               :    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                               :    _M_insert_node(_Base_ptr __x, _Base_ptr __p, _Link_type __z)
                               :    {
                               :      bool __insert_left = (__x != 0 || __p == _M_end()
                               :			    || _M_impl._M_key_compare(_S_key(__z),
                               :						      _S_key(__p)));
                               :
                               :      _Rb_tree_insert_and_rebalance(__insert_left, __z, __p,
                               :				    this->_M_impl._M_header);
                               :      ++_M_impl._M_node_count;
                               :      return iterator(__z);
                               :    }
                               :
                               :  template<typename _Key, typename _Val, typename _KeyOfValue,
                               :           typename _Compare, typename _Alloc>
                               :    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
                               :    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                               :    _M_insert_lower_node(_Base_ptr __p, _Link_type __z)
                               :    {
                               :      bool __insert_left = (__p == _M_end()
                               :			    || !_M_impl._M_key_compare(_S_key(__p),
                               :						       _S_key(__z)));
                               :
                               :      _Rb_tree_insert_and_rebalance(__insert_left, __z, __p,
                               :				    this->_M_impl._M_header);
                               :      ++_M_impl._M_node_count;
                               :      return iterator(__z);
                               :    }
                               :
                               :  template<typename _Key, typename _Val, typename _KeyOfValue,
                               :           typename _Compare, typename _Alloc>
                               :    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
                               :    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                               :    _M_insert_equal_lower_node(_Link_type __z)
                               :    {
                               :      _Link_type __x = _M_begin();
                               :      _Link_type __y = _M_end();
                               :      while (__x != 0)
                               :	{
                               :	  __y = __x;
                               :	  __x = !_M_impl._M_key_compare(_S_key(__x), _S_key(__z)) ?
                               :	        _S_left(__x) : _S_right(__x);
                               :	}
                               :      return _M_insert_lower_node(__y, __z);
                               :    }
                               :
                               :  template<typename _Key, typename _Val, typename _KeyOfValue,
                               :           typename _Compare, typename _Alloc>
                               :    template<typename... _Args>
                               :      pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
                               :			     _Compare, _Alloc>::iterator, bool>
                               :      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                               :      _M_emplace_unique(_Args&&... __args)
                               :      {
                               :	_Link_type __z = _M_create_node(std::forward<_Args>(__args)...);
                               :
                               :	__try
                               :	  {
                               :	    typedef pair<iterator, bool> _Res;
                               :	    auto __res = _M_get_insert_unique_pos(_S_key(__z));
                               :	    if (__res.second)
                               :	      return _Res(_M_insert_node(__res.first, __res.second, __z), true);
                               :	
                               :	    _M_destroy_node(__z);
                               :	    return _Res(iterator(static_cast<_Link_type>(__res.first)), false);
                               :	  }
                               :	__catch(...)
                               :	  {
                               :	    _M_destroy_node(__z);
                               :	    __throw_exception_again;
                               :	  }
                               :      }
                               :
                               :  template<typename _Key, typename _Val, typename _KeyOfValue,
                               :           typename _Compare, typename _Alloc>
                               :    template<typename... _Args>
                               :      typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
                               :      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                               :      _M_emplace_equal(_Args&&... __args)
                               :      {
                               :	_Link_type __z = _M_create_node(std::forward<_Args>(__args)...);
                               :
                               :	__try
                               :	  {
                               :	    auto __res = _M_get_insert_equal_pos(_S_key(__z));
                               :	    return _M_insert_node(__res.first, __res.second, __z);
                               :	  }
                               :	__catch(...)
                               :	  {
                               :	    _M_destroy_node(__z);
                               :	    __throw_exception_again;
                               :	  }
                               :      }
                               :
                               :  template<typename _Key, typename _Val, typename _KeyOfValue,
                               :           typename _Compare, typename _Alloc>
                               :    template<typename... _Args>
                               :      typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
                               :      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                               :      _M_emplace_hint_unique(const_iterator __pos, _Args&&... __args)
                               :      {
                               :	_Link_type __z = _M_create_node(std::forward<_Args>(__args)...);
                               :
                               :	__try
                               :	  {
                               :	    auto __res = _M_get_insert_hint_unique_pos(__pos, _S_key(__z));
                               :
                               :	    if (__res.second)
                               :	      return _M_insert_node(__res.first, __res.second, __z);
                               :
                               :	    _M_destroy_node(__z);
                               :	    return iterator(static_cast<_Link_type>(__res.first));
                               :	  }
                               :	__catch(...)
                               :	  {
                               :	    _M_destroy_node(__z);
                               :	    __throw_exception_again;
                               :	  }
                               :      }
                               :
                               :  template<typename _Key, typename _Val, typename _KeyOfValue,
                               :           typename _Compare, typename _Alloc>
                               :    template<typename... _Args>
                               :      typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
                               :      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                               :      _M_emplace_hint_equal(const_iterator __pos, _Args&&... __args)
                               :      {
                               :	_Link_type __z = _M_create_node(std::forward<_Args>(__args)...);
                               :
                               :	__try
                               :	  {
                               :	    auto __res = _M_get_insert_hint_equal_pos(__pos, _S_key(__z));
                               :
                               :	    if (__res.second)
                               :	      return _M_insert_node(__res.first, __res.second, __z);
                               :
                               :	    return _M_insert_equal_lower_node(__z);
                               :	  }
                               :	__catch(...)
                               :	  {
                               :	    _M_destroy_node(__z);
                               :	    __throw_exception_again;
                               :	  }
                               :      }
                               :#endif
                               :
                               :  template<typename _Key, typename _Val, typename _KoV,
                               :           typename _Cmp, typename _Alloc>
                               :    template<class _II>
                               :      void
                               :      _Rb_tree<_Key, _Val, _KoV, _Cmp, _Alloc>::
                               :      _M_insert_unique(_II __first, _II __last)
                               :      {
                               :	for (; __first != __last; ++__first)
                               :	  _M_insert_unique_(end(), *__first);
                               :      }
                               :
                               :  template<typename _Key, typename _Val, typename _KoV,
                               :           typename _Cmp, typename _Alloc>
                               :    template<class _II>
                               :      void
                               :      _Rb_tree<_Key, _Val, _KoV, _Cmp, _Alloc>::
                               :      _M_insert_equal(_II __first, _II __last)
                               :      {
                               :	for (; __first != __last; ++__first)
                               :	  _M_insert_equal_(end(), *__first);
                               :      }
                               :
                               :  template<typename _Key, typename _Val, typename _KeyOfValue,
                               :           typename _Compare, typename _Alloc>
                               :    void
                               :    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                               :    _M_erase_aux(const_iterator __position)
                               :    {
                               :      _Link_type __y =
                               :	static_cast<_Link_type>(_Rb_tree_rebalance_for_erase
                               :				(const_cast<_Base_ptr>(__position._M_node),
                               :				 this->_M_impl._M_header));
                               :      _M_destroy_node(__y);
                               :      --_M_impl._M_node_count;
                               :    }
                               :
                               :  template<typename _Key, typename _Val, typename _KeyOfValue,
                               :           typename _Compare, typename _Alloc>
                               :    void
                               :    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                               :    _M_erase_aux(const_iterator __first, const_iterator __last)
                               :    {
                               :      if (__first == begin() && __last == end())
                               :	clear();
                               :      else
                               :	while (__first != __last)
                               :	  erase(__first++);
                               :    }
                               :
                               :  template<typename _Key, typename _Val, typename _KeyOfValue,
                               :           typename _Compare, typename _Alloc>
                               :    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::size_type
                               :    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                               :    erase(const _Key& __x)
                               :    {
                               :      pair<iterator, iterator> __p = equal_range(__x);
                               :      const size_type __old_size = size();
                               :      erase(__p.first, __p.second);
                               :      return __old_size - size();
                               :    }
                               :
                               :  template<typename _Key, typename _Val, typename _KeyOfValue,
                               :           typename _Compare, typename _Alloc>
                               :    void
                               :    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                               :    erase(const _Key* __first, const _Key* __last)
                               :    {
                               :      while (__first != __last)
                               :	erase(*__first++);
                               :    }
                               :
                               :  template<typename _Key, typename _Val, typename _KeyOfValue,
                               :           typename _Compare, typename _Alloc>
                               :    typename _Rb_tree<_Key, _Val, _KeyOfValue,
                               :		      _Compare, _Alloc>::iterator
                               :    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
     1 8.5e-04     0       0   :    find(const _Key& __k)
                               :    {
                               :      iterator __j = _M_lower_bound(_M_begin(), _M_end(), __k);
                               :      return (__j == end()
                               :	      || _M_impl._M_key_compare(__k,
    16  0.0136     0       0   :					_S_key(__j._M_node))) ? end() : __j;
                               :    }
                               :
                               :  template<typename _Key, typename _Val, typename _KeyOfValue,
                               :           typename _Compare, typename _Alloc>
                               :    typename _Rb_tree<_Key, _Val, _KeyOfValue,
                               :		      _Compare, _Alloc>::const_iterator
                               :    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                               :    find(const _Key& __k) const
                               :    {
                               :      const_iterator __j = _M_lower_bound(_M_begin(), _M_end(), __k);
                               :      return (__j == end()
                               :	      || _M_impl._M_key_compare(__k, 
                               :					_S_key(__j._M_node))) ? end() : __j;
                               :    }
                               :
                               :  template<typename _Key, typename _Val, typename _KeyOfValue,
                               :           typename _Compare, typename _Alloc>
                               :    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::size_type
                               :    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
                               :    count(const _Key& __k) const
                               :    {
                               :      pair<const_iterator, const_iterator> __p = equal_range(__k);
                               :      const size_type __n = std::distance(__p.first, __p.second);
                               :      return __n;
                               :    }
                               :
                               :  _GLIBCXX_PURE unsigned int
                               :  _Rb_tree_black_count(const _Rb_tree_node_base* __node,
                               :                       const _Rb_tree_node_base* __root) throw ();
                               :
                               :  template<typename _Key, typename _Val, typename _KeyOfValue,
                               :           typename _Compare, typename _Alloc>
                               :    bool
                               :    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::__rb_verify() const
                               :    {
                               :      if (_M_impl._M_node_count == 0 || begin() == end())
                               :	return _M_impl._M_node_count == 0 && begin() == end()
                               :	       && this->_M_impl._M_header._M_left == _M_end()
                               :	       && this->_M_impl._M_header._M_right == _M_end();
                               :
                               :      unsigned int __len = _Rb_tree_black_count(_M_leftmost(), _M_root());
                               :      for (const_iterator __it = begin(); __it != end(); ++__it)
                               :	{
                               :	  _Const_Link_type __x = static_cast<_Const_Link_type>(__it._M_node);
                               :	  _Const_Link_type __L = _S_left(__x);
                               :	  _Const_Link_type __R = _S_right(__x);
                               :
                               :	  if (__x->_M_color == _S_red)
                               :	    if ((__L && __L->_M_color == _S_red)
                               :		|| (__R && __R->_M_color == _S_red))
                               :	      return false;
                               :
                               :	  if (__L && _M_impl._M_key_compare(_S_key(__x), _S_key(__L)))
                               :	    return false;
                               :	  if (__R && _M_impl._M_key_compare(_S_key(__R), _S_key(__x)))
                               :	    return false;
                               :
                               :	  if (!__L && !__R && _Rb_tree_black_count(__x, _M_root()) != __len)
                               :	    return false;
                               :	}
                               :
                               :      if (_M_leftmost() != _Rb_tree_node_base::_S_minimum(_M_root()))
                               :	return false;
                               :      if (_M_rightmost() != _Rb_tree_node_base::_S_maximum(_M_root()))
                               :	return false;
                               :      return true;
                               :    }
                               :
                               :_GLIBCXX_END_NAMESPACE_VERSION
                               :} // namespace
                               :
                               :#endif
/* 
 * Total samples for file : "/usr/include/c++/4.8/bits/stl_algo.h"
 * 
 *    626  0.5326     9  0.5316
 */


                               :// Algorithm implementation -*- C++ -*-
                               :
                               :// Copyright (C) 2001-2013 Free Software Foundation, Inc.
                               ://
                               :// This file is part of the GNU ISO C++ Library.  This library is free
                               :// software; you can redistribute it and/or modify it under the
                               :// terms of the GNU General Public License as published by the
                               :// Free Software Foundation; either version 3, or (at your option)
                               :// any later version.
                               :
                               :// This library is distributed in the hope that it will be useful,
                               :// but WITHOUT ANY WARRANTY; without even the implied warranty of
                               :// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                               :// GNU General Public License for more details.
                               :
                               :// Under Section 7 of GPL version 3, you are granted additional
                               :// permissions described in the GCC Runtime Library Exception, version
                               :// 3.1, as published by the Free Software Foundation.
                               :
                               :// You should have received a copy of the GNU General Public License and
                               :// a copy of the GCC Runtime Library Exception along with this program;
                               :// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                               :// <http://www.gnu.org/licenses/>.
                               :
                               :/*
                               : *
                               : * Copyright (c) 1994
                               : * Hewlett-Packard Company
                               : *
                               : * Permission to use, copy, modify, distribute and sell this software
                               : * and its documentation for any purpose is hereby granted without fee,
                               : * provided that the above copyright notice appear in all copies and
                               : * that both that copyright notice and this permission notice appear
                               : * in supporting documentation.  Hewlett-Packard Company makes no
                               : * representations about the suitability of this software for any
                               : * purpose.  It is provided "as is" without express or implied warranty.
                               : *
                               : *
                               : * Copyright (c) 1996
                               : * Silicon Graphics Computer Systems, Inc.
                               : *
                               : * Permission to use, copy, modify, distribute and sell this software
                               : * and its documentation for any purpose is hereby granted without fee,
                               : * provided that the above copyright notice appear in all copies and
                               : * that both that copyright notice and this permission notice appear
                               : * in supporting documentation.  Silicon Graphics makes no
                               : * representations about the suitability of this software for any
                               : * purpose.  It is provided "as is" without express or implied warranty.
                               : */
                               :
                               :/** @file bits/stl_algo.h
                               : *  This is an internal header file, included by other library headers.
                               : *  Do not attempt to use it directly. @headername{algorithm}
                               : */
                               :
                               :#ifndef _STL_ALGO_H
                               :#define _STL_ALGO_H 1
                               :
                               :#include <cstdlib>             // for rand
                               :#include <bits/algorithmfwd.h>
                               :#include <bits/stl_heap.h>
                               :#include <bits/stl_tempbuf.h>  // for _Temporary_buffer
                               :
                               :#if __cplusplus >= 201103L
                               :#include <random>     // for std::uniform_int_distribution
                               :#include <functional> // for std::bind
                               :#endif
                               :
                               :// See concept_check.h for the __glibcxx_*_requires macros.
                               :
                               :namespace std _GLIBCXX_VISIBILITY(default)
                               :{
                               :_GLIBCXX_BEGIN_NAMESPACE_VERSION
                               :
                               :  /// Swaps the median value of *__a, *__b and *__c to *__result
                               :  template<typename _Iterator>
                               :    void
                               :    __move_median_to_first(_Iterator __result, _Iterator __a,
                               :			   _Iterator __b, _Iterator __c)
                               :    {
                               :      // concept requirements
                               :      __glibcxx_function_requires(_LessThanComparableConcept<
                               :	    typename iterator_traits<_Iterator>::value_type>)
                               :
                               :      if (*__a < *__b)
                               :	{
                               :	  if (*__b < *__c)
                               :	    std::iter_swap(__result, __b);
                               :	  else if (*__a < *__c)
                               :	    std::iter_swap(__result, __c);
                               :	  else
                               :	    std::iter_swap(__result, __a);
                               :	}
                               :      else if (*__a < *__c)
                               :      	std::iter_swap(__result, __a);
                               :      else if (*__b < *__c)
                               :	std::iter_swap(__result, __c);
                               :      else
                               :	std::iter_swap(__result, __b);
                               :    }
                               :
                               :  /// Swaps the median value of *__a, *__b and *__c under __comp to *__result
                               :  template<typename _Iterator, typename _Compare>
                               :    void
                               :    __move_median_to_first(_Iterator __result, _Iterator __a,
                               :			   _Iterator __b, _Iterator __c,
                               :			   _Compare __comp)
                               :    {
                               :      // concept requirements
                               :      __glibcxx_function_requires(_BinaryFunctionConcept<_Compare, bool,
                               :	    typename iterator_traits<_Iterator>::value_type,
                               :	    typename iterator_traits<_Iterator>::value_type>)
                               :
                               :      if (__comp(*__a, *__b))
                               :	{
                               :	  if (__comp(*__b, *__c))
                               :	    std::iter_swap(__result, __b);
                               :	  else if (__comp(*__a, *__c))
                               :	    std::iter_swap(__result, __c);
                               :	  else
                               :	    std::iter_swap(__result, __a);
                               :	}
                               :      else if (__comp(*__a, *__c))
                               :	std::iter_swap(__result, __a);
                               :      else if (__comp(*__b, *__c))
                               :	std::iter_swap(__result, __c);
                               :      else
                               :	std::iter_swap(__result, __b);
                               :    }
                               :
                               :  // for_each
                               :
                               :  /// This is an overload used by find() for the Input Iterator case.
                               :  template<typename _InputIterator, typename _Tp>
                               :    inline _InputIterator
                               :    __find(_InputIterator __first, _InputIterator __last,
                               :	   const _Tp& __val, input_iterator_tag)
                               :    {
                               :      while (__first != __last && !(*__first == __val))
                               :	++__first;
                               :      return __first;
                               :    }
                               :
                               :  /// This is an overload used by find_if() for the Input Iterator case.
                               :  template<typename _InputIterator, typename _Predicate>
                               :    inline _InputIterator
                               :    __find_if(_InputIterator __first, _InputIterator __last,
                               :	      _Predicate __pred, input_iterator_tag)
                               :    {
                               :      while (__first != __last && !bool(__pred(*__first)))
                               :	++__first;
                               :      return __first;
                               :    }
                               :
                               :  /// This is an overload used by find() for the RAI case.
                               :  template<typename _RandomAccessIterator, typename _Tp>
                               :    _RandomAccessIterator
                               :    __find(_RandomAccessIterator __first, _RandomAccessIterator __last,
                               :	   const _Tp& __val, random_access_iterator_tag)
                               :    {
                               :      typename iterator_traits<_RandomAccessIterator>::difference_type
                               :	__trip_count = (__last - __first) >> 2;
                               :
                               :      for (; __trip_count > 0; --__trip_count)
                               :	{
                               :	  if (*__first == __val)
                               :	    return __first;
                               :	  ++__first;
                               :
                               :	  if (*__first == __val)
                               :	    return __first;
                               :	  ++__first;
                               :
                               :	  if (*__first == __val)
                               :	    return __first;
                               :	  ++__first;
                               :
                               :	  if (*__first == __val)
                               :	    return __first;
                               :	  ++__first;
                               :	}
                               :
                               :      switch (__last - __first)
                               :	{
                               :	case 3:
                               :	  if (*__first == __val)
                               :	    return __first;
                               :	  ++__first;
                               :	case 2:
                               :	  if (*__first == __val)
                               :	    return __first;
                               :	  ++__first;
                               :	case 1:
                               :	  if (*__first == __val)
                               :	    return __first;
                               :	  ++__first;
                               :	case 0:
                               :	default:
                               :	  return __last;
                               :	}
                               :    }
                               :
                               :  /// This is an overload used by find_if() for the RAI case.
                               :  template<typename _RandomAccessIterator, typename _Predicate>
                               :    _RandomAccessIterator
                               :    __find_if(_RandomAccessIterator __first, _RandomAccessIterator __last,
                               :	      _Predicate __pred, random_access_iterator_tag)
                               :    {
                               :      typename iterator_traits<_RandomAccessIterator>::difference_type
                               :	__trip_count = (__last - __first) >> 2;
                               :
                               :      for (; __trip_count > 0; --__trip_count)
                               :	{
                               :	  if (__pred(*__first))
                               :	    return __first;
                               :	  ++__first;
                               :
                               :	  if (__pred(*__first))
                               :	    return __first;
                               :	  ++__first;
                               :
                               :	  if (__pred(*__first))
                               :	    return __first;
                               :	  ++__first;
                               :
                               :	  if (__pred(*__first))
                               :	    return __first;
                               :	  ++__first;
                               :	}
                               :
                               :      switch (__last - __first)
                               :	{
                               :	case 3:
                               :	  if (__pred(*__first))
                               :	    return __first;
                               :	  ++__first;
                               :	case 2:
                               :	  if (__pred(*__first))
                               :	    return __first;
                               :	  ++__first;
                               :	case 1:
                               :	  if (__pred(*__first))
                               :	    return __first;
                               :	  ++__first;
                               :	case 0:
                               :	default:
                               :	  return __last;
                               :	}
                               :    }
                               :
                               :  /// This is an overload used by find_if_not() for the Input Iterator case.
                               :  template<typename _InputIterator, typename _Predicate>
                               :    inline _InputIterator
                               :    __find_if_not(_InputIterator __first, _InputIterator __last,
                               :		  _Predicate __pred, input_iterator_tag)
                               :    {
                               :      while (__first != __last && bool(__pred(*__first)))
                               :	++__first;
                               :      return __first;
                               :    }
                               :
                               :  /// This is an overload used by find_if_not() for the RAI case.
                               :  template<typename _RandomAccessIterator, typename _Predicate>
                               :    _RandomAccessIterator
                               :    __find_if_not(_RandomAccessIterator __first, _RandomAccessIterator __last,
                               :		  _Predicate __pred, random_access_iterator_tag)
                               :    {
                               :      typename iterator_traits<_RandomAccessIterator>::difference_type
                               :	__trip_count = (__last - __first) >> 2;
                               :
                               :      for (; __trip_count > 0; --__trip_count)
                               :	{
                               :	  if (!bool(__pred(*__first)))
                               :	    return __first;
                               :	  ++__first;
                               :
                               :	  if (!bool(__pred(*__first)))
                               :	    return __first;
                               :	  ++__first;
                               :
                               :	  if (!bool(__pred(*__first)))
                               :	    return __first;
                               :	  ++__first;
                               :
                               :	  if (!bool(__pred(*__first)))
                               :	    return __first;
                               :	  ++__first;
                               :	}
                               :
                               :      switch (__last - __first)
                               :	{
                               :	case 3:
                               :	  if (!bool(__pred(*__first)))
                               :	    return __first;
                               :	  ++__first;
                               :	case 2:
                               :	  if (!bool(__pred(*__first)))
                               :	    return __first;
                               :	  ++__first;
                               :	case 1:
                               :	  if (!bool(__pred(*__first)))
                               :	    return __first;
                               :	  ++__first;
                               :	case 0:
                               :	default:
                               :	  return __last;
                               :	}
                               :    }
                               :
                               :  /// Provided for stable_partition to use.
                               :  template<typename _InputIterator, typename _Predicate>
                               :    inline _InputIterator
                               :    __find_if_not(_InputIterator __first, _InputIterator __last,
                               :		  _Predicate __pred)
                               :    {
                               :      return std::__find_if_not(__first, __last, __pred,
                               :				std::__iterator_category(__first));
                               :    }
                               :
                               :  /// Like find_if_not(), but uses and updates a count of the
                               :  /// remaining range length instead of comparing against an end
                               :  /// iterator.
                               :  template<typename _InputIterator, typename _Predicate, typename _Distance>
                               :    _InputIterator
                               :    __find_if_not_n(_InputIterator __first, _Distance& __len, _Predicate __pred)
                               :    {
                               :      for (; __len; --__len, ++__first)
                               :	if (!bool(__pred(*__first)))
                               :	  break;
                               :      return __first;
                               :    }
                               :
                               :  // set_difference
                               :  // set_intersection
                               :  // set_symmetric_difference
                               :  // set_union
                               :  // for_each
                               :  // find
                               :  // find_if
                               :  // find_first_of
                               :  // adjacent_find
                               :  // count
                               :  // count_if
                               :  // search
                               :
                               :  /**
                               :   *  This is an uglified
                               :   *  search_n(_ForwardIterator, _ForwardIterator, _Integer, const _Tp&)
                               :   *  overloaded for forward iterators.
                               :  */
                               :  template<typename _ForwardIterator, typename _Integer, typename _Tp>
                               :    _ForwardIterator
                               :    __search_n(_ForwardIterator __first, _ForwardIterator __last,
                               :	       _Integer __count, const _Tp& __val,
                               :	       std::forward_iterator_tag)
                               :    {
                               :      __first = _GLIBCXX_STD_A::find(__first, __last, __val);
                               :      while (__first != __last)
                               :	{
                               :	  typename iterator_traits<_ForwardIterator>::difference_type
                               :	    __n = __count;
                               :	  _ForwardIterator __i = __first;
                               :	  ++__i;
                               :	  while (__i != __last && __n != 1 && *__i == __val)
                               :	    {
                               :	      ++__i;
                               :	      --__n;
                               :	    }
                               :	  if (__n == 1)
                               :	    return __first;
                               :	  if (__i == __last)
                               :	    return __last;
                               :	  __first = _GLIBCXX_STD_A::find(++__i, __last, __val);
                               :	}
                               :      return __last;
                               :    }
                               :
                               :  /**
                               :   *  This is an uglified
                               :   *  search_n(_ForwardIterator, _ForwardIterator, _Integer, const _Tp&)
                               :   *  overloaded for random access iterators.
                               :  */
                               :  template<typename _RandomAccessIter, typename _Integer, typename _Tp>
                               :    _RandomAccessIter
                               :    __search_n(_RandomAccessIter __first, _RandomAccessIter __last,
                               :	       _Integer __count, const _Tp& __val, 
                               :	       std::random_access_iterator_tag)
                               :    {
                               :      
                               :      typedef typename std::iterator_traits<_RandomAccessIter>::difference_type
                               :	_DistanceType;
                               :
                               :      _DistanceType __tailSize = __last - __first;
                               :      _DistanceType __remainder = __count;
                               :
                               :      while (__remainder <= __tailSize) // the main loop...
                               :	{
                               :	  __first += __remainder;
                               :	  __tailSize -= __remainder;
                               :	  // __first here is always pointing to one past the last element of
                               :	  // next possible match.
                               :	  _RandomAccessIter __backTrack = __first; 
                               :	  while (*--__backTrack == __val)
                               :	    {
                               :	      if (--__remainder == 0)
                               :	        return (__first - __count); // Success
                               :	    }
                               :	  __remainder = __count + 1 - (__first - __backTrack);
                               :	}
                               :      return __last; // Failure
                               :    }
                               :
                               :  // search_n
                               :
                               :  /**
                               :   *  This is an uglified
                               :   *  search_n(_ForwardIterator, _ForwardIterator, _Integer, const _Tp&,
                               :   *	       _BinaryPredicate)
                               :   *  overloaded for forward iterators.
                               :  */
                               :  template<typename _ForwardIterator, typename _Integer, typename _Tp,
                               :           typename _BinaryPredicate>
                               :    _ForwardIterator
                               :    __search_n(_ForwardIterator __first, _ForwardIterator __last,
                               :	       _Integer __count, const _Tp& __val,
                               :	       _BinaryPredicate __binary_pred, std::forward_iterator_tag)
                               :    {
                               :      while (__first != __last && !bool(__binary_pred(*__first, __val)))
                               :        ++__first;
                               :
                               :      while (__first != __last)
                               :	{
                               :	  typename iterator_traits<_ForwardIterator>::difference_type
                               :	    __n = __count;
                               :	  _ForwardIterator __i = __first;
                               :	  ++__i;
                               :	  while (__i != __last && __n != 1 && bool(__binary_pred(*__i, __val)))
                               :	    {
                               :	      ++__i;
                               :	      --__n;
                               :	    }
                               :	  if (__n == 1)
                               :	    return __first;
                               :	  if (__i == __last)
                               :	    return __last;
                               :	  __first = ++__i;
                               :	  while (__first != __last
                               :		 && !bool(__binary_pred(*__first, __val)))
                               :	    ++__first;
                               :	}
                               :      return __last;
                               :    }
                               :
                               :  /**
                               :   *  This is an uglified
                               :   *  search_n(_ForwardIterator, _ForwardIterator, _Integer, const _Tp&,
                               :   *	       _BinaryPredicate)
                               :   *  overloaded for random access iterators.
                               :  */
                               :  template<typename _RandomAccessIter, typename _Integer, typename _Tp,
                               :	   typename _BinaryPredicate>
                               :    _RandomAccessIter
                               :    __search_n(_RandomAccessIter __first, _RandomAccessIter __last,
                               :	       _Integer __count, const _Tp& __val,
                               :	       _BinaryPredicate __binary_pred, std::random_access_iterator_tag)
                               :    {
                               :      
                               :      typedef typename std::iterator_traits<_RandomAccessIter>::difference_type
                               :	_DistanceType;
                               :
                               :      _DistanceType __tailSize = __last - __first;
                               :      _DistanceType __remainder = __count;
                               :
                               :      while (__remainder <= __tailSize) // the main loop...
                               :	{
                               :	  __first += __remainder;
                               :	  __tailSize -= __remainder;
                               :	  // __first here is always pointing to one past the last element of
                               :	  // next possible match.
                               :	  _RandomAccessIter __backTrack = __first; 
                               :	  while (__binary_pred(*--__backTrack, __val))
                               :	    {
                               :	      if (--__remainder == 0)
                               :	        return (__first - __count); // Success
                               :	    }
                               :	  __remainder = __count + 1 - (__first - __backTrack);
                               :	}
                               :      return __last; // Failure
                               :    }
                               :
                               :  // find_end for forward iterators.
                               :  template<typename _ForwardIterator1, typename _ForwardIterator2>
                               :    _ForwardIterator1
                               :    __find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
                               :	       _ForwardIterator2 __first2, _ForwardIterator2 __last2,
                               :	       forward_iterator_tag, forward_iterator_tag)
                               :    {
                               :      if (__first2 == __last2)
                               :	return __last1;
                               :      else
                               :	{
                               :	  _ForwardIterator1 __result = __last1;
                               :	  while (1)
                               :	    {
                               :	      _ForwardIterator1 __new_result
                               :		= _GLIBCXX_STD_A::search(__first1, __last1, __first2, __last2);
                               :	      if (__new_result == __last1)
                               :		return __result;
                               :	      else
                               :		{
                               :		  __result = __new_result;
                               :		  __first1 = __new_result;
                               :		  ++__first1;
                               :		}
                               :	    }
                               :	}
                               :    }
                               :
                               :  template<typename _ForwardIterator1, typename _ForwardIterator2,
                               :	   typename _BinaryPredicate>
                               :    _ForwardIterator1
                               :    __find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
                               :	       _ForwardIterator2 __first2, _ForwardIterator2 __last2,
                               :	       forward_iterator_tag, forward_iterator_tag,
                               :	       _BinaryPredicate __comp)
                               :    {
                               :      if (__first2 == __last2)
                               :	return __last1;
                               :      else
                               :	{
                               :	  _ForwardIterator1 __result = __last1;
                               :	  while (1)
                               :	    {
                               :	      _ForwardIterator1 __new_result
                               :		= _GLIBCXX_STD_A::search(__first1, __last1, __first2,
                               :					 __last2, __comp);
                               :	      if (__new_result == __last1)
                               :		return __result;
                               :	      else
                               :		{
                               :		  __result = __new_result;
                               :		  __first1 = __new_result;
                               :		  ++__first1;
                               :		}
                               :	    }
                               :	}
                               :    }
                               :
                               :  // find_end for bidirectional iterators (much faster).
                               :  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2>
                               :    _BidirectionalIterator1
                               :    __find_end(_BidirectionalIterator1 __first1,
                               :	       _BidirectionalIterator1 __last1,
                               :	       _BidirectionalIterator2 __first2,
                               :	       _BidirectionalIterator2 __last2,
                               :	       bidirectional_iterator_tag, bidirectional_iterator_tag)
                               :    {
                               :      // concept requirements
                               :      __glibcxx_function_requires(_BidirectionalIteratorConcept<
                               :				  _BidirectionalIterator1>)
                               :      __glibcxx_function_requires(_BidirectionalIteratorConcept<
                               :				  _BidirectionalIterator2>)
                               :
                               :      typedef reverse_iterator<_BidirectionalIterator1> _RevIterator1;
                               :      typedef reverse_iterator<_BidirectionalIterator2> _RevIterator2;
                               :
                               :      _RevIterator1 __rlast1(__first1);
                               :      _RevIterator2 __rlast2(__first2);
                               :      _RevIterator1 __rresult = _GLIBCXX_STD_A::search(_RevIterator1(__last1),
                               :						       __rlast1,
                               :						       _RevIterator2(__last2),
                               :						       __rlast2);
                               :
                               :      if (__rresult == __rlast1)
                               :	return __last1;
                               :      else
                               :	{
                               :	  _BidirectionalIterator1 __result = __rresult.base();
                               :	  std::advance(__result, -std::distance(__first2, __last2));
                               :	  return __result;
                               :	}
                               :    }
                               :
                               :  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
                               :	   typename _BinaryPredicate>
                               :    _BidirectionalIterator1
                               :    __find_end(_BidirectionalIterator1 __first1,
                               :	       _BidirectionalIterator1 __last1,
                               :	       _BidirectionalIterator2 __first2,
                               :	       _BidirectionalIterator2 __last2,
                               :	       bidirectional_iterator_tag, bidirectional_iterator_tag,
                               :	       _BinaryPredicate __comp)
                               :    {
                               :      // concept requirements
                               :      __glibcxx_function_requires(_BidirectionalIteratorConcept<
                               :				  _BidirectionalIterator1>)
                               :      __glibcxx_function_requires(_BidirectionalIteratorConcept<
                               :				  _BidirectionalIterator2>)
                               :
                               :      typedef reverse_iterator<_BidirectionalIterator1> _RevIterator1;
                               :      typedef reverse_iterator<_BidirectionalIterator2> _RevIterator2;
                               :
                               :      _RevIterator1 __rlast1(__first1);
                               :      _RevIterator2 __rlast2(__first2);
                               :      _RevIterator1 __rresult = std::search(_RevIterator1(__last1), __rlast1,
                               :					    _RevIterator2(__last2), __rlast2,
                               :					    __comp);
                               :
                               :      if (__rresult == __rlast1)
                               :	return __last1;
                               :      else
                               :	{
                               :	  _BidirectionalIterator1 __result = __rresult.base();
                               :	  std::advance(__result, -std::distance(__first2, __last2));
                               :	  return __result;
                               :	}
                               :    }
                               :
                               :  /**
                               :   *  @brief  Find last matching subsequence in a sequence.
                               :   *  @ingroup non_mutating_algorithms
                               :   *  @param  __first1  Start of range to search.
                               :   *  @param  __last1   End of range to search.
                               :   *  @param  __first2  Start of sequence to match.
                               :   *  @param  __last2   End of sequence to match.
                               :   *  @return   The last iterator @c i in the range
                               :   *  @p [__first1,__last1-(__last2-__first2)) such that @c *(i+N) ==
                               :   *  @p *(__first2+N) for each @c N in the range @p
                               :   *  [0,__last2-__first2), or @p __last1 if no such iterator exists.
                               :   *
                               :   *  Searches the range @p [__first1,__last1) for a sub-sequence that
                               :   *  compares equal value-by-value with the sequence given by @p
                               :   *  [__first2,__last2) and returns an iterator to the __first
                               :   *  element of the sub-sequence, or @p __last1 if the sub-sequence
                               :   *  is not found.  The sub-sequence will be the last such
                               :   *  subsequence contained in [__first,__last1).
                               :   *
                               :   *  Because the sub-sequence must lie completely within the range @p
                               :   *  [__first1,__last1) it must start at a position less than @p
                               :   *  __last1-(__last2-__first2) where @p __last2-__first2 is the
                               :   *  length of the sub-sequence.  This means that the returned
                               :   *  iterator @c i will be in the range @p
                               :   *  [__first1,__last1-(__last2-__first2))
                               :  */
                               :  template<typename _ForwardIterator1, typename _ForwardIterator2>
                               :    inline _ForwardIterator1
                               :    find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
                               :	     _ForwardIterator2 __first2, _ForwardIterator2 __last2)
                               :    {
                               :      // concept requirements
                               :      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator1>)
                               :      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator2>)
                               :      __glibcxx_function_requires(_EqualOpConcept<
                               :	    typename iterator_traits<_ForwardIterator1>::value_type,
                               :	    typename iterator_traits<_ForwardIterator2>::value_type>)
                               :      __glibcxx_requires_valid_range(__first1, __last1);
                               :      __glibcxx_requires_valid_range(__first2, __last2);
                               :
                               :      return std::__find_end(__first1, __last1, __first2, __last2,
                               :			     std::__iterator_category(__first1),
                               :			     std::__iterator_category(__first2));
                               :    }
                               :
                               :  /**
                               :   *  @brief  Find last matching subsequence in a sequence using a predicate.
                               :   *  @ingroup non_mutating_algorithms
                               :   *  @param  __first1  Start of range to search.
                               :   *  @param  __last1   End of range to search.
                               :   *  @param  __first2  Start of sequence to match.
                               :   *  @param  __last2   End of sequence to match.
                               :   *  @param  __comp    The predicate to use.
                               :   *  @return The last iterator @c i in the range @p
                               :   *  [__first1,__last1-(__last2-__first2)) such that @c
                               :   *  predicate(*(i+N), @p (__first2+N)) is true for each @c N in the
                               :   *  range @p [0,__last2-__first2), or @p __last1 if no such iterator
                               :   *  exists.
                               :   *
                               :   *  Searches the range @p [__first1,__last1) for a sub-sequence that
                               :   *  compares equal value-by-value with the sequence given by @p
                               :   *  [__first2,__last2) using comp as a predicate and returns an
                               :   *  iterator to the first element of the sub-sequence, or @p __last1
                               :   *  if the sub-sequence is not found.  The sub-sequence will be the
                               :   *  last such subsequence contained in [__first,__last1).
                               :   *
                               :   *  Because the sub-sequence must lie completely within the range @p
                               :   *  [__first1,__last1) it must start at a position less than @p
                               :   *  __last1-(__last2-__first2) where @p __last2-__first2 is the
                               :   *  length of the sub-sequence.  This means that the returned
                               :   *  iterator @c i will be in the range @p
                               :   *  [__first1,__last1-(__last2-__first2))
                               :  */
                               :  template<typename _ForwardIterator1, typename _ForwardIterator2,
                               :	   typename _BinaryPredicate>
                               :    inline _ForwardIterator1
                               :    find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
                               :	     _ForwardIterator2 __first2, _ForwardIterator2 __last2,
                               :	     _BinaryPredicate __comp)
                               :    {
                               :      // concept requirements
                               :      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator1>)
                               :      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator2>)
                               :      __glibcxx_function_requires(_BinaryPredicateConcept<_BinaryPredicate,
                               :	    typename iterator_traits<_ForwardIterator1>::value_type,
                               :	    typename iterator_traits<_ForwardIterator2>::value_type>)
                               :      __glibcxx_requires_valid_range(__first1, __last1);
                               :      __glibcxx_requires_valid_range(__first2, __last2);
                               :
                               :      return std::__find_end(__first1, __last1, __first2, __last2,
                               :			     std::__iterator_category(__first1),
                               :			     std::__iterator_category(__first2),
                               :			     __comp);
                               :    }
                               :
                               :#if __cplusplus >= 201103L
                               :  /**
                               :   *  @brief  Checks that a predicate is true for all the elements
                               :   *          of a sequence.
                               :   *  @ingroup non_mutating_algorithms
                               :   *  @param  __first   An input iterator.
                               :   *  @param  __last    An input iterator.
                               :   *  @param  __pred    A predicate.
                               :   *  @return  True if the check is true, false otherwise.
                               :   *
                               :   *  Returns true if @p __pred is true for each element in the range
                               :   *  @p [__first,__last), and false otherwise.
                               :  */
                               :  template<typename _InputIterator, typename _Predicate>
                               :    inline bool
                               :    all_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)
                               :    { return __last == std::find_if_not(__first, __last, __pred); }
                               :
                               :  /**
                               :   *  @brief  Checks that a predicate is false for all the elements
                               :   *          of a sequence.
                               :   *  @ingroup non_mutating_algorithms
                               :   *  @param  __first   An input iterator.
                               :   *  @param  __last    An input iterator.
                               :   *  @param  __pred    A predicate.
                               :   *  @return  True if the check is true, false otherwise.
                               :   *
                               :   *  Returns true if @p __pred is false for each element in the range
                               :   *  @p [__first,__last), and false otherwise.
                               :  */
                               :  template<typename _InputIterator, typename _Predicate>
                               :    inline bool
                               :    none_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)
                               :    { return __last == _GLIBCXX_STD_A::find_if(__first, __last, __pred); }
                               :
                               :  /**
                               :   *  @brief  Checks that a predicate is false for at least an element
                               :   *          of a sequence.
                               :   *  @ingroup non_mutating_algorithms
                               :   *  @param  __first   An input iterator.
                               :   *  @param  __last    An input iterator.
                               :   *  @param  __pred    A predicate.
                               :   *  @return  True if the check is true, false otherwise.
                               :   *
                               :   *  Returns true if an element exists in the range @p
                               :   *  [__first,__last) such that @p __pred is true, and false
                               :   *  otherwise.
                               :  */
                               :  template<typename _InputIterator, typename _Predicate>
                               :    inline bool
                               :    any_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)
                               :    { return !std::none_of(__first, __last, __pred); }
                               :
                               :  /**
                               :   *  @brief  Find the first element in a sequence for which a
                               :   *          predicate is false.
                               :   *  @ingroup non_mutating_algorithms
                               :   *  @param  __first  An input iterator.
                               :   *  @param  __last   An input iterator.
                               :   *  @param  __pred   A predicate.
                               :   *  @return   The first iterator @c i in the range @p [__first,__last)
                               :   *  such that @p __pred(*i) is false, or @p __last if no such iterator exists.
                               :  */
                               :  template<typename _InputIterator, typename _Predicate>
                               :    inline _InputIterator
                               :    find_if_not(_InputIterator __first, _InputIterator __last,
                               :		_Predicate __pred)
                               :    {
                               :      // concept requirements
                               :      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
                               :      __glibcxx_function_requires(_UnaryPredicateConcept<_Predicate,
                               :	      typename iterator_traits<_InputIterator>::value_type>)
                               :      __glibcxx_requires_valid_range(__first, __last);
                               :      return std::__find_if_not(__first, __last, __pred);
                               :    }
                               :
                               :  /**
                               :   *  @brief  Checks whether the sequence is partitioned.
                               :   *  @ingroup mutating_algorithms
                               :   *  @param  __first  An input iterator.
                               :   *  @param  __last   An input iterator.
                               :   *  @param  __pred   A predicate.
                               :   *  @return  True if the range @p [__first,__last) is partioned by @p __pred,
                               :   *  i.e. if all elements that satisfy @p __pred appear before those that
                               :   *  do not.
                               :  */
                               :  template<typename _InputIterator, typename _Predicate>
                               :    inline bool
                               :    is_partitioned(_InputIterator __first, _InputIterator __last,
                               :		   _Predicate __pred)
                               :    {
                               :      __first = std::find_if_not(__first, __last, __pred);
                               :      return std::none_of(__first, __last, __pred);
                               :    }
                               :
                               :  /**
                               :   *  @brief  Find the partition point of a partitioned range.
                               :   *  @ingroup mutating_algorithms
                               :   *  @param  __first   An iterator.
                               :   *  @param  __last    Another iterator.
                               :   *  @param  __pred    A predicate.
                               :   *  @return  An iterator @p mid such that @p all_of(__first, mid, __pred)
                               :   *           and @p none_of(mid, __last, __pred) are both true.
                               :  */
                               :  template<typename _ForwardIterator, typename _Predicate>
                               :    _ForwardIterator
                               :    partition_point(_ForwardIterator __first, _ForwardIterator __last,
                               :		    _Predicate __pred)
                               :    {
                               :      // concept requirements
                               :      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                               :      __glibcxx_function_requires(_UnaryPredicateConcept<_Predicate,
                               :	      typename iterator_traits<_ForwardIterator>::value_type>)
                               :
                               :      // A specific debug-mode test will be necessary...
                               :      __glibcxx_requires_valid_range(__first, __last);
                               :
                               :      typedef typename iterator_traits<_ForwardIterator>::difference_type
                               :	_DistanceType;
                               :
                               :      _DistanceType __len = std::distance(__first, __last);
                               :      _DistanceType __half;
                               :      _ForwardIterator __middle;
                               :
                               :      while (__len > 0)
                               :	{
                               :	  __half = __len >> 1;
                               :	  __middle = __first;
                               :	  std::advance(__middle, __half);
                               :	  if (__pred(*__middle))
                               :	    {
                               :	      __first = __middle;
                               :	      ++__first;
                               :	      __len = __len - __half - 1;
                               :	    }
                               :	  else
                               :	    __len = __half;
                               :	}
                               :      return __first;
                               :    }
                               :#endif
                               :
                               :
                               :  /**
                               :   *  @brief Copy a sequence, removing elements of a given value.
                               :   *  @ingroup mutating_algorithms
                               :   *  @param  __first   An input iterator.
                               :   *  @param  __last    An input iterator.
                               :   *  @param  __result  An output iterator.
                               :   *  @param  __value   The value to be removed.
                               :   *  @return   An iterator designating the end of the resulting sequence.
                               :   *
                               :   *  Copies each element in the range @p [__first,__last) not equal
                               :   *  to @p __value to the range beginning at @p __result.
                               :   *  remove_copy() is stable, so the relative order of elements that
                               :   *  are copied is unchanged.
                               :  */
                               :  template<typename _InputIterator, typename _OutputIterator, typename _Tp>
                               :    _OutputIterator
                               :    remove_copy(_InputIterator __first, _InputIterator __last,
                               :		_OutputIterator __result, const _Tp& __value)
                               :    {
                               :      // concept requirements
                               :      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
                               :      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                               :	    typename iterator_traits<_InputIterator>::value_type>)
                               :      __glibcxx_function_requires(_EqualOpConcept<
                               :	    typename iterator_traits<_InputIterator>::value_type, _Tp>)
                               :      __glibcxx_requires_valid_range(__first, __last);
                               :
                               :      for (; __first != __last; ++__first)
                               :	if (!(*__first == __value))
                               :	  {
                               :	    *__result = *__first;
                               :	    ++__result;
                               :	  }
                               :      return __result;
                               :    }
                               :
                               :  /**
                               :   *  @brief Copy a sequence, removing elements for which a predicate is true.
                               :   *  @ingroup mutating_algorithms
                               :   *  @param  __first   An input iterator.
                               :   *  @param  __last    An input iterator.
                               :   *  @param  __result  An output iterator.
                               :   *  @param  __pred    A predicate.
                               :   *  @return   An iterator designating the end of the resulting sequence.
                               :   *
                               :   *  Copies each element in the range @p [__first,__last) for which
                               :   *  @p __pred returns false to the range beginning at @p __result.
                               :   *
                               :   *  remove_copy_if() is stable, so the relative order of elements that are
                               :   *  copied is unchanged.
                               :  */
                               :  template<typename _InputIterator, typename _OutputIterator,
                               :	   typename _Predicate>
                               :    _OutputIterator
                               :    remove_copy_if(_InputIterator __first, _InputIterator __last,
                               :		   _OutputIterator __result, _Predicate __pred)
                               :    {
                               :      // concept requirements
                               :      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
                               :      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                               :	    typename iterator_traits<_InputIterator>::value_type>)
                               :      __glibcxx_function_requires(_UnaryPredicateConcept<_Predicate,
                               :	    typename iterator_traits<_InputIterator>::value_type>)
                               :      __glibcxx_requires_valid_range(__first, __last);
                               :
                               :      for (; __first != __last; ++__first)
                               :	if (!bool(__pred(*__first)))
                               :	  {
                               :	    *__result = *__first;
                               :	    ++__result;
                               :	  }
                               :      return __result;
                               :    }
                               :
                               :#if __cplusplus >= 201103L
                               :  /**
                               :   *  @brief Copy the elements of a sequence for which a predicate is true.
                               :   *  @ingroup mutating_algorithms
                               :   *  @param  __first   An input iterator.
                               :   *  @param  __last    An input iterator.
                               :   *  @param  __result  An output iterator.
                               :   *  @param  __pred    A predicate.
                               :   *  @return   An iterator designating the end of the resulting sequence.
                               :   *
                               :   *  Copies each element in the range @p [__first,__last) for which
                               :   *  @p __pred returns true to the range beginning at @p __result.
                               :   *
                               :   *  copy_if() is stable, so the relative order of elements that are
                               :   *  copied is unchanged.
                               :  */
                               :  template<typename _InputIterator, typename _OutputIterator,
                               :	   typename _Predicate>
                               :    _OutputIterator
                               :    copy_if(_InputIterator __first, _InputIterator __last,
                               :	    _OutputIterator __result, _Predicate __pred)
                               :    {
                               :      // concept requirements
                               :      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
                               :      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                               :	    typename iterator_traits<_InputIterator>::value_type>)
                               :      __glibcxx_function_requires(_UnaryPredicateConcept<_Predicate,
                               :	    typename iterator_traits<_InputIterator>::value_type>)
                               :      __glibcxx_requires_valid_range(__first, __last);
                               :
                               :      for (; __first != __last; ++__first)
                               :	if (__pred(*__first))
                               :	  {
                               :	    *__result = *__first;
                               :	    ++__result;
                               :	  }
                               :      return __result;
                               :    }
                               :
                               :
                               :  template<typename _InputIterator, typename _Size, typename _OutputIterator>
                               :    _OutputIterator
                               :    __copy_n(_InputIterator __first, _Size __n,
                               :	     _OutputIterator __result, input_iterator_tag)
                               :    {
                               :      if (__n > 0)
                               :	{
                               :	  while (true)
                               :	    {
                               :	      *__result = *__first;
                               :	      ++__result;
                               :	      if (--__n > 0)
                               :		++__first;
                               :	      else
                               :		break;
                               :	    }
                               :	}
                               :      return __result;
                               :    }
                               :
                               :  template<typename _RandomAccessIterator, typename _Size,
                               :	   typename _OutputIterator>
                               :    inline _OutputIterator
                               :    __copy_n(_RandomAccessIterator __first, _Size __n,
                               :	     _OutputIterator __result, random_access_iterator_tag)
                               :    { return std::copy(__first, __first + __n, __result); }
                               :
                               :  /**
                               :   *  @brief Copies the range [first,first+n) into [result,result+n).
                               :   *  @ingroup mutating_algorithms
                               :   *  @param  __first  An input iterator.
                               :   *  @param  __n      The number of elements to copy.
                               :   *  @param  __result An output iterator.
                               :   *  @return  result+n.
                               :   *
                               :   *  This inline function will boil down to a call to @c memmove whenever
                               :   *  possible.  Failing that, if random access iterators are passed, then the
                               :   *  loop count will be known (and therefore a candidate for compiler
                               :   *  optimizations such as unrolling).
                               :  */
                               :  template<typename _InputIterator, typename _Size, typename _OutputIterator>
                               :    inline _OutputIterator
                               :    copy_n(_InputIterator __first, _Size __n, _OutputIterator __result)
                               :    {
                               :      // concept requirements
                               :      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
                               :      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                               :	    typename iterator_traits<_InputIterator>::value_type>)
                               :
                               :      return std::__copy_n(__first, __n, __result,
                               :			   std::__iterator_category(__first));
                               :    }
                               :
                               :  /**
                               :   *  @brief Copy the elements of a sequence to separate output sequences
                               :   *         depending on the truth value of a predicate.
                               :   *  @ingroup mutating_algorithms
                               :   *  @param  __first   An input iterator.
                               :   *  @param  __last    An input iterator.
                               :   *  @param  __out_true   An output iterator.
                               :   *  @param  __out_false  An output iterator.
                               :   *  @param  __pred    A predicate.
                               :   *  @return   A pair designating the ends of the resulting sequences.
                               :   *
                               :   *  Copies each element in the range @p [__first,__last) for which
                               :   *  @p __pred returns true to the range beginning at @p out_true
                               :   *  and each element for which @p __pred returns false to @p __out_false.
                               :  */
                               :  template<typename _InputIterator, typename _OutputIterator1,
                               :	   typename _OutputIterator2, typename _Predicate>
                               :    pair<_OutputIterator1, _OutputIterator2>
                               :    partition_copy(_InputIterator __first, _InputIterator __last,
                               :		   _OutputIterator1 __out_true, _OutputIterator2 __out_false,
                               :		   _Predicate __pred)
                               :    {
                               :      // concept requirements
                               :      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
                               :      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator1,
                               :	    typename iterator_traits<_InputIterator>::value_type>)
                               :      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator2,
                               :	    typename iterator_traits<_InputIterator>::value_type>)
                               :      __glibcxx_function_requires(_UnaryPredicateConcept<_Predicate,
                               :	    typename iterator_traits<_InputIterator>::value_type>)
                               :      __glibcxx_requires_valid_range(__first, __last);
                               :      
                               :      for (; __first != __last; ++__first)
                               :	if (__pred(*__first))
                               :	  {
                               :	    *__out_true = *__first;
                               :	    ++__out_true;
                               :	  }
                               :	else
                               :	  {
                               :	    *__out_false = *__first;
                               :	    ++__out_false;
                               :	  }
                               :
                               :      return pair<_OutputIterator1, _OutputIterator2>(__out_true, __out_false);
                               :    }
                               :#endif
                               :
                               :  /**
                               :   *  @brief Remove elements from a sequence.
                               :   *  @ingroup mutating_algorithms
                               :   *  @param  __first  An input iterator.
                               :   *  @param  __last   An input iterator.
                               :   *  @param  __value  The value to be removed.
                               :   *  @return   An iterator designating the end of the resulting sequence.
                               :   *
                               :   *  All elements equal to @p __value are removed from the range
                               :   *  @p [__first,__last).
                               :   *
                               :   *  remove() is stable, so the relative order of elements that are
                               :   *  not removed is unchanged.
                               :   *
                               :   *  Elements between the end of the resulting sequence and @p __last
                               :   *  are still present, but their value is unspecified.
                               :  */
                               :  template<typename _ForwardIterator, typename _Tp>
                               :    _ForwardIterator
                               :    remove(_ForwardIterator __first, _ForwardIterator __last,
                               :	   const _Tp& __value)
                               :    {
                               :      // concept requirements
                               :      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
                               :				  _ForwardIterator>)
                               :      __glibcxx_function_requires(_EqualOpConcept<
                               :	    typename iterator_traits<_ForwardIterator>::value_type, _Tp>)
                               :      __glibcxx_requires_valid_range(__first, __last);
                               :
                               :      __first = _GLIBCXX_STD_A::find(__first, __last, __value);
                               :      if(__first == __last)
                               :        return __first;
                               :      _ForwardIterator __result = __first;
                               :      ++__first;
                               :      for(; __first != __last; ++__first)
                               :        if(!(*__first == __value))
                               :          {
                               :            *__result = _GLIBCXX_MOVE(*__first);
                               :            ++__result;
                               :          }
                               :      return __result;
                               :    }
                               :
                               :  /**
                               :   *  @brief Remove elements from a sequence using a predicate.
                               :   *  @ingroup mutating_algorithms
                               :   *  @param  __first  A forward iterator.
                               :   *  @param  __last   A forward iterator.
                               :   *  @param  __pred   A predicate.
                               :   *  @return   An iterator designating the end of the resulting sequence.
                               :   *
                               :   *  All elements for which @p __pred returns true are removed from the range
                               :   *  @p [__first,__last).
                               :   *
                               :   *  remove_if() is stable, so the relative order of elements that are
                               :   *  not removed is unchanged.
                               :   *
                               :   *  Elements between the end of the resulting sequence and @p __last
                               :   *  are still present, but their value is unspecified.
                               :  */
                               :  template<typename _ForwardIterator, typename _Predicate>
                               :    _ForwardIterator
                               :    remove_if(_ForwardIterator __first, _ForwardIterator __last,
                               :	      _Predicate __pred)
                               :    {
                               :      // concept requirements
                               :      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
                               :				  _ForwardIterator>)
                               :      __glibcxx_function_requires(_UnaryPredicateConcept<_Predicate,
                               :	    typename iterator_traits<_ForwardIterator>::value_type>)
                               :      __glibcxx_requires_valid_range(__first, __last);
                               :
                               :      __first = _GLIBCXX_STD_A::find_if(__first, __last, __pred);
                               :      if(__first == __last)
                               :        return __first;
                               :      _ForwardIterator __result = __first;
                               :      ++__first;
                               :      for(; __first != __last; ++__first)
                               :        if(!bool(__pred(*__first)))
                               :          {
                               :            *__result = _GLIBCXX_MOVE(*__first);
                               :            ++__result;
                               :          }
                               :      return __result;
                               :    }
                               :
                               :  /**
                               :   *  @brief Remove consecutive duplicate values from a sequence.
                               :   *  @ingroup mutating_algorithms
                               :   *  @param  __first  A forward iterator.
                               :   *  @param  __last   A forward iterator.
                               :   *  @return  An iterator designating the end of the resulting sequence.
                               :   *
                               :   *  Removes all but the first element from each group of consecutive
                               :   *  values that compare equal.
                               :   *  unique() is stable, so the relative order of elements that are
                               :   *  not removed is unchanged.
                               :   *  Elements between the end of the resulting sequence and @p __last
                               :   *  are still present, but their value is unspecified.
                               :  */
                               :  template<typename _ForwardIterator>
                               :    _ForwardIterator
                               :    unique(_ForwardIterator __first, _ForwardIterator __last)
                               :    {
                               :      // concept requirements
                               :      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
                               :				  _ForwardIterator>)
                               :      __glibcxx_function_requires(_EqualityComparableConcept<
                               :		     typename iterator_traits<_ForwardIterator>::value_type>)
                               :      __glibcxx_requires_valid_range(__first, __last);
                               :
                               :      // Skip the beginning, if already unique.
                               :      __first = _GLIBCXX_STD_A::adjacent_find(__first, __last);
                               :      if (__first == __last)
                               :	return __last;
                               :
                               :      // Do the real copy work.
                               :      _ForwardIterator __dest = __first;
                               :      ++__first;
                               :      while (++__first != __last)
                               :	if (!(*__dest == *__first))
                               :	  *++__dest = _GLIBCXX_MOVE(*__first);
                               :      return ++__dest;
                               :    }
                               :
                               :  /**
                               :   *  @brief Remove consecutive values from a sequence using a predicate.
                               :   *  @ingroup mutating_algorithms
                               :   *  @param  __first        A forward iterator.
                               :   *  @param  __last         A forward iterator.
                               :   *  @param  __binary_pred  A binary predicate.
                               :   *  @return  An iterator designating the end of the resulting sequence.
                               :   *
                               :   *  Removes all but the first element from each group of consecutive
                               :   *  values for which @p __binary_pred returns true.
                               :   *  unique() is stable, so the relative order of elements that are
                               :   *  not removed is unchanged.
                               :   *  Elements between the end of the resulting sequence and @p __last
                               :   *  are still present, but their value is unspecified.
                               :  */
                               :  template<typename _ForwardIterator, typename _BinaryPredicate>
                               :    _ForwardIterator
                               :    unique(_ForwardIterator __first, _ForwardIterator __last,
                               :           _BinaryPredicate __binary_pred)
                               :    {
                               :      // concept requirements
                               :      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
                               :				  _ForwardIterator>)
                               :      __glibcxx_function_requires(_BinaryPredicateConcept<_BinaryPredicate,
                               :		typename iterator_traits<_ForwardIterator>::value_type,
                               :		typename iterator_traits<_ForwardIterator>::value_type>)
                               :      __glibcxx_requires_valid_range(__first, __last);
                               :
                               :      // Skip the beginning, if already unique.
                               :      __first = _GLIBCXX_STD_A::adjacent_find(__first, __last, __binary_pred);
                               :      if (__first == __last)
                               :	return __last;
                               :
                               :      // Do the real copy work.
                               :      _ForwardIterator __dest = __first;
                               :      ++__first;
                               :      while (++__first != __last)
                               :	if (!bool(__binary_pred(*__dest, *__first)))
                               :	  *++__dest = _GLIBCXX_MOVE(*__first);
                               :      return ++__dest;
                               :    }
                               :
                               :  /**
                               :   *  This is an uglified unique_copy(_InputIterator, _InputIterator,
                               :   *                                  _OutputIterator)
                               :   *  overloaded for forward iterators and output iterator as result.
                               :  */
                               :  template<typename _ForwardIterator, typename _OutputIterator>
                               :    _OutputIterator
                               :    __unique_copy(_ForwardIterator __first, _ForwardIterator __last,
                               :		  _OutputIterator __result,
                               :		  forward_iterator_tag, output_iterator_tag)
                               :    {
                               :      // concept requirements -- taken care of in dispatching function
                               :      _ForwardIterator __next = __first;
                               :      *__result = *__first;
                               :      while (++__next != __last)
                               :	if (!(*__first == *__next))
                               :	  {
                               :	    __first = __next;
                               :	    *++__result = *__first;
                               :	  }
                               :      return ++__result;
                               :    }
                               :
                               :  /**
                               :   *  This is an uglified unique_copy(_InputIterator, _InputIterator,
                               :   *                                  _OutputIterator)
                               :   *  overloaded for input iterators and output iterator as result.
                               :  */
                               :  template<typename _InputIterator, typename _OutputIterator>
                               :    _OutputIterator
                               :    __unique_copy(_InputIterator __first, _InputIterator __last,
                               :		  _OutputIterator __result,
                               :		  input_iterator_tag, output_iterator_tag)
                               :    {
                               :      // concept requirements -- taken care of in dispatching function
                               :      typename iterator_traits<_InputIterator>::value_type __value = *__first;
                               :      *__result = __value;
                               :      while (++__first != __last)
                               :	if (!(__value == *__first))
                               :	  {
                               :	    __value = *__first;
                               :	    *++__result = __value;
                               :	  }
                               :      return ++__result;
                               :    }
                               :
                               :  /**
                               :   *  This is an uglified unique_copy(_InputIterator, _InputIterator,
                               :   *                                  _OutputIterator)
                               :   *  overloaded for input iterators and forward iterator as result.
                               :  */
                               :  template<typename _InputIterator, typename _ForwardIterator>
                               :    _ForwardIterator
                               :    __unique_copy(_InputIterator __first, _InputIterator __last,
                               :		  _ForwardIterator __result,
                               :		  input_iterator_tag, forward_iterator_tag)
                               :    {
                               :      // concept requirements -- taken care of in dispatching function
                               :      *__result = *__first;
                               :      while (++__first != __last)
                               :	if (!(*__result == *__first))
                               :	  *++__result = *__first;
                               :      return ++__result;
                               :    }
                               :
                               :  /**
                               :   *  This is an uglified
                               :   *  unique_copy(_InputIterator, _InputIterator, _OutputIterator,
                               :   *              _BinaryPredicate)
                               :   *  overloaded for forward iterators and output iterator as result.
                               :  */
                               :  template<typename _ForwardIterator, typename _OutputIterator,
                               :	   typename _BinaryPredicate>
                               :    _OutputIterator
                               :    __unique_copy(_ForwardIterator __first, _ForwardIterator __last,
                               :		  _OutputIterator __result, _BinaryPredicate __binary_pred,
                               :		  forward_iterator_tag, output_iterator_tag)
                               :    {
                               :      // concept requirements -- iterators already checked
                               :      __glibcxx_function_requires(_BinaryPredicateConcept<_BinaryPredicate,
                               :	  typename iterator_traits<_ForwardIterator>::value_type,
                               :	  typename iterator_traits<_ForwardIterator>::value_type>)
                               :
                               :      _ForwardIterator __next = __first;
                               :      *__result = *__first;
                               :      while (++__next != __last)
                               :	if (!bool(__binary_pred(*__first, *__next)))
                               :	  {
                               :	    __first = __next;
                               :	    *++__result = *__first;
                               :	  }
                               :      return ++__result;
                               :    }
                               :
                               :  /**
                               :   *  This is an uglified
                               :   *  unique_copy(_InputIterator, _InputIterator, _OutputIterator,
                               :   *              _BinaryPredicate)
                               :   *  overloaded for input iterators and output iterator as result.
                               :  */
                               :  template<typename _InputIterator, typename _OutputIterator,
                               :	   typename _BinaryPredicate>
                               :    _OutputIterator
                               :    __unique_copy(_InputIterator __first, _InputIterator __last,
                               :		  _OutputIterator __result, _BinaryPredicate __binary_pred,
                               :		  input_iterator_tag, output_iterator_tag)
                               :    {
                               :      // concept requirements -- iterators already checked
                               :      __glibcxx_function_requires(_BinaryPredicateConcept<_BinaryPredicate,
                               :	  typename iterator_traits<_InputIterator>::value_type,
                               :	  typename iterator_traits<_InputIterator>::value_type>)
                               :
                               :      typename iterator_traits<_InputIterator>::value_type __value = *__first;
                               :      *__result = __value;
                               :      while (++__first != __last)
                               :	if (!bool(__binary_pred(__value, *__first)))
                               :	  {
                               :	    __value = *__first;
                               :	    *++__result = __value;
                               :	  }
                               :      return ++__result;
                               :    }
                               :
                               :  /**
                               :   *  This is an uglified
                               :   *  unique_copy(_InputIterator, _InputIterator, _OutputIterator,
                               :   *              _BinaryPredicate)
                               :   *  overloaded for input iterators and forward iterator as result.
                               :  */
                               :  template<typename _InputIterator, typename _ForwardIterator,
                               :	   typename _BinaryPredicate>
                               :    _ForwardIterator
                               :    __unique_copy(_InputIterator __first, _InputIterator __last,
                               :		  _ForwardIterator __result, _BinaryPredicate __binary_pred,
                               :		  input_iterator_tag, forward_iterator_tag)
                               :    {
                               :      // concept requirements -- iterators already checked
                               :      __glibcxx_function_requires(_BinaryPredicateConcept<_BinaryPredicate,
                               :	  typename iterator_traits<_ForwardIterator>::value_type,
                               :	  typename iterator_traits<_InputIterator>::value_type>)
                               :
                               :      *__result = *__first;
                               :      while (++__first != __last)
                               :	if (!bool(__binary_pred(*__result, *__first)))
                               :	  *++__result = *__first;
                               :      return ++__result;
                               :    }
                               :
                               :  /**
                               :   *  This is an uglified reverse(_BidirectionalIterator,
                               :   *                              _BidirectionalIterator)
                               :   *  overloaded for bidirectional iterators.
                               :  */
                               :  template<typename _BidirectionalIterator>
                               :    void
                               :    __reverse(_BidirectionalIterator __first, _BidirectionalIterator __last,
                               :	      bidirectional_iterator_tag)
                               :    {
                               :      while (true)
                               :	if (__first == __last || __first == --__last)
                               :	  return;
                               :	else
                               :	  {
                               :	    std::iter_swap(__first, __last);
                               :	    ++__first;
                               :	  }
                               :    }
                               :
                               :  /**
                               :   *  This is an uglified reverse(_BidirectionalIterator,
                               :   *                              _BidirectionalIterator)
                               :   *  overloaded for random access iterators.
                               :  */
                               :  template<typename _RandomAccessIterator>
                               :    void
                               :    __reverse(_RandomAccessIterator __first, _RandomAccessIterator __last,
                               :	      random_access_iterator_tag)
                               :    {
                               :      if (__first == __last)
                               :	return;
                               :      --__last;
                               :      while (__first < __last)
                               :	{
                               :	  std::iter_swap(__first, __last);
                               :	  ++__first;
                               :	  --__last;
                               :	}
                               :    }
                               :
                               :  /**
                               :   *  @brief Reverse a sequence.
                               :   *  @ingroup mutating_algorithms
                               :   *  @param  __first  A bidirectional iterator.
                               :   *  @param  __last   A bidirectional iterator.
                               :   *  @return   reverse() returns no value.
                               :   *
                               :   *  Reverses the order of the elements in the range @p [__first,__last),
                               :   *  so that the first element becomes the last etc.
                               :   *  For every @c i such that @p 0<=i<=(__last-__first)/2), @p reverse()
                               :   *  swaps @p *(__first+i) and @p *(__last-(i+1))
                               :  */
                               :  template<typename _BidirectionalIterator>
                               :    inline void
                               :    reverse(_BidirectionalIterator __first, _BidirectionalIterator __last)
                               :    {
                               :      // concept requirements
                               :      __glibcxx_function_requires(_Mutable_BidirectionalIteratorConcept<
                               :				  _BidirectionalIterator>)
                               :      __glibcxx_requires_valid_range(__first, __last);
                               :      std::__reverse(__first, __last, std::__iterator_category(__first));
                               :    }
                               :
                               :  /**
                               :   *  @brief Copy a sequence, reversing its elements.
                               :   *  @ingroup mutating_algorithms
                               :   *  @param  __first   A bidirectional iterator.
                               :   *  @param  __last    A bidirectional iterator.
                               :   *  @param  __result  An output iterator.
                               :   *  @return  An iterator designating the end of the resulting sequence.
                               :   *
                               :   *  Copies the elements in the range @p [__first,__last) to the
                               :   *  range @p [__result,__result+(__last-__first)) such that the
                               :   *  order of the elements is reversed.  For every @c i such that @p
                               :   *  0<=i<=(__last-__first), @p reverse_copy() performs the
                               :   *  assignment @p *(__result+(__last-__first)-1-i) = *(__first+i).
                               :   *  The ranges @p [__first,__last) and @p
                               :   *  [__result,__result+(__last-__first)) must not overlap.
                               :  */
                               :  template<typename _BidirectionalIterator, typename _OutputIterator>
                               :    _OutputIterator
                               :    reverse_copy(_BidirectionalIterator __first, _BidirectionalIterator __last,
                               :		 _OutputIterator __result)
                               :    {
                               :      // concept requirements
                               :      __glibcxx_function_requires(_BidirectionalIteratorConcept<
                               :				  _BidirectionalIterator>)
                               :      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                               :		typename iterator_traits<_BidirectionalIterator>::value_type>)
                               :      __glibcxx_requires_valid_range(__first, __last);
                               :
                               :      while (__first != __last)
                               :	{
                               :	  --__last;
                               :	  *__result = *__last;
                               :	  ++__result;
                               :	}
                               :      return __result;
                               :    }
                               :
                               :  /**
                               :   *  This is a helper function for the rotate algorithm specialized on RAIs.
                               :   *  It returns the greatest common divisor of two integer values.
                               :  */
                               :  template<typename _EuclideanRingElement>
                               :    _EuclideanRingElement
                               :    __gcd(_EuclideanRingElement __m, _EuclideanRingElement __n)
                               :    {
                               :      while (__n != 0)
                               :	{
                               :	  _EuclideanRingElement __t = __m % __n;
                               :	  __m = __n;
                               :	  __n = __t;
                               :	}
                               :      return __m;
                               :    }
                               :
                               :  /// This is a helper function for the rotate algorithm.
                               :  template<typename _ForwardIterator>
                               :    void
                               :    __rotate(_ForwardIterator __first,
                               :	     _ForwardIterator __middle,
                               :	     _ForwardIterator __last,
                               :	     forward_iterator_tag)
                               :    {
                               :      if (__first == __middle || __last  == __middle)
                               :	return;
                               :
                               :      _ForwardIterator __first2 = __middle;
                               :      do
                               :	{
                               :	  std::iter_swap(__first, __first2);
                               :	  ++__first;
                               :	  ++__first2;
                               :	  if (__first == __middle)
                               :	    __middle = __first2;
                               :	}
                               :      while (__first2 != __last);
                               :
                               :      __first2 = __middle;
                               :
                               :      while (__first2 != __last)
                               :	{
                               :	  std::iter_swap(__first, __first2);
                               :	  ++__first;
                               :	  ++__first2;
                               :	  if (__first == __middle)
                               :	    __middle = __first2;
                               :	  else if (__first2 == __last)
                               :	    __first2 = __middle;
                               :	}
                               :    }
                               :
                               :   /// This is a helper function for the rotate algorithm.
                               :  template<typename _BidirectionalIterator>
                               :    void
                               :    __rotate(_BidirectionalIterator __first,
                               :	     _BidirectionalIterator __middle,
                               :	     _BidirectionalIterator __last,
                               :	      bidirectional_iterator_tag)
                               :    {
                               :      // concept requirements
                               :      __glibcxx_function_requires(_Mutable_BidirectionalIteratorConcept<
                               :				  _BidirectionalIterator>)
                               :
                               :      if (__first == __middle || __last  == __middle)
                               :	return;
                               :
                               :      std::__reverse(__first,  __middle, bidirectional_iterator_tag());
                               :      std::__reverse(__middle, __last,   bidirectional_iterator_tag());
                               :
                               :      while (__first != __middle && __middle != __last)
                               :	{
                               :	  std::iter_swap(__first, --__last);
                               :	  ++__first;
                               :	}
                               :
                               :      if (__first == __middle)
                               :	std::__reverse(__middle, __last,   bidirectional_iterator_tag());
                               :      else
                               :	std::__reverse(__first,  __middle, bidirectional_iterator_tag());
                               :    }
                               :
                               :  /// This is a helper function for the rotate algorithm.
                               :  template<typename _RandomAccessIterator>
                               :    void
                               :    __rotate(_RandomAccessIterator __first,
                               :	     _RandomAccessIterator __middle,
                               :	     _RandomAccessIterator __last,
                               :	     random_access_iterator_tag)
                               :    {
                               :      // concept requirements
                               :      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
                               :				  _RandomAccessIterator>)
                               :
                               :      if (__first == __middle || __last  == __middle)
                               :	return;
                               :
                               :      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
                               :	_Distance;
                               :      typedef typename iterator_traits<_RandomAccessIterator>::value_type
                               :	_ValueType;
                               :
                               :      _Distance __n = __last   - __first;
                               :      _Distance __k = __middle - __first;
                               :
                               :      if (__k == __n - __k)
                               :	{
                               :	  std::swap_ranges(__first, __middle, __middle);
                               :	  return;
                               :	}
                               :
                               :      _RandomAccessIterator __p = __first;
                               :
                               :      for (;;)
                               :	{
                               :	  if (__k < __n - __k)
                               :	    {
                               :	      if (__is_pod(_ValueType) && __k == 1)
                               :		{
                               :		  _ValueType __t = _GLIBCXX_MOVE(*__p);
                               :		  _GLIBCXX_MOVE3(__p + 1, __p + __n, __p);
                               :		  *(__p + __n - 1) = _GLIBCXX_MOVE(__t);
                               :		  return;
                               :		}
                               :	      _RandomAccessIterator __q = __p + __k;
                               :	      for (_Distance __i = 0; __i < __n - __k; ++ __i)
                               :		{
                               :		  std::iter_swap(__p, __q);
                               :		  ++__p;
                               :		  ++__q;
                               :		}
                               :	      __n %= __k;
                               :	      if (__n == 0)
                               :		return;
                               :	      std::swap(__n, __k);
                               :	      __k = __n - __k;
                               :	    }
                               :	  else
                               :	    {
                               :	      __k = __n - __k;
                               :	      if (__is_pod(_ValueType) && __k == 1)
                               :		{
                               :		  _ValueType __t = _GLIBCXX_MOVE(*(__p + __n - 1));
                               :		  _GLIBCXX_MOVE_BACKWARD3(__p, __p + __n - 1, __p + __n);
                               :		  *__p = _GLIBCXX_MOVE(__t);
                               :		  return;
                               :		}
                               :	      _RandomAccessIterator __q = __p + __n;
                               :	      __p = __q - __k;
                               :	      for (_Distance __i = 0; __i < __n - __k; ++ __i)
                               :		{
                               :		  --__p;
                               :		  --__q;
                               :		  std::iter_swap(__p, __q);
                               :		}
                               :	      __n %= __k;
                               :	      if (__n == 0)
                               :		return;
                               :	      std::swap(__n, __k);
                               :	    }
                               :	}
                               :    }
                               :
                               :  /**
                               :   *  @brief Rotate the elements of a sequence.
                               :   *  @ingroup mutating_algorithms
                               :   *  @param  __first   A forward iterator.
                               :   *  @param  __middle  A forward iterator.
                               :   *  @param  __last    A forward iterator.
                               :   *  @return  Nothing.
                               :   *
                               :   *  Rotates the elements of the range @p [__first,__last) by 
                               :   *  @p (__middle - __first) positions so that the element at @p __middle
                               :   *  is moved to @p __first, the element at @p __middle+1 is moved to
                               :   *  @p __first+1 and so on for each element in the range
                               :   *  @p [__first,__last).
                               :   *
                               :   *  This effectively swaps the ranges @p [__first,__middle) and
                               :   *  @p [__middle,__last).
                               :   *
                               :   *  Performs
                               :   *   @p *(__first+(n+(__last-__middle))%(__last-__first))=*(__first+n)
                               :   *  for each @p n in the range @p [0,__last-__first).
                               :  */
                               :  template<typename _ForwardIterator>
                               :    inline void
                               :    rotate(_ForwardIterator __first, _ForwardIterator __middle,
                               :	   _ForwardIterator __last)
                               :    {
                               :      // concept requirements
                               :      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
                               :				  _ForwardIterator>)
                               :      __glibcxx_requires_valid_range(__first, __middle);
                               :      __glibcxx_requires_valid_range(__middle, __last);
                               :
                               :      typedef typename iterator_traits<_ForwardIterator>::iterator_category
                               :	_IterType;
                               :      std::__rotate(__first, __middle, __last, _IterType());
                               :    }
                               :
                               :  /**
                               :   *  @brief Copy a sequence, rotating its elements.
                               :   *  @ingroup mutating_algorithms
                               :   *  @param  __first   A forward iterator.
                               :   *  @param  __middle  A forward iterator.
                               :   *  @param  __last    A forward iterator.
                               :   *  @param  __result  An output iterator.
                               :   *  @return   An iterator designating the end of the resulting sequence.
                               :   *
                               :   *  Copies the elements of the range @p [__first,__last) to the
                               :   *  range beginning at @result, rotating the copied elements by 
                               :   *  @p (__middle-__first) positions so that the element at @p __middle
                               :   *  is moved to @p __result, the element at @p __middle+1 is moved
                               :   *  to @p __result+1 and so on for each element in the range @p
                               :   *  [__first,__last).
                               :   *
                               :   *  Performs 
                               :   *  @p *(__result+(n+(__last-__middle))%(__last-__first))=*(__first+n)
                               :   *  for each @p n in the range @p [0,__last-__first).
                               :  */
                               :  template<typename _ForwardIterator, typename _OutputIterator>
                               :    _OutputIterator
                               :    rotate_copy(_ForwardIterator __first, _ForwardIterator __middle,
                               :                _ForwardIterator __last, _OutputIterator __result)
                               :    {
                               :      // concept requirements
                               :      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                               :      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                               :		typename iterator_traits<_ForwardIterator>::value_type>)
                               :      __glibcxx_requires_valid_range(__first, __middle);
                               :      __glibcxx_requires_valid_range(__middle, __last);
                               :
                               :      return std::copy(__first, __middle,
                               :                       std::copy(__middle, __last, __result));
                               :    }
                               :
                               :  /// This is a helper function...
                               :  template<typename _ForwardIterator, typename _Predicate>
                               :    _ForwardIterator
                               :    __partition(_ForwardIterator __first, _ForwardIterator __last,
                               :		_Predicate __pred, forward_iterator_tag)
                               :    {
                               :      if (__first == __last)
                               :	return __first;
                               :
                               :      while (__pred(*__first))
                               :	if (++__first == __last)
                               :	  return __first;
                               :
                               :      _ForwardIterator __next = __first;
                               :
                               :      while (++__next != __last)
                               :	if (__pred(*__next))
                               :	  {
                               :	    std::iter_swap(__first, __next);
                               :	    ++__first;
                               :	  }
                               :
                               :      return __first;
                               :    }
                               :
                               :  /// This is a helper function...
                               :  template<typename _BidirectionalIterator, typename _Predicate>
                               :    _BidirectionalIterator
                               :    __partition(_BidirectionalIterator __first, _BidirectionalIterator __last,
                               :		_Predicate __pred, bidirectional_iterator_tag)
                               :    {
                               :      while (true)
                               :	{
                               :	  while (true)
                               :	    if (__first == __last)
                               :	      return __first;
                               :	    else if (__pred(*__first))
                               :	      ++__first;
                               :	    else
                               :	      break;
                               :	  --__last;
                               :	  while (true)
                               :	    if (__first == __last)
                               :	      return __first;
                               :	    else if (!bool(__pred(*__last)))
                               :	      --__last;
                               :	    else
                               :	      break;
                               :	  std::iter_swap(__first, __last);
                               :	  ++__first;
                               :	}
                               :    }
                               :
                               :  // partition
                               :
                               :  /// This is a helper function...
                               :  /// Requires __len != 0 and !__pred(*__first),
                               :  /// same as __stable_partition_adaptive.
                               :  template<typename _ForwardIterator, typename _Predicate, typename _Distance>
                               :    _ForwardIterator
                               :    __inplace_stable_partition(_ForwardIterator __first,
                               :			       _Predicate __pred, _Distance __len)
                               :    {
                               :      if (__len == 1)
                               :	return __first;
                               :      _ForwardIterator __middle = __first;
                               :      std::advance(__middle, __len / 2);
                               :      _ForwardIterator __left_split =
                               :	std::__inplace_stable_partition(__first, __pred, __len / 2);
                               :      // Advance past true-predicate values to satisfy this
                               :      // function's preconditions.
                               :      _Distance __right_len = __len - __len / 2;
                               :      _ForwardIterator __right_split =
                               :	std::__find_if_not_n(__middle, __right_len, __pred);
                               :      if (__right_len)
                               :	__right_split = std::__inplace_stable_partition(__middle,
                               :							__pred,
                               :							__right_len);
                               :      std::rotate(__left_split, __middle, __right_split);
                               :      std::advance(__left_split, std::distance(__middle, __right_split));
                               :      return __left_split;
                               :    }
                               :
                               :  /// This is a helper function...
                               :  /// Requires __first != __last and !__pred(*__first)
                               :  /// and __len == distance(__first, __last).
                               :  ///
                               :  /// !__pred(*__first) allows us to guarantee that we don't
                               :  /// move-assign an element onto itself.
                               :  template<typename _ForwardIterator, typename _Pointer, typename _Predicate,
                               :	   typename _Distance>
                               :    _ForwardIterator
                               :    __stable_partition_adaptive(_ForwardIterator __first,
                               :				_ForwardIterator __last,
                               :				_Predicate __pred, _Distance __len,
                               :				_Pointer __buffer,
                               :				_Distance __buffer_size)
                               :    {
                               :      if (__len <= __buffer_size)
                               :	{
                               :	  _ForwardIterator __result1 = __first;
                               :	  _Pointer __result2 = __buffer;
                               :	  // The precondition guarantees that !__pred(*__first), so
                               :	  // move that element to the buffer before starting the loop.
                               :	  // This ensures that we only call __pred once per element.
                               :	  *__result2 = _GLIBCXX_MOVE(*__first);
                               :	  ++__result2;
                               :	  ++__first;
                               :	  for (; __first != __last; ++__first)
                               :	    if (__pred(*__first))
                               :	      {
                               :		*__result1 = _GLIBCXX_MOVE(*__first);
                               :		++__result1;
                               :	      }
                               :	    else
                               :	      {
                               :		*__result2 = _GLIBCXX_MOVE(*__first);
                               :		++__result2;
                               :	      }
                               :	  _GLIBCXX_MOVE3(__buffer, __result2, __result1);
                               :	  return __result1;
                               :	}
                               :      else
                               :	{
                               :	  _ForwardIterator __middle = __first;
                               :	  std::advance(__middle, __len / 2);
                               :	  _ForwardIterator __left_split =
                               :	    std::__stable_partition_adaptive(__first, __middle, __pred,
                               :					     __len / 2, __buffer,
                               :					     __buffer_size);
                               :	  // Advance past true-predicate values to satisfy this
                               :	  // function's preconditions.
                               :	  _Distance __right_len = __len - __len / 2;
                               :	  _ForwardIterator __right_split =
                               :	    std::__find_if_not_n(__middle, __right_len, __pred);
                               :	  if (__right_len)
                               :	    __right_split =
                               :	      std::__stable_partition_adaptive(__right_split, __last, __pred,
                               :					       __right_len,
                               :					       __buffer, __buffer_size);
                               :	  std::rotate(__left_split, __middle, __right_split);
                               :	  std::advance(__left_split, std::distance(__middle, __right_split));
                               :	  return __left_split;
                               :	}
                               :    }
                               :
                               :  /**
                               :   *  @brief Move elements for which a predicate is true to the beginning
                               :   *         of a sequence, preserving relative ordering.
                               :   *  @ingroup mutating_algorithms
                               :   *  @param  __first   A forward iterator.
                               :   *  @param  __last    A forward iterator.
                               :   *  @param  __pred    A predicate functor.
                               :   *  @return  An iterator @p middle such that @p __pred(i) is true for each
                               :   *  iterator @p i in the range @p [first,middle) and false for each @p i
                               :   *  in the range @p [middle,last).
                               :   *
                               :   *  Performs the same function as @p partition() with the additional
                               :   *  guarantee that the relative ordering of elements in each group is
                               :   *  preserved, so any two elements @p x and @p y in the range
                               :   *  @p [__first,__last) such that @p __pred(x)==__pred(y) will have the same
                               :   *  relative ordering after calling @p stable_partition().
                               :  */
                               :  template<typename _ForwardIterator, typename _Predicate>
                               :    _ForwardIterator
                               :    stable_partition(_ForwardIterator __first, _ForwardIterator __last,
                               :		     _Predicate __pred)
                               :    {
                               :      // concept requirements
                               :      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
                               :				  _ForwardIterator>)
                               :      __glibcxx_function_requires(_UnaryPredicateConcept<_Predicate,
                               :	    typename iterator_traits<_ForwardIterator>::value_type>)
                               :      __glibcxx_requires_valid_range(__first, __last);
                               :
                               :      __first = std::__find_if_not(__first, __last, __pred);
                               :
                               :      if (__first == __last)
                               :	return __first;
                               :      else
                               :	{
                               :	  typedef typename iterator_traits<_ForwardIterator>::value_type
                               :	    _ValueType;
                               :	  typedef typename iterator_traits<_ForwardIterator>::difference_type
                               :	    _DistanceType;
                               :
                               :	  _Temporary_buffer<_ForwardIterator, _ValueType> __buf(__first,
                               :								__last);
                               :	if (__buf.size() > 0)
                               :	  return
                               :	    std::__stable_partition_adaptive(__first, __last, __pred,
                               :					  _DistanceType(__buf.requested_size()),
                               :					  __buf.begin(),
                               :					  _DistanceType(__buf.size()));
                               :	else
                               :	  return
                               :	    std::__inplace_stable_partition(__first, __pred,
                               :					 _DistanceType(__buf.requested_size()));
                               :	}
                               :    }
                               :
                               :  /// This is a helper function for the sort routines.
                               :  template<typename _RandomAccessIterator>
                               :    void
                               :    __heap_select(_RandomAccessIterator __first,
                               :		  _RandomAccessIterator __middle,
                               :		  _RandomAccessIterator __last)
                               :    {
                               :      std::make_heap(__first, __middle);
                               :      for (_RandomAccessIterator __i = __middle; __i < __last; ++__i)
                               :	if (*__i < *__first)
                               :	  std::__pop_heap(__first, __middle, __i);
                               :    }
                               :
                               :  /// This is a helper function for the sort routines.
                               :  template<typename _RandomAccessIterator, typename _Compare>
                               :    void
                               :    __heap_select(_RandomAccessIterator __first,
                               :		  _RandomAccessIterator __middle,
                               :		  _RandomAccessIterator __last, _Compare __comp)
                               :    {
                               :      std::make_heap(__first, __middle, __comp);
                               :      for (_RandomAccessIterator __i = __middle; __i < __last; ++__i)
                               :	if (__comp(*__i, *__first))
                               :	  std::__pop_heap(__first, __middle, __i, __comp);
                               :    }
                               :
                               :  // partial_sort
                               :
                               :  /**
                               :   *  @brief Copy the smallest elements of a sequence.
                               :   *  @ingroup sorting_algorithms
                               :   *  @param  __first   An iterator.
                               :   *  @param  __last    Another iterator.
                               :   *  @param  __result_first   A random-access iterator.
                               :   *  @param  __result_last    Another random-access iterator.
                               :   *  @return   An iterator indicating the end of the resulting sequence.
                               :   *
                               :   *  Copies and sorts the smallest N values from the range @p [__first,__last)
                               :   *  to the range beginning at @p __result_first, where the number of
                               :   *  elements to be copied, @p N, is the smaller of @p (__last-__first) and
                               :   *  @p (__result_last-__result_first).
                               :   *  After the sort if @e i and @e j are iterators in the range
                               :   *  @p [__result_first,__result_first+N) such that i precedes j then
                               :   *  *j<*i is false.
                               :   *  The value returned is @p __result_first+N.
                               :  */
                               :  template<typename _InputIterator, typename _RandomAccessIterator>
                               :    _RandomAccessIterator
                               :    partial_sort_copy(_InputIterator __first, _InputIterator __last,
                               :		      _RandomAccessIterator __result_first,
                               :		      _RandomAccessIterator __result_last)
                               :    {
                               :      typedef typename iterator_traits<_InputIterator>::value_type
                               :	_InputValueType;
                               :      typedef typename iterator_traits<_RandomAccessIterator>::value_type
                               :	_OutputValueType;
                               :      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
                               :	_DistanceType;
                               :
                               :      // concept requirements
                               :      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
                               :      __glibcxx_function_requires(_ConvertibleConcept<_InputValueType,
                               :				  _OutputValueType>)
                               :      __glibcxx_function_requires(_LessThanOpConcept<_InputValueType,
                               :				                     _OutputValueType>)
                               :      __glibcxx_function_requires(_LessThanComparableConcept<_OutputValueType>)
                               :      __glibcxx_requires_valid_range(__first, __last);
                               :      __glibcxx_requires_valid_range(__result_first, __result_last);
                               :
                               :      if (__result_first == __result_last)
                               :	return __result_last;
                               :      _RandomAccessIterator __result_real_last = __result_first;
                               :      while(__first != __last && __result_real_last != __result_last)
                               :	{
                               :	  *__result_real_last = *__first;
                               :	  ++__result_real_last;
                               :	  ++__first;
                               :	}
                               :      std::make_heap(__result_first, __result_real_last);
                               :      while (__first != __last)
                               :	{
                               :	  if (*__first < *__result_first)
                               :	    std::__adjust_heap(__result_first, _DistanceType(0),
                               :			       _DistanceType(__result_real_last
                               :					     - __result_first),
                               :			       _InputValueType(*__first));
                               :	  ++__first;
                               :	}
                               :      std::sort_heap(__result_first, __result_real_last);
                               :      return __result_real_last;
                               :    }
                               :
                               :  /**
                               :   *  @brief Copy the smallest elements of a sequence using a predicate for
                               :   *         comparison.
                               :   *  @ingroup sorting_algorithms
                               :   *  @param  __first   An input iterator.
                               :   *  @param  __last    Another input iterator.
                               :   *  @param  __result_first   A random-access iterator.
                               :   *  @param  __result_last    Another random-access iterator.
                               :   *  @param  __comp    A comparison functor.
                               :   *  @return   An iterator indicating the end of the resulting sequence.
                               :   *
                               :   *  Copies and sorts the smallest N values from the range @p [__first,__last)
                               :   *  to the range beginning at @p result_first, where the number of
                               :   *  elements to be copied, @p N, is the smaller of @p (__last-__first) and
                               :   *  @p (__result_last-__result_first).
                               :   *  After the sort if @e i and @e j are iterators in the range
                               :   *  @p [__result_first,__result_first+N) such that i precedes j then
                               :   *  @p __comp(*j,*i) is false.
                               :   *  The value returned is @p __result_first+N.
                               :  */
                               :  template<typename _InputIterator, typename _RandomAccessIterator, typename _Compare>
                               :    _RandomAccessIterator
                               :    partial_sort_copy(_InputIterator __first, _InputIterator __last,
                               :		      _RandomAccessIterator __result_first,
                               :		      _RandomAccessIterator __result_last,
                               :		      _Compare __comp)
                               :    {
                               :      typedef typename iterator_traits<_InputIterator>::value_type
                               :	_InputValueType;
                               :      typedef typename iterator_traits<_RandomAccessIterator>::value_type
                               :	_OutputValueType;
                               :      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
                               :	_DistanceType;
                               :
                               :      // concept requirements
                               :      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
                               :      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
                               :				  _RandomAccessIterator>)
                               :      __glibcxx_function_requires(_ConvertibleConcept<_InputValueType,
                               :				  _OutputValueType>)
                               :      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
                               :				  _InputValueType, _OutputValueType>)
                               :      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
                               :				  _OutputValueType, _OutputValueType>)
                               :      __glibcxx_requires_valid_range(__first, __last);
                               :      __glibcxx_requires_valid_range(__result_first, __result_last);
                               :
                               :      if (__result_first == __result_last)
                               :	return __result_last;
                               :      _RandomAccessIterator __result_real_last = __result_first;
                               :      while(__first != __last && __result_real_last != __result_last)
                               :	{
                               :	  *__result_real_last = *__first;
                               :	  ++__result_real_last;
                               :	  ++__first;
                               :	}
                               :      std::make_heap(__result_first, __result_real_last, __comp);
                               :      while (__first != __last)
                               :	{
                               :	  if (__comp(*__first, *__result_first))
                               :	    std::__adjust_heap(__result_first, _DistanceType(0),
                               :			       _DistanceType(__result_real_last
                               :					     - __result_first),
                               :			       _InputValueType(*__first),
                               :			       __comp);
                               :	  ++__first;
                               :	}
                               :      std::sort_heap(__result_first, __result_real_last, __comp);
                               :      return __result_real_last;
                               :    }
                               :
                               :  /// This is a helper function for the sort routine.
                               :  template<typename _RandomAccessIterator>
                               :    void
                               :    __unguarded_linear_insert(_RandomAccessIterator __last)
                               :    {
                               :      typename iterator_traits<_RandomAccessIterator>::value_type
                               :	__val = _GLIBCXX_MOVE(*__last);
                               :      _RandomAccessIterator __next = __last;
                               :      --__next;
                               :      while (__val < *__next)
                               :	{
                               :	  *__last = _GLIBCXX_MOVE(*__next);
                               :	  __last = __next;
                               :	  --__next;
                               :	}
                               :      *__last = _GLIBCXX_MOVE(__val);
                               :    }
                               :
                               :  /// This is a helper function for the sort routine.
                               :  template<typename _RandomAccessIterator, typename _Compare>
                               :    void
                               :    __unguarded_linear_insert(_RandomAccessIterator __last,
                               :			      _Compare __comp)
                               :    {
                               :      typename iterator_traits<_RandomAccessIterator>::value_type
                               :	__val = _GLIBCXX_MOVE(*__last);
                               :      _RandomAccessIterator __next = __last;
                               :      --__next;
    53  0.0451     0       0   :      while (__comp(__val, *__next))
                               :	{
    15  0.0128     0       0   :	  *__last = _GLIBCXX_MOVE(*__next);
                               :	  __last = __next;
                               :	  --__next;
                               :	}
    37  0.0315     0       0   :      *__last = _GLIBCXX_MOVE(__val);
                               :    }
                               :
                               :  /// This is a helper function for the sort routine.
                               :  template<typename _RandomAccessIterator>
                               :    void
                               :    __insertion_sort(_RandomAccessIterator __first,
                               :		     _RandomAccessIterator __last)
                               :    {
                               :      if (__first == __last)
                               :	return;
                               :
                               :      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
                               :	{
                               :	  if (*__i < *__first)
                               :	    {
                               :	      typename iterator_traits<_RandomAccessIterator>::value_type
                               :		__val = _GLIBCXX_MOVE(*__i);
                               :	      _GLIBCXX_MOVE_BACKWARD3(__first, __i, __i + 1);
                               :	      *__first = _GLIBCXX_MOVE(__val);
                               :	    }
                               :	  else
                               :	    std::__unguarded_linear_insert(__i);
                               :	}
                               :    }
                               :
                               :  /// This is a helper function for the sort routine.
                               :  template<typename _RandomAccessIterator, typename _Compare>
                               :    void
     5  0.0043     0       0   :    __insertion_sort(_RandomAccessIterator __first, /* void std::__insertion_sort<__gnu_cxx::__normal_iterator<Path**, std::vector<Path*, std::allocator<Path*> > >, bool (*)(Path*, Path*)>(__gnu_cxx::__normal_iterator<Path**, std::vector<Path*, std::allocator<Path*> > >, __gnu_cxx::__normal_iterator<Path**, std::vector<Path*, std::allocator<Path*> > >, bool (*)(Path*, Path*)) total:      6  0.0051     0       0 */
                               :		     _RandomAccessIterator __last, _Compare __comp)
                               :    {
     3  0.0026     0       0   :      if (__first == __last) return;
                               :
    17  0.0145     0       0   :      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
                               :	{
    85  0.0723     9  0.5316   :	  if (__comp(*__i, *__first))
                               :	    {
                               :	      typename iterator_traits<_RandomAccessIterator>::value_type
                               :		__val = _GLIBCXX_MOVE(*__i);
                               :	      _GLIBCXX_MOVE_BACKWARD3(__first, __i, __i + 1);
     4  0.0034     0       0   :	      *__first = _GLIBCXX_MOVE(__val);
                               :	    }
                               :	  else
                               :	    std::__unguarded_linear_insert(__i, __comp);
                               :	}
     1 8.5e-04     0       0   :    }
                               :
                               :  /// This is a helper function for the sort routine.
                               :  template<typename _RandomAccessIterator>
                               :    inline void
                               :    __unguarded_insertion_sort(_RandomAccessIterator __first,
                               :			       _RandomAccessIterator __last)
                               :    {
                               :      typedef typename iterator_traits<_RandomAccessIterator>::value_type
                               :	_ValueType;
                               :
                               :      for (_RandomAccessIterator __i = __first; __i != __last; ++__i)
                               :	std::__unguarded_linear_insert(__i);
                               :    }
                               :
                               :  /// This is a helper function for the sort routine.
                               :  template<typename _RandomAccessIterator, typename _Compare>
                               :    inline void
                               :    __unguarded_insertion_sort(_RandomAccessIterator __first,
                               :			       _RandomAccessIterator __last, _Compare __comp)
                               :    {
                               :      typedef typename iterator_traits<_RandomAccessIterator>::value_type
                               :	_ValueType;
                               :
                               :      for (_RandomAccessIterator __i = __first; __i != __last; ++__i)
                               :	std::__unguarded_linear_insert(__i, __comp);
                               :    }
                               :
                               :  /**
                               :   *  @doctodo
                               :   *  This controls some aspect of the sort routines.
                               :  */
                               :  enum { _S_threshold = 16 };
                               :
                               :  /// This is a helper function for the sort routine.
                               :  template<typename _RandomAccessIterator>
                               :    void
                               :    __final_insertion_sort(_RandomAccessIterator __first,
                               :			   _RandomAccessIterator __last)
                               :    {
                               :      if (__last - __first > int(_S_threshold))
                               :	{
                               :	  std::__insertion_sort(__first, __first + int(_S_threshold));
                               :	  std::__unguarded_insertion_sort(__first + int(_S_threshold), __last);
                               :	}
                               :      else
                               :	std::__insertion_sort(__first, __last);
                               :    }
                               :
                               :  /// This is a helper function for the sort routine.
                               :  template<typename _RandomAccessIterator, typename _Compare>
                               :    void
                               :    __final_insertion_sort(_RandomAccessIterator __first,
                               :			   _RandomAccessIterator __last, _Compare __comp)
                               :    {
                               :      if (__last - __first > int(_S_threshold))
                               :	{
                               :	  std::__insertion_sort(__first, __first + int(_S_threshold), __comp);
                               :	  std::__unguarded_insertion_sort(__first + int(_S_threshold), __last,
                               :					  __comp);
                               :	}
                               :      else
                               :	std::__insertion_sort(__first, __last, __comp);
                               :    }
                               :
                               :  /// This is a helper function...
                               :  template<typename _RandomAccessIterator, typename _Tp>
                               :    _RandomAccessIterator
                               :    __unguarded_partition(_RandomAccessIterator __first,
                               :			  _RandomAccessIterator __last, const _Tp& __pivot)
                               :    {
                               :      while (true)
                               :	{
                               :	  while (*__first < __pivot)
                               :	    ++__first;
                               :	  --__last;
                               :	  while (__pivot < *__last)
                               :	    --__last;
                               :	  if (!(__first < __last))
                               :	    return __first;
                               :	  std::iter_swap(__first, __last);
                               :	  ++__first;
                               :	}
                               :    }
                               :
                               :  /// This is a helper function...
                               :  template<typename _RandomAccessIterator, typename _Tp, typename _Compare>
                               :    _RandomAccessIterator
                               :    __unguarded_partition(_RandomAccessIterator __first,
                               :			  _RandomAccessIterator __last,
                               :			  const _Tp& __pivot, _Compare __comp)
                               :    {
                               :      while (true)
                               :	{
                               :	  while (__comp(*__first, __pivot))
                               :	    ++__first;
                               :	  --__last;
                               :	  while (__comp(__pivot, *__last))
                               :	    --__last;
                               :	  if (!(__first < __last))
                               :	    return __first;
                               :	  std::iter_swap(__first, __last);
                               :	  ++__first;
                               :	}
                               :    }
                               :
                               :  /// This is a helper function...
                               :  template<typename _RandomAccessIterator>
                               :    inline _RandomAccessIterator
                               :    __unguarded_partition_pivot(_RandomAccessIterator __first,
                               :				_RandomAccessIterator __last)
                               :    {
                               :      _RandomAccessIterator __mid = __first + (__last - __first) / 2;
                               :      std::__move_median_to_first(__first, __first + 1, __mid, __last - 1);
                               :      return std::__unguarded_partition(__first + 1, __last, *__first);
                               :    }
                               :
                               :
                               :  /// This is a helper function...
                               :  template<typename _RandomAccessIterator, typename _Compare>
                               :    inline _RandomAccessIterator
                               :    __unguarded_partition_pivot(_RandomAccessIterator __first,
                               :				_RandomAccessIterator __last, _Compare __comp)
                               :    {
                               :      _RandomAccessIterator __mid = __first + (__last - __first) / 2;
                               :      std::__move_median_to_first(__first, __first + 1, __mid, __last - 1,
                               :				  __comp);
                               :      return std::__unguarded_partition(__first + 1, __last, *__first, __comp);
                               :    }
                               :
                               :  /// This is a helper function for the sort routine.
                               :  template<typename _RandomAccessIterator, typename _Size>
                               :    void
                               :    __introsort_loop(_RandomAccessIterator __first,
                               :		     _RandomAccessIterator __last,
                               :		     _Size __depth_limit)
                               :    {
                               :      while (__last - __first > int(_S_threshold))
                               :	{
                               :	  if (__depth_limit == 0)
                               :	    {
                               :	      _GLIBCXX_STD_A::partial_sort(__first, __last, __last);
                               :	      return;
                               :	    }
                               :	  --__depth_limit;
                               :	  _RandomAccessIterator __cut =
                               :	    std::__unguarded_partition_pivot(__first, __last);
                               :	  std::__introsort_loop(__cut, __last, __depth_limit);
                               :	  __last = __cut;
                               :	}
                               :    }
                               :
                               :  /// This is a helper function for the sort routine.
                               :  template<typename _RandomAccessIterator, typename _Size, typename _Compare>
                               :    void
                               :    __introsort_loop(_RandomAccessIterator __first,
                               :		     _RandomAccessIterator __last,
                               :		     _Size __depth_limit, _Compare __comp)
                               :    {
                               :      while (__last - __first > int(_S_threshold))
                               :	{
                               :	  if (__depth_limit == 0)
                               :	    {
                               :	      _GLIBCXX_STD_A::partial_sort(__first, __last, __last, __comp);
                               :	      return;
                               :	    }
                               :	  --__depth_limit;
                               :	  _RandomAccessIterator __cut =
                               :	    std::__unguarded_partition_pivot(__first, __last, __comp);
                               :	  std::__introsort_loop(__cut, __last, __depth_limit, __comp);
                               :	  __last = __cut;
                               :	}
                               :    }
                               :
                               :  // sort
                               :
                               :  template<typename _RandomAccessIterator, typename _Size>
                               :    void
                               :    __introselect(_RandomAccessIterator __first, _RandomAccessIterator __nth,
                               :		  _RandomAccessIterator __last, _Size __depth_limit)
                               :    {
                               :      typedef typename iterator_traits<_RandomAccessIterator>::value_type
                               :	_ValueType;
                               :
                               :      while (__last - __first > 3)
                               :	{
                               :	  if (__depth_limit == 0)
                               :	    {
                               :	      std::__heap_select(__first, __nth + 1, __last);
                               :
                               :	      // Place the nth largest element in its final position.
                               :	      std::iter_swap(__first, __nth);
                               :	      return;
                               :	    }
                               :	  --__depth_limit;
                               :	  _RandomAccessIterator __cut =
                               :	    std::__unguarded_partition_pivot(__first, __last);
                               :	  if (__cut <= __nth)
                               :	    __first = __cut;
                               :	  else
                               :	    __last = __cut;
                               :	}
                               :      std::__insertion_sort(__first, __last);
                               :    }
                               :
                               :  template<typename _RandomAccessIterator, typename _Size, typename _Compare>
                               :    void
                               :    __introselect(_RandomAccessIterator __first, _RandomAccessIterator __nth,
                               :		  _RandomAccessIterator __last, _Size __depth_limit,
                               :		  _Compare __comp)
                               :    {
                               :      typedef typename iterator_traits<_RandomAccessIterator>::value_type
                               :	_ValueType;
                               :
                               :      while (__last - __first > 3)
                               :	{
                               :	  if (__depth_limit == 0)
                               :	    {
                               :	      std::__heap_select(__first, __nth + 1, __last, __comp);
                               :	      // Place the nth largest element in its final position.
                               :	      std::iter_swap(__first, __nth);
                               :	      return;
                               :	    }
                               :	  --__depth_limit;
                               :	  _RandomAccessIterator __cut =
                               :	    std::__unguarded_partition_pivot(__first, __last, __comp);
                               :	  if (__cut <= __nth)
                               :	    __first = __cut;
                               :	  else
                               :	    __last = __cut;
                               :	}
                               :      std::__insertion_sort(__first, __last, __comp);
                               :    }
                               :
                               :  // nth_element
                               :
                               :  // lower_bound moved to stl_algobase.h
                               :
                               :  /**
                               :   *  @brief Finds the first position in which @p __val could be inserted
                               :   *         without changing the ordering.
                               :   *  @ingroup binary_search_algorithms
                               :   *  @param  __first   An iterator.
                               :   *  @param  __last    Another iterator.
                               :   *  @param  __val     The search term.
                               :   *  @param  __comp    A functor to use for comparisons.
                               :   *  @return An iterator pointing to the first element <em>not less
                               :   *           than</em> @p __val, or end() if every element is less
                               :   *           than @p __val.
                               :   *  @ingroup binary_search_algorithms
                               :   *
                               :   *  The comparison function should have the same effects on ordering as
                               :   *  the function used for the initial sort.
                               :  */
                               :  template<typename _ForwardIterator, typename _Tp, typename _Compare>
                               :    _ForwardIterator
                               :    lower_bound(_ForwardIterator __first, _ForwardIterator __last,
                               :		const _Tp& __val, _Compare __comp)
                               :    {
                               :      typedef typename iterator_traits<_ForwardIterator>::value_type
                               :	_ValueType;
                               :      typedef typename iterator_traits<_ForwardIterator>::difference_type
                               :	_DistanceType;
                               :
                               :      // concept requirements
                               :      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                               :      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
                               :				  _ValueType, _Tp>)
                               :      __glibcxx_requires_partitioned_lower_pred(__first, __last,
                               :						__val, __comp);
                               :
                               :      _DistanceType __len = std::distance(__first, __last);
                               :
                               :      while (__len > 0)
                               :	{
                               :	  _DistanceType __half = __len >> 1;
                               :	  _ForwardIterator __middle = __first;
                               :	  std::advance(__middle, __half);
                               :	  if (__comp(*__middle, __val))
                               :	    {
                               :	      __first = __middle;
                               :	      ++__first;
                               :	      __len = __len - __half - 1;
                               :	    }
                               :	  else
                               :	    __len = __half;
                               :	}
                               :      return __first;
                               :    }
                               :
                               :  /**
                               :   *  @brief Finds the last position in which @p __val could be inserted
                               :   *         without changing the ordering.
                               :   *  @ingroup binary_search_algorithms
                               :   *  @param  __first   An iterator.
                               :   *  @param  __last    Another iterator.
                               :   *  @param  __val     The search term.
                               :   *  @return  An iterator pointing to the first element greater than @p __val,
                               :   *           or end() if no elements are greater than @p __val.
                               :   *  @ingroup binary_search_algorithms
                               :  */
                               :  template<typename _ForwardIterator, typename _Tp>
                               :    _ForwardIterator
                               :    upper_bound(_ForwardIterator __first, _ForwardIterator __last,
                               :		const _Tp& __val)
                               :    {
                               :      typedef typename iterator_traits<_ForwardIterator>::value_type
                               :	_ValueType;
                               :      typedef typename iterator_traits<_ForwardIterator>::difference_type
                               :	_DistanceType;
                               :
                               :      // concept requirements
                               :      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                               :      __glibcxx_function_requires(_LessThanOpConcept<_Tp, _ValueType>)
                               :      __glibcxx_requires_partitioned_upper(__first, __last, __val);
                               :
                               :      _DistanceType __len = std::distance(__first, __last);
                               :
                               :      while (__len > 0)
                               :	{
                               :	  _DistanceType __half = __len >> 1;
                               :	  _ForwardIterator __middle = __first;
                               :	  std::advance(__middle, __half);
                               :	  if (__val < *__middle)
                               :	    __len = __half;
                               :	  else
                               :	    {
                               :	      __first = __middle;
                               :	      ++__first;
                               :	      __len = __len - __half - 1;
                               :	    }
                               :	}
                               :      return __first;
                               :    }
                               :
                               :  /**
                               :   *  @brief Finds the last position in which @p __val could be inserted
                               :   *         without changing the ordering.
                               :   *  @ingroup binary_search_algorithms
                               :   *  @param  __first   An iterator.
                               :   *  @param  __last    Another iterator.
                               :   *  @param  __val     The search term.
                               :   *  @param  __comp    A functor to use for comparisons.
                               :   *  @return  An iterator pointing to the first element greater than @p __val,
                               :   *           or end() if no elements are greater than @p __val.
                               :   *  @ingroup binary_search_algorithms
                               :   *
                               :   *  The comparison function should have the same effects on ordering as
                               :   *  the function used for the initial sort.
                               :  */
                               :  template<typename _ForwardIterator, typename _Tp, typename _Compare>
                               :    _ForwardIterator
                               :    upper_bound(_ForwardIterator __first, _ForwardIterator __last,
                               :		const _Tp& __val, _Compare __comp)
                               :    {
                               :      typedef typename iterator_traits<_ForwardIterator>::value_type
                               :	_ValueType;
                               :      typedef typename iterator_traits<_ForwardIterator>::difference_type
                               :	_DistanceType;
                               :
                               :      // concept requirements
                               :      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                               :      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
                               :				  _Tp, _ValueType>)
                               :      __glibcxx_requires_partitioned_upper_pred(__first, __last,
                               :						__val, __comp);
                               :
                               :      _DistanceType __len = std::distance(__first, __last);
                               :
                               :      while (__len > 0)
                               :	{
                               :	  _DistanceType __half = __len >> 1;
                               :	  _ForwardIterator __middle = __first;
                               :	  std::advance(__middle, __half);
                               :	  if (__comp(__val, *__middle))
                               :	    __len = __half;
                               :	  else
                               :	    {
                               :	      __first = __middle;
                               :	      ++__first;
                               :	      __len = __len - __half - 1;
                               :	    }
                               :	}
                               :      return __first;
                               :    }
                               :
                               :  /**
                               :   *  @brief Finds the largest subrange in which @p __val could be inserted
                               :   *         at any place in it without changing the ordering.
                               :   *  @ingroup binary_search_algorithms
                               :   *  @param  __first   An iterator.
                               :   *  @param  __last    Another iterator.
                               :   *  @param  __val     The search term.
                               :   *  @return  An pair of iterators defining the subrange.
                               :   *  @ingroup binary_search_algorithms
                               :   *
                               :   *  This is equivalent to
                               :   *  @code
                               :   *    std::make_pair(lower_bound(__first, __last, __val),
                               :   *                   upper_bound(__first, __last, __val))
                               :   *  @endcode
                               :   *  but does not actually call those functions.
                               :  */
                               :  template<typename _ForwardIterator, typename _Tp>
                               :    pair<_ForwardIterator, _ForwardIterator>
                               :    equal_range(_ForwardIterator __first, _ForwardIterator __last,
                               :		const _Tp& __val)
                               :    {
                               :      typedef typename iterator_traits<_ForwardIterator>::value_type
                               :	_ValueType;
                               :      typedef typename iterator_traits<_ForwardIterator>::difference_type
                               :	_DistanceType;
                               :
                               :      // concept requirements
                               :      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                               :      __glibcxx_function_requires(_LessThanOpConcept<_ValueType, _Tp>)
                               :      __glibcxx_function_requires(_LessThanOpConcept<_Tp, _ValueType>)	
                               :      __glibcxx_requires_partitioned_lower(__first, __last, __val);
                               :      __glibcxx_requires_partitioned_upper(__first, __last, __val);      
                               :
                               :      _DistanceType __len = std::distance(__first, __last);
                               : 
                               :      while (__len > 0)
                               :	{
                               :	  _DistanceType __half = __len >> 1;
                               :	  _ForwardIterator __middle = __first;
                               :	  std::advance(__middle, __half);
                               :	  if (*__middle < __val)
                               :	    {
                               :	      __first = __middle;
                               :	      ++__first;
                               :	      __len = __len - __half - 1;
                               :	    }
                               :	  else if (__val < *__middle)
                               :	    __len = __half;
                               :	  else
                               :	    {
                               :	      _ForwardIterator __left = std::lower_bound(__first, __middle,
                               :							 __val);
                               :	      std::advance(__first, __len);
                               :	      _ForwardIterator __right = std::upper_bound(++__middle, __first,
                               :							  __val);
                               :	      return pair<_ForwardIterator, _ForwardIterator>(__left, __right);
                               :	    }
                               :	}
                               :      return pair<_ForwardIterator, _ForwardIterator>(__first, __first);
                               :    }
                               :
                               :  /**
                               :   *  @brief Finds the largest subrange in which @p __val could be inserted
                               :   *         at any place in it without changing the ordering.
                               :   *  @param  __first   An iterator.
                               :   *  @param  __last    Another iterator.
                               :   *  @param  __val     The search term.
                               :   *  @param  __comp    A functor to use for comparisons.
                               :   *  @return  An pair of iterators defining the subrange.
                               :   *  @ingroup binary_search_algorithms
                               :   *
                               :   *  This is equivalent to
                               :   *  @code
                               :   *    std::make_pair(lower_bound(__first, __last, __val, __comp),
                               :   *                   upper_bound(__first, __last, __val, __comp))
                               :   *  @endcode
                               :   *  but does not actually call those functions.
                               :  */
                               :  template<typename _ForwardIterator, typename _Tp, typename _Compare>
                               :    pair<_ForwardIterator, _ForwardIterator>
                               :    equal_range(_ForwardIterator __first, _ForwardIterator __last,
                               :		const _Tp& __val, _Compare __comp)
                               :    {
                               :      typedef typename iterator_traits<_ForwardIterator>::value_type
                               :	_ValueType;
                               :      typedef typename iterator_traits<_ForwardIterator>::difference_type
                               :	_DistanceType;
                               :
                               :      // concept requirements
                               :      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                               :      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
                               :				  _ValueType, _Tp>)
                               :      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
                               :				  _Tp, _ValueType>)
                               :      __glibcxx_requires_partitioned_lower_pred(__first, __last,
                               :						__val, __comp);
                               :      __glibcxx_requires_partitioned_upper_pred(__first, __last,
                               :						__val, __comp);
                               :
                               :      _DistanceType __len = std::distance(__first, __last);
                               :
                               :      while (__len > 0)
                               :	{
                               :	  _DistanceType __half = __len >> 1;
                               :	  _ForwardIterator __middle = __first;
                               :	  std::advance(__middle, __half);
                               :	  if (__comp(*__middle, __val))
                               :	    {
                               :	      __first = __middle;
                               :	      ++__first;
                               :	      __len = __len - __half - 1;
                               :	    }
                               :	  else if (__comp(__val, *__middle))
                               :	    __len = __half;
                               :	  else
                               :	    {
                               :	      _ForwardIterator __left = std::lower_bound(__first, __middle,
                               :							 __val, __comp);
                               :	      std::advance(__first, __len);
                               :	      _ForwardIterator __right = std::upper_bound(++__middle, __first,
                               :							  __val, __comp);
                               :	      return pair<_ForwardIterator, _ForwardIterator>(__left, __right);
                               :	    }
                               :	}
                               :      return pair<_ForwardIterator, _ForwardIterator>(__first, __first);
                               :    }
                               :
                               :  /**
                               :   *  @brief Determines whether an element exists in a range.
                               :   *  @ingroup binary_search_algorithms
                               :   *  @param  __first   An iterator.
                               :   *  @param  __last    Another iterator.
                               :   *  @param  __val     The search term.
                               :   *  @return True if @p __val (or its equivalent) is in [@p
                               :   *  __first,@p __last ].
                               :   *
                               :   *  Note that this does not actually return an iterator to @p __val.  For
                               :   *  that, use std::find or a container's specialized find member functions.
                               :  */
                               :  template<typename _ForwardIterator, typename _Tp>
                               :    bool
                               :    binary_search(_ForwardIterator __first, _ForwardIterator __last,
                               :                  const _Tp& __val)
                               :    {
                               :      typedef typename iterator_traits<_ForwardIterator>::value_type
                               :	_ValueType;
                               :
                               :      // concept requirements
                               :      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                               :      __glibcxx_function_requires(_LessThanOpConcept<_Tp, _ValueType>)
                               :      __glibcxx_requires_partitioned_lower(__first, __last, __val);
                               :      __glibcxx_requires_partitioned_upper(__first, __last, __val);
                               :
                               :      _ForwardIterator __i = std::lower_bound(__first, __last, __val);
                               :      return __i != __last && !(__val < *__i);
                               :    }
                               :
                               :  /**
                               :   *  @brief Determines whether an element exists in a range.
                               :   *  @ingroup binary_search_algorithms
                               :   *  @param  __first   An iterator.
                               :   *  @param  __last    Another iterator.
                               :   *  @param  __val     The search term.
                               :   *  @param  __comp    A functor to use for comparisons.
                               :   *  @return  True if @p __val (or its equivalent) is in @p [__first,__last].
                               :   *
                               :   *  Note that this does not actually return an iterator to @p __val.  For
                               :   *  that, use std::find or a container's specialized find member functions.
                               :   *
                               :   *  The comparison function should have the same effects on ordering as
                               :   *  the function used for the initial sort.
                               :  */
                               :  template<typename _ForwardIterator, typename _Tp, typename _Compare>
                               :    bool
                               :    binary_search(_ForwardIterator __first, _ForwardIterator __last,
                               :                  const _Tp& __val, _Compare __comp)
                               :    {
                               :      typedef typename iterator_traits<_ForwardIterator>::value_type
                               :	_ValueType;
                               :
                               :      // concept requirements
                               :      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                               :      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
                               :				  _Tp, _ValueType>)
                               :      __glibcxx_requires_partitioned_lower_pred(__first, __last,
                               :						__val, __comp);
                               :      __glibcxx_requires_partitioned_upper_pred(__first, __last,
                               :						__val, __comp);
                               :
                               :      _ForwardIterator __i = std::lower_bound(__first, __last, __val, __comp);
                               :      return __i != __last && !bool(__comp(__val, *__i));
                               :    }
                               :
                               :  // merge
                               :
                               :  /// This is a helper function for the __merge_adaptive routines.
                               :  template<typename _InputIterator1, typename _InputIterator2,
                               :	   typename _OutputIterator>
                               :    void
                               :    __move_merge_adaptive(_InputIterator1 __first1, _InputIterator1 __last1,
                               :			  _InputIterator2 __first2, _InputIterator2 __last2,
                               :			  _OutputIterator __result)
                               :    {
                               :      while (__first1 != __last1 && __first2 != __last2)
                               :	{
                               :	  if (*__first2 < *__first1)
                               :	    {
                               :	      *__result = _GLIBCXX_MOVE(*__first2);
                               :	      ++__first2;
                               :	    }
                               :	  else
                               :	    {
                               :	      *__result = _GLIBCXX_MOVE(*__first1);
                               :	      ++__first1;
                               :	    }
                               :	  ++__result;
                               :	}
                               :      if (__first1 != __last1)
                               :	_GLIBCXX_MOVE3(__first1, __last1, __result);
                               :    }
                               :
                               :  /// This is a helper function for the __merge_adaptive routines.
                               :  template<typename _InputIterator1, typename _InputIterator2,
                               :	   typename _OutputIterator, typename _Compare>
                               :    void
                               :    __move_merge_adaptive(_InputIterator1 __first1, _InputIterator1 __last1,
                               :			  _InputIterator2 __first2, _InputIterator2 __last2,
                               :			  _OutputIterator __result, _Compare __comp)
                               :    {
     5  0.0043     0       0   :      while (__first1 != __last1 && __first2 != __last2)
                               :	{
    22  0.0187     0       0   :	  if (__comp(*__first2, *__first1))
                               :	    {
                               :	      *__result = _GLIBCXX_MOVE(*__first2);
                               :	      ++__first2;
                               :	    }
                               :	  else
                               :	    {
                               :	      *__result = _GLIBCXX_MOVE(*__first1);
    24  0.0204     0       0   :	      ++__first1;
                               :	    }
                               :	  ++__result;
                               :	}
                               :      if (__first1 != __last1)
                               :	_GLIBCXX_MOVE3(__first1, __last1, __result);
                               :    }
                               :
                               :  /// This is a helper function for the __merge_adaptive routines.
                               :  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
                               :	   typename _BidirectionalIterator3>
                               :    void
                               :    __move_merge_adaptive_backward(_BidirectionalIterator1 __first1,
                               :				   _BidirectionalIterator1 __last1,
                               :				   _BidirectionalIterator2 __first2,
                               :				   _BidirectionalIterator2 __last2,
                               :				   _BidirectionalIterator3 __result)
                               :    {
                               :      if (__first1 == __last1)
                               :	{
                               :	  _GLIBCXX_MOVE_BACKWARD3(__first2, __last2, __result);
                               :	  return;
                               :	}
                               :      else if (__first2 == __last2)
                               :	return;
                               :
                               :      --__last1;
                               :      --__last2;
                               :      while (true)
                               :	{
                               :	  if (*__last2 < *__last1)
                               :	    {
                               :	      *--__result = _GLIBCXX_MOVE(*__last1);
                               :	      if (__first1 == __last1)
                               :		{
                               :		  _GLIBCXX_MOVE_BACKWARD3(__first2, ++__last2, __result);
                               :		  return;
                               :		}
                               :	      --__last1;
                               :	    }
                               :	  else
                               :	    {
                               :	      *--__result = _GLIBCXX_MOVE(*__last2);
                               :	      if (__first2 == __last2)
                               :		return;
                               :	      --__last2;
                               :	    }
                               :	}
                               :    }
                               :
                               :  /// This is a helper function for the __merge_adaptive routines.
                               :  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
                               :	   typename _BidirectionalIterator3, typename _Compare>
                               :    void
                               :    __move_merge_adaptive_backward(_BidirectionalIterator1 __first1,
                               :				   _BidirectionalIterator1 __last1,
                               :				   _BidirectionalIterator2 __first2,
                               :				   _BidirectionalIterator2 __last2,
                               :				   _BidirectionalIterator3 __result,
                               :				   _Compare __comp)
                               :    {
                               :      if (__first1 == __last1)
                               :	{
                               :	  _GLIBCXX_MOVE_BACKWARD3(__first2, __last2, __result);
                               :	  return;
                               :	}
                               :      else if (__first2 == __last2)
                               :	return;
                               :
                               :      --__last1;
                               :      --__last2;
                               :      while (true)
                               :	{
     7  0.0060     0       0   :	  if (__comp(*__last2, *__last1))
                               :	    {
     3  0.0026     0       0   :	      *--__result = _GLIBCXX_MOVE(*__last1);
     3  0.0026     0       0   :	      if (__first1 == __last1)
                               :		{
                               :		  _GLIBCXX_MOVE_BACKWARD3(__first2, ++__last2, __result);
                               :		  return;
                               :		}
                               :	      --__last1;
                               :	    }
                               :	  else
                               :	    {
     2  0.0017     0       0   :	      *--__result = _GLIBCXX_MOVE(*__last2);
     9  0.0077     0       0   :	      if (__first2 == __last2)
                               :		return;
                               :	      --__last2;
                               :	    }
                               :	}
                               :    }
                               :
                               :  /// This is a helper function for the merge routines.
                               :  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
                               :	   typename _Distance>
                               :    _BidirectionalIterator1
                               :    __rotate_adaptive(_BidirectionalIterator1 __first,
                               :		      _BidirectionalIterator1 __middle,
                               :		      _BidirectionalIterator1 __last,
                               :		      _Distance __len1, _Distance __len2,
                               :		      _BidirectionalIterator2 __buffer,
                               :		      _Distance __buffer_size)
                               :    {
                               :      _BidirectionalIterator2 __buffer_end;
                               :      if (__len1 > __len2 && __len2 <= __buffer_size)
                               :	{
                               :	  if (__len2)
                               :	    {
                               :	      __buffer_end = _GLIBCXX_MOVE3(__middle, __last, __buffer);
                               :	      _GLIBCXX_MOVE_BACKWARD3(__first, __middle, __last);
                               :	      return _GLIBCXX_MOVE3(__buffer, __buffer_end, __first);
                               :	    }
                               :	  else
                               :	    return __first;
                               :	}
                               :      else if (__len1 <= __buffer_size)
                               :	{
                               :	  if (__len1)
                               :	    {
                               :	      __buffer_end = _GLIBCXX_MOVE3(__first, __middle, __buffer);
                               :	      _GLIBCXX_MOVE3(__middle, __last, __first);
                               :	      return _GLIBCXX_MOVE_BACKWARD3(__buffer, __buffer_end, __last);
                               :	    }
                               :	  else
                               :	    return __last;
                               :	}
                               :      else
                               :	{
                               :	  std::rotate(__first, __middle, __last);
                               :	  std::advance(__first, std::distance(__middle, __last));
                               :	  return __first;
                               :	}
                               :    }
                               :
                               :  /// This is a helper function for the merge routines.
                               :  template<typename _BidirectionalIterator, typename _Distance,
                               :	   typename _Pointer>
                               :    void
                               :    __merge_adaptive(_BidirectionalIterator __first,
                               :                     _BidirectionalIterator __middle,
                               :		     _BidirectionalIterator __last,
                               :		     _Distance __len1, _Distance __len2,
                               :		     _Pointer __buffer, _Distance __buffer_size)
                               :    {
                               :      if (__len1 <= __len2 && __len1 <= __buffer_size)
                               :	{
                               :	  _Pointer __buffer_end = _GLIBCXX_MOVE3(__first, __middle, __buffer);
                               :	  std::__move_merge_adaptive(__buffer, __buffer_end, __middle, __last,
                               :				     __first);
                               :	}
                               :      else if (__len2 <= __buffer_size)
                               :	{
                               :	  _Pointer __buffer_end = _GLIBCXX_MOVE3(__middle, __last, __buffer);
                               :	  std::__move_merge_adaptive_backward(__first, __middle, __buffer,
                               :					      __buffer_end, __last);
                               :	}
                               :      else
                               :	{
                               :	  _BidirectionalIterator __first_cut = __first;
                               :	  _BidirectionalIterator __second_cut = __middle;
                               :	  _Distance __len11 = 0;
                               :	  _Distance __len22 = 0;
                               :	  if (__len1 > __len2)
                               :	    {
                               :	      __len11 = __len1 / 2;
                               :	      std::advance(__first_cut, __len11);
                               :	      __second_cut = std::lower_bound(__middle, __last,
                               :					      *__first_cut);
                               :	      __len22 = std::distance(__middle, __second_cut);
                               :	    }
                               :	  else
                               :	    {
                               :	      __len22 = __len2 / 2;
                               :	      std::advance(__second_cut, __len22);
                               :	      __first_cut = std::upper_bound(__first, __middle,
                               :					     *__second_cut);
                               :	      __len11 = std::distance(__first, __first_cut);
                               :	    }
                               :	  _BidirectionalIterator __new_middle =
                               :	    std::__rotate_adaptive(__first_cut, __middle, __second_cut,
                               :				   __len1 - __len11, __len22, __buffer,
                               :				   __buffer_size);
                               :	  std::__merge_adaptive(__first, __first_cut, __new_middle, __len11,
                               :				__len22, __buffer, __buffer_size);
                               :	  std::__merge_adaptive(__new_middle, __second_cut, __last,
                               :				__len1 - __len11,
                               :				__len2 - __len22, __buffer, __buffer_size);
                               :	}
                               :    }
                               :
                               :  /// This is a helper function for the merge routines.
                               :  template<typename _BidirectionalIterator, typename _Distance, 
                               :	   typename _Pointer, typename _Compare>
                               :    void
     6  0.0051     0       0   :    __merge_adaptive(_BidirectionalIterator __first, /* void std::__merge_adaptive<__gnu_cxx::__normal_iterator<Path**, std::vector<Path*, std::allocator<Path*> > >, int, Path**, bool (*)(Path*, Path*)>(__gnu_cxx::__normal_iterator<Path**, std::vector<Path*, std::allocator<Path*> > >, __gnu_cxx::__normal_iterator<Path**, std::vector<Path*, std::allocator<Path*> > >, __gnu_cxx::__normal_iterator<Path**, std::vector<Path*, std::allocator<Path*> > >, int, int, Path**, int, bool (*)(Path*, Path*)) [clone .constprop.395] total:    170  0.1446     0       0 */
                               :                     _BidirectionalIterator __middle,
                               :		     _BidirectionalIterator __last,
                               :		     _Distance __len1, _Distance __len2,
                               :		     _Pointer __buffer, _Distance __buffer_size,
                               :		     _Compare __comp)
                               :    {
     4  0.0034     0       0   :      if (__len1 <= __len2 && __len1 <= __buffer_size)
                               :	{
                               :	  _Pointer __buffer_end = _GLIBCXX_MOVE3(__first, __middle, __buffer);
                               :	  std::__move_merge_adaptive(__buffer, __buffer_end, __middle, __last,
                               :				     __first, __comp);
                               :	}
                               :      else if (__len2 <= __buffer_size)
                               :	{
                               :	  _Pointer __buffer_end = _GLIBCXX_MOVE3(__middle, __last, __buffer);
                               :	  std::__move_merge_adaptive_backward(__first, __middle, __buffer,
                               :					      __buffer_end, __last, __comp);
                               :	}
                               :      else
                               :	{
                               :	  _BidirectionalIterator __first_cut = __first;
                               :	  _BidirectionalIterator __second_cut = __middle;
                               :	  _Distance __len11 = 0;
                               :	  _Distance __len22 = 0;
                               :	  if (__len1 > __len2)
                               :	    {
                               :	      __len11 = __len1 / 2;
                               :	      std::advance(__first_cut, __len11);
                               :	      __second_cut = std::lower_bound(__middle, __last, *__first_cut,
                               :					      __comp);
                               :	      __len22 = std::distance(__middle, __second_cut);
                               :	    }
                               :	  else
                               :	    {
                               :	      __len22 = __len2 / 2;
                               :	      std::advance(__second_cut, __len22);
                               :	      __first_cut = std::upper_bound(__first, __middle, *__second_cut,
                               :					     __comp);
                               :	      __len11 = std::distance(__first, __first_cut);
                               :	    }
                               :	  _BidirectionalIterator __new_middle =
                               :	    std::__rotate_adaptive(__first_cut, __middle, __second_cut,
                               :				   __len1 - __len11, __len22, __buffer,
                               :				   __buffer_size);
                               :	  std::__merge_adaptive(__first, __first_cut, __new_middle, __len11,
                               :				__len22, __buffer, __buffer_size, __comp);
                               :	  std::__merge_adaptive(__new_middle, __second_cut, __last,
                               :				__len1 - __len11,
                               :				__len2 - __len22, __buffer,
                               :				__buffer_size, __comp);
                               :	}
     2  0.0017     0       0   :    }
                               :
                               :  /// This is a helper function for the merge routines.
                               :  template<typename _BidirectionalIterator, typename _Distance>
                               :    void
                               :    __merge_without_buffer(_BidirectionalIterator __first,
                               :			   _BidirectionalIterator __middle,
                               :			   _BidirectionalIterator __last,
                               :			   _Distance __len1, _Distance __len2)
                               :    {
                               :      if (__len1 == 0 || __len2 == 0)
                               :	return;
                               :      if (__len1 + __len2 == 2)
                               :	{
                               :	  if (*__middle < *__first)
                               :	    std::iter_swap(__first, __middle);
                               :	  return;
                               :	}
                               :      _BidirectionalIterator __first_cut = __first;
                               :      _BidirectionalIterator __second_cut = __middle;
                               :      _Distance __len11 = 0;
                               :      _Distance __len22 = 0;
                               :      if (__len1 > __len2)
                               :	{
                               :	  __len11 = __len1 / 2;
                               :	  std::advance(__first_cut, __len11);
                               :	  __second_cut = std::lower_bound(__middle, __last, *__first_cut);
                               :	  __len22 = std::distance(__middle, __second_cut);
                               :	}
                               :      else
                               :	{
                               :	  __len22 = __len2 / 2;
                               :	  std::advance(__second_cut, __len22);
                               :	  __first_cut = std::upper_bound(__first, __middle, *__second_cut);
                               :	  __len11 = std::distance(__first, __first_cut);
                               :	}
                               :      std::rotate(__first_cut, __middle, __second_cut);
                               :      _BidirectionalIterator __new_middle = __first_cut;
                               :      std::advance(__new_middle, std::distance(__middle, __second_cut));
                               :      std::__merge_without_buffer(__first, __first_cut, __new_middle,
                               :				  __len11, __len22);
                               :      std::__merge_without_buffer(__new_middle, __second_cut, __last,
                               :				  __len1 - __len11, __len2 - __len22);
                               :    }
                               :
                               :  /// This is a helper function for the merge routines.
                               :  template<typename _BidirectionalIterator, typename _Distance,
                               :	   typename _Compare>
                               :    void
                               :    __merge_without_buffer(_BidirectionalIterator __first,
                               :                           _BidirectionalIterator __middle,
                               :			   _BidirectionalIterator __last,
                               :			   _Distance __len1, _Distance __len2,
                               :			   _Compare __comp)
                               :    {
                               :      if (__len1 == 0 || __len2 == 0)
                               :	return;
                               :      if (__len1 + __len2 == 2)
                               :	{
                               :	  if (__comp(*__middle, *__first))
                               :	    std::iter_swap(__first, __middle);
                               :	  return;
                               :	}
                               :      _BidirectionalIterator __first_cut = __first;
                               :      _BidirectionalIterator __second_cut = __middle;
                               :      _Distance __len11 = 0;
                               :      _Distance __len22 = 0;
                               :      if (__len1 > __len2)
                               :	{
                               :	  __len11 = __len1 / 2;
                               :	  std::advance(__first_cut, __len11);
                               :	  __second_cut = std::lower_bound(__middle, __last, *__first_cut,
                               :					  __comp);
                               :	  __len22 = std::distance(__middle, __second_cut);
                               :	}
                               :      else
                               :	{
                               :	  __len22 = __len2 / 2;
                               :	  std::advance(__second_cut, __len22);
                               :	  __first_cut = std::upper_bound(__first, __middle, *__second_cut,
                               :					 __comp);
                               :	  __len11 = std::distance(__first, __first_cut);
                               :	}
                               :      std::rotate(__first_cut, __middle, __second_cut);
                               :      _BidirectionalIterator __new_middle = __first_cut;
                               :      std::advance(__new_middle, std::distance(__middle, __second_cut));
                               :      std::__merge_without_buffer(__first, __first_cut, __new_middle,
                               :				  __len11, __len22, __comp);
                               :      std::__merge_without_buffer(__new_middle, __second_cut, __last,
                               :				  __len1 - __len11, __len2 - __len22, __comp);
                               :    }
                               :
                               :  /**
                               :   *  @brief Merges two sorted ranges in place.
                               :   *  @ingroup sorting_algorithms
                               :   *  @param  __first   An iterator.
                               :   *  @param  __middle  Another iterator.
                               :   *  @param  __last    Another iterator.
                               :   *  @return  Nothing.
                               :   *
                               :   *  Merges two sorted and consecutive ranges, [__first,__middle) and
                               :   *  [__middle,__last), and puts the result in [__first,__last).  The
                               :   *  output will be sorted.  The sort is @e stable, that is, for
                               :   *  equivalent elements in the two ranges, elements from the first
                               :   *  range will always come before elements from the second.
                               :   *
                               :   *  If enough additional memory is available, this takes (__last-__first)-1
                               :   *  comparisons.  Otherwise an NlogN algorithm is used, where N is
                               :   *  distance(__first,__last).
                               :  */
                               :  template<typename _BidirectionalIterator>
                               :    void
                               :    inplace_merge(_BidirectionalIterator __first,
                               :		  _BidirectionalIterator __middle,
                               :		  _BidirectionalIterator __last)
                               :    {
                               :      typedef typename iterator_traits<_BidirectionalIterator>::value_type
                               :          _ValueType;
                               :      typedef typename iterator_traits<_BidirectionalIterator>::difference_type
                               :          _DistanceType;
                               :
                               :      // concept requirements
                               :      __glibcxx_function_requires(_Mutable_BidirectionalIteratorConcept<
                               :	    _BidirectionalIterator>)
                               :      __glibcxx_function_requires(_LessThanComparableConcept<_ValueType>)
                               :      __glibcxx_requires_sorted(__first, __middle);
                               :      __glibcxx_requires_sorted(__middle, __last);
                               :
                               :      if (__first == __middle || __middle == __last)
                               :	return;
                               :
                               :      _DistanceType __len1 = std::distance(__first, __middle);
                               :      _DistanceType __len2 = std::distance(__middle, __last);
                               :
                               :      _Temporary_buffer<_BidirectionalIterator, _ValueType> __buf(__first,
                               :								  __last);
                               :      if (__buf.begin() == 0)
                               :	std::__merge_without_buffer(__first, __middle, __last, __len1, __len2);
                               :      else
                               :	std::__merge_adaptive(__first, __middle, __last, __len1, __len2,
                               :			      __buf.begin(), _DistanceType(__buf.size()));
                               :    }
                               :
                               :  /**
                               :   *  @brief Merges two sorted ranges in place.
                               :   *  @ingroup sorting_algorithms
                               :   *  @param  __first   An iterator.
                               :   *  @param  __middle  Another iterator.
                               :   *  @param  __last    Another iterator.
                               :   *  @param  __comp    A functor to use for comparisons.
                               :   *  @return  Nothing.
                               :   *
                               :   *  Merges two sorted and consecutive ranges, [__first,__middle) and
                               :   *  [middle,last), and puts the result in [__first,__last).  The output will
                               :   *  be sorted.  The sort is @e stable, that is, for equivalent
                               :   *  elements in the two ranges, elements from the first range will always
                               :   *  come before elements from the second.
                               :   *
                               :   *  If enough additional memory is available, this takes (__last-__first)-1
                               :   *  comparisons.  Otherwise an NlogN algorithm is used, where N is
                               :   *  distance(__first,__last).
                               :   *
                               :   *  The comparison function should have the same effects on ordering as
                               :   *  the function used for the initial sort.
                               :  */
                               :  template<typename _BidirectionalIterator, typename _Compare>
                               :    void
                               :    inplace_merge(_BidirectionalIterator __first,
                               :		  _BidirectionalIterator __middle,
                               :		  _BidirectionalIterator __last,
                               :		  _Compare __comp)
                               :    {
                               :      typedef typename iterator_traits<_BidirectionalIterator>::value_type
                               :          _ValueType;
                               :      typedef typename iterator_traits<_BidirectionalIterator>::difference_type
                               :          _DistanceType;
                               :
                               :      // concept requirements
                               :      __glibcxx_function_requires(_Mutable_BidirectionalIteratorConcept<
                               :	    _BidirectionalIterator>)
                               :      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
                               :	    _ValueType, _ValueType>)
                               :      __glibcxx_requires_sorted_pred(__first, __middle, __comp);
                               :      __glibcxx_requires_sorted_pred(__middle, __last, __comp);
                               :
                               :      if (__first == __middle || __middle == __last)
                               :	return;
                               :
                               :      const _DistanceType __len1 = std::distance(__first, __middle);
                               :      const _DistanceType __len2 = std::distance(__middle, __last);
                               :
                               :      _Temporary_buffer<_BidirectionalIterator, _ValueType> __buf(__first,
                               :								  __last);
                               :      if (__buf.begin() == 0)
                               :	std::__merge_without_buffer(__first, __middle, __last, __len1,
                               :				    __len2, __comp);
                               :      else
                               :	std::__merge_adaptive(__first, __middle, __last, __len1, __len2,
                               :			      __buf.begin(), _DistanceType(__buf.size()),
                               :			      __comp);
                               :    }
                               :
                               :
                               :  /// This is a helper function for the __merge_sort_loop routines.
                               :  template<typename _InputIterator1, typename _InputIterator2,
                               :	   typename _OutputIterator>
                               :    _OutputIterator
                               :    __move_merge(_InputIterator1 __first1, _InputIterator1 __last1,
                               :		 _InputIterator2 __first2, _InputIterator2 __last2,
                               :		 _OutputIterator __result)
                               :    {
                               :      while (__first1 != __last1 && __first2 != __last2)
                               :	{
                               :	  if (*__first2 < *__first1)
                               :	    {
                               :	      *__result = _GLIBCXX_MOVE(*__first2);
                               :	      ++__first2;
                               :	    }
                               :	  else
                               :	    {
                               :	      *__result = _GLIBCXX_MOVE(*__first1);
                               :	      ++__first1;
                               :	    }
                               :	  ++__result;
                               :	}
                               :      return _GLIBCXX_MOVE3(__first2, __last2,
                               :			    _GLIBCXX_MOVE3(__first1, __last1,
                               :					   __result));
                               :    }
                               :
                               :  /// This is a helper function for the __merge_sort_loop routines.
                               :  template<typename _InputIterator1, typename _InputIterator2,
                               :	   typename _OutputIterator, typename _Compare>
                               :    _OutputIterator
                               :    __move_merge(_InputIterator1 __first1, _InputIterator1 __last1,
                               :		 _InputIterator2 __first2, _InputIterator2 __last2,
                               :		 _OutputIterator __result, _Compare __comp)
                               :    {
    47  0.0400     0       0   :      while (__first1 != __last1 && __first2 != __last2)
                               :	{
    80  0.0681     0       0   :	  if (__comp(*__first2, *__first1))
                               :	    {
                               :	      *__result = _GLIBCXX_MOVE(*__first2);
    82  0.0698     0       0   :	      ++__first2;
                               :	    }
                               :	  else
                               :	    {
                               :	      *__result = _GLIBCXX_MOVE(*__first1);
     7  0.0060     0       0   :	      ++__first1;
                               :	    }
    20  0.0170     0       0   :	  ++__result;
                               :	}
                               :      return _GLIBCXX_MOVE3(__first2, __last2,
                               :			    _GLIBCXX_MOVE3(__first1, __last1,
                               :					   __result));
                               :    }
                               :
                               :  template<typename _RandomAccessIterator1, typename _RandomAccessIterator2,
                               :	   typename _Distance>
                               :    void
                               :    __merge_sort_loop(_RandomAccessIterator1 __first,
                               :		      _RandomAccessIterator1 __last,
                               :		      _RandomAccessIterator2 __result,
                               :		      _Distance __step_size)
                               :    {
                               :      const _Distance __two_step = 2 * __step_size;
                               :
                               :      while (__last - __first >= __two_step)
                               :	{
                               :	  __result = std::__move_merge(__first, __first + __step_size,
                               :				       __first + __step_size,
                               :				       __first + __two_step, __result);
                               :	  __first += __two_step;
                               :	}
                               :
                               :      __step_size = std::min(_Distance(__last - __first), __step_size);
                               :      std::__move_merge(__first, __first + __step_size,
                               :			__first + __step_size, __last, __result);
                               :    }
                               :
                               :  template<typename _RandomAccessIterator1, typename _RandomAccessIterator2,
                               :	   typename _Distance, typename _Compare>
                               :    void
                               :    __merge_sort_loop(_RandomAccessIterator1 __first,
                               :		      _RandomAccessIterator1 __last,
                               :		      _RandomAccessIterator2 __result, _Distance __step_size,
                               :		      _Compare __comp)
                               :    {
     9  0.0077     0       0   :      const _Distance __two_step = 2 * __step_size;
                               :
    17  0.0145     0       0   :      while (__last - __first >= __two_step)
                               :	{
                               :	  __result = std::__move_merge(__first, __first + __step_size,
                               :				       __first + __step_size,
                               :				       __first + __two_step,
     2  0.0017     0       0   :				       __result, __comp);
                               :	  __first += __two_step;
                               :	}
                               :      __step_size = std::min(_Distance(__last - __first), __step_size);
                               :
                               :      std::__move_merge(__first,__first + __step_size,
     5  0.0043     0       0   :			__first + __step_size, __last, __result, __comp);
                               :    }
                               :
                               :  template<typename _RandomAccessIterator, typename _Distance>
                               :    void
                               :    __chunk_insertion_sort(_RandomAccessIterator __first,
                               :			   _RandomAccessIterator __last,
                               :			   _Distance __chunk_size)
                               :    {
                               :      while (__last - __first >= __chunk_size)
                               :	{
                               :	  std::__insertion_sort(__first, __first + __chunk_size);
                               :	  __first += __chunk_size;
                               :	}
                               :      std::__insertion_sort(__first, __last);
                               :    }
                               :
                               :  template<typename _RandomAccessIterator, typename _Distance,
                               :	   typename _Compare>
                               :    void
                               :    __chunk_insertion_sort(_RandomAccessIterator __first,
                               :			   _RandomAccessIterator __last,
                               :			   _Distance __chunk_size, _Compare __comp)
                               :    {
     2  0.0017     0       0   :      while (__last - __first >= __chunk_size)
                               :	{
                               :	  std::__insertion_sort(__first, __first + __chunk_size, __comp);
                               :	  __first += __chunk_size;
                               :	}
                               :      std::__insertion_sort(__first, __last, __comp);
                               :    }
                               :
                               :  enum { _S_chunk_size = 7 };
                               :
                               :  template<typename _RandomAccessIterator, typename _Pointer>
                               :    void
                               :    __merge_sort_with_buffer(_RandomAccessIterator __first,
                               :			     _RandomAccessIterator __last,
                               :                             _Pointer __buffer)
                               :    {
                               :      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
                               :	_Distance;
                               :
                               :      const _Distance __len = __last - __first;
                               :      const _Pointer __buffer_last = __buffer + __len;
                               :
                               :      _Distance __step_size = _S_chunk_size;
                               :      std::__chunk_insertion_sort(__first, __last, __step_size);
                               :
                               :      while (__step_size < __len)
                               :	{
                               :	  std::__merge_sort_loop(__first, __last, __buffer, __step_size);
                               :	  __step_size *= 2;
                               :	  std::__merge_sort_loop(__buffer, __buffer_last, __first, __step_size);
                               :	  __step_size *= 2;
                               :	}
                               :    }
                               :
                               :  template<typename _RandomAccessIterator, typename _Pointer, typename _Compare>
                               :    void
    16  0.0136     0       0   :    __merge_sort_with_buffer(_RandomAccessIterator __first, /* void std::__merge_sort_with_buffer<__gnu_cxx::__normal_iterator<Path**, std::vector<Path*, std::allocator<Path*> > >, Path**, bool (*)(Path*, Path*)>(__gnu_cxx::__normal_iterator<Path**, std::vector<Path*, std::allocator<Path*> > >, __gnu_cxx::__normal_iterator<Path**, std::vector<Path*, std::allocator<Path*> > >, Path**, bool (*)(Path*, Path*)) [clone .constprop.389] total:    771  0.6560    11  0.6497 */
                               :			     _RandomAccessIterator __last,
                               :                             _Pointer __buffer, _Compare __comp)
                               :    {
                               :      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
                               :	_Distance;
                               :
                               :      const _Distance __len = __last - __first;
                               :      const _Pointer __buffer_last = __buffer + __len;
                               :
                               :      _Distance __step_size = _S_chunk_size;
                               :      std::__chunk_insertion_sort(__first, __last, __step_size, __comp);
                               :
    10  0.0085     0       0   :      while (__step_size < __len)
                               :	{
                               :	  std::__merge_sort_loop(__first, __last, __buffer,
                               :				 __step_size, __comp);
                               :	  __step_size *= 2;
                               :	  std::__merge_sort_loop(__buffer, __buffer_last, __first,
                               :				 __step_size, __comp);
                               :	  __step_size *= 2;
                               :	}
     2  0.0017     0       0   :    }
                               :
                               :  template<typename _RandomAccessIterator, typename _Pointer,
                               :	   typename _Distance>
                               :    void
                               :    __stable_sort_adaptive(_RandomAccessIterator __first,
                               :			   _RandomAccessIterator __last,
                               :                           _Pointer __buffer, _Distance __buffer_size)
                               :    {
                               :      const _Distance __len = (__last - __first + 1) / 2;
                               :      const _RandomAccessIterator __middle = __first + __len;
                               :      if (__len > __buffer_size)
                               :	{
                               :	  std::__stable_sort_adaptive(__first, __middle,
                               :				      __buffer, __buffer_size);
                               :	  std::__stable_sort_adaptive(__middle, __last,
                               :				      __buffer, __buffer_size);
                               :	}
                               :      else
                               :	{
                               :	  std::__merge_sort_with_buffer(__first, __middle, __buffer);
                               :	  std::__merge_sort_with_buffer(__middle, __last, __buffer);
                               :	}
                               :      std::__merge_adaptive(__first, __middle, __last,
                               :			    _Distance(__middle - __first),
                               :			    _Distance(__last - __middle),
                               :			    __buffer, __buffer_size);
                               :    }
                               :
                               :  template<typename _RandomAccessIterator, typename _Pointer,
                               :	   typename _Distance, typename _Compare>
                               :    void
     6  0.0051     0       0   :    __stable_sort_adaptive(_RandomAccessIterator __first, /* void std::__stable_sort_adaptive<__gnu_cxx::__normal_iterator<Path**, std::vector<Path*, std::allocator<Path*> > >, Path**, int, bool (*)(Path*, Path*)>(__gnu_cxx::__normal_iterator<Path**, std::vector<Path*, std::allocator<Path*> > >, __gnu_cxx::__normal_iterator<Path**, std::vector<Path*, std::allocator<Path*> > >, Path**, int, bool (*)(Path*, Path*)) [clone .constprop.388] total:     14  0.0119     0       0 */
                               :			   _RandomAccessIterator __last,
                               :                           _Pointer __buffer, _Distance __buffer_size,
                               :                           _Compare __comp)
                               :    {
                               :      const _Distance __len = (__last - __first + 1) / 2;
                               :      const _RandomAccessIterator __middle = __first + __len;
     1 8.5e-04     0       0   :      if (__len > __buffer_size)
                               :	{
                               :	  std::__stable_sort_adaptive(__first, __middle, __buffer,
                               :				      __buffer_size, __comp);
                               :	  std::__stable_sort_adaptive(__middle, __last, __buffer,
                               :				      __buffer_size, __comp);
                               :	}
                               :      else
                               :	{
                               :	  std::__merge_sort_with_buffer(__first, __middle, __buffer, __comp);
     1 8.5e-04     0       0   :	  std::__merge_sort_with_buffer(__middle, __last, __buffer, __comp);
                               :	}
     3  0.0026     0       0   :      std::__merge_adaptive(__first, __middle, __last,
                               :			    _Distance(__middle - __first),
                               :			    _Distance(__last - __middle),
                               :			    __buffer, __buffer_size,
                               :			    __comp);
     2  0.0017     0       0   :    }
                               :
                               :  /// This is a helper function for the stable sorting routines.
                               :  template<typename _RandomAccessIterator>
                               :    void
                               :    __inplace_stable_sort(_RandomAccessIterator __first,
                               :			  _RandomAccessIterator __last)
                               :    {
                               :      if (__last - __first < 15)
                               :	{
                               :	  std::__insertion_sort(__first, __last);
                               :	  return;
                               :	}
                               :      _RandomAccessIterator __middle = __first + (__last - __first) / 2;
                               :      std::__inplace_stable_sort(__first, __middle);
                               :      std::__inplace_stable_sort(__middle, __last);
                               :      std::__merge_without_buffer(__first, __middle, __last,
                               :				  __middle - __first,
                               :				  __last - __middle);
                               :    }
                               :
                               :  /// This is a helper function for the stable sorting routines.
                               :  template<typename _RandomAccessIterator, typename _Compare>
                               :    void
     1 8.5e-04     0       0   :    __inplace_stable_sort(_RandomAccessIterator __first, /* void std::__inplace_stable_sort<__gnu_cxx::__normal_iterator<Path**, std::vector<Path*, std::allocator<Path*> > >, bool (*)(Path*, Path*)>(__gnu_cxx::__normal_iterator<Path**, std::vector<Path*, std::allocator<Path*> > >, __gnu_cxx::__normal_iterator<Path**, std::vector<Path*, std::allocator<Path*> > >, bool (*)(Path*, Path*)) total:      4  0.0034     0       0 */
                               :			  _RandomAccessIterator __last, _Compare __comp)
                               :    {
                               :      if (__last - __first < 15)
                               :	{
                               :	  std::__insertion_sort(__first, __last, __comp);
                               :	  return;
                               :	}
                               :      _RandomAccessIterator __middle = __first + (__last - __first) / 2;
                               :      std::__inplace_stable_sort(__first, __middle, __comp);
                               :      std::__inplace_stable_sort(__middle, __last, __comp);
                               :      std::__merge_without_buffer(__first, __middle, __last,
                               :				  __middle - __first,
                               :				  __last - __middle,
                               :				  __comp);
     3  0.0026     0       0   :    }
                               :
                               :  // stable_sort
                               :
                               :  // Set algorithms: includes, set_union, set_intersection, set_difference,
                               :  // set_symmetric_difference.  All of these algorithms have the precondition
                               :  // that their input ranges are sorted and the postcondition that their output
                               :  // ranges are sorted.
                               :
                               :  /**
                               :   *  @brief Determines whether all elements of a sequence exists in a range.
                               :   *  @param  __first1  Start of search range.
                               :   *  @param  __last1   End of search range.
                               :   *  @param  __first2  Start of sequence
                               :   *  @param  __last2   End of sequence.
                               :   *  @return  True if each element in [__first2,__last2) is contained in order
                               :   *  within [__first1,__last1).  False otherwise.
                               :   *  @ingroup set_algorithms
                               :   *
                               :   *  This operation expects both [__first1,__last1) and
                               :   *  [__first2,__last2) to be sorted.  Searches for the presence of
                               :   *  each element in [__first2,__last2) within [__first1,__last1).
                               :   *  The iterators over each range only move forward, so this is a
                               :   *  linear algorithm.  If an element in [__first2,__last2) is not
                               :   *  found before the search iterator reaches @p __last2, false is
                               :   *  returned.
                               :  */
                               :  template<typename _InputIterator1, typename _InputIterator2>
                               :    bool
                               :    includes(_InputIterator1 __first1, _InputIterator1 __last1,
                               :	     _InputIterator2 __first2, _InputIterator2 __last2)
                               :    {
                               :      typedef typename iterator_traits<_InputIterator1>::value_type
                               :	_ValueType1;
                               :      typedef typename iterator_traits<_InputIterator2>::value_type
                               :	_ValueType2;
                               :
                               :      // concept requirements
                               :      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
                               :      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
                               :      __glibcxx_function_requires(_LessThanOpConcept<_ValueType1, _ValueType2>)
                               :      __glibcxx_function_requires(_LessThanOpConcept<_ValueType2, _ValueType1>)
                               :      __glibcxx_requires_sorted_set(__first1, __last1, __first2);
                               :      __glibcxx_requires_sorted_set(__first2, __last2, __first1);
                               :
                               :      while (__first1 != __last1 && __first2 != __last2)
                               :	if (*__first2 < *__first1)
                               :	  return false;
                               :	else if(*__first1 < *__first2)
                               :	  ++__first1;
                               :	else
                               :	  ++__first1, ++__first2;
                               :
                               :      return __first2 == __last2;
                               :    }
                               :
                               :  /**
                               :   *  @brief Determines whether all elements of a sequence exists in a range
                               :   *  using comparison.
                               :   *  @ingroup set_algorithms
                               :   *  @param  __first1  Start of search range.
                               :   *  @param  __last1   End of search range.
                               :   *  @param  __first2  Start of sequence
                               :   *  @param  __last2   End of sequence.
                               :   *  @param  __comp    Comparison function to use.
                               :   *  @return True if each element in [__first2,__last2) is contained
                               :   *  in order within [__first1,__last1) according to comp.  False
                               :   *  otherwise.  @ingroup set_algorithms
                               :   *
                               :   *  This operation expects both [__first1,__last1) and
                               :   *  [__first2,__last2) to be sorted.  Searches for the presence of
                               :   *  each element in [__first2,__last2) within [__first1,__last1),
                               :   *  using comp to decide.  The iterators over each range only move
                               :   *  forward, so this is a linear algorithm.  If an element in
                               :   *  [__first2,__last2) is not found before the search iterator
                               :   *  reaches @p __last2, false is returned.
                               :  */
                               :  template<typename _InputIterator1, typename _InputIterator2,
                               :	   typename _Compare>
                               :    bool
                               :    includes(_InputIterator1 __first1, _InputIterator1 __last1,
                               :	     _InputIterator2 __first2, _InputIterator2 __last2,
                               :	     _Compare __comp)
                               :    {
                               :      typedef typename iterator_traits<_InputIterator1>::value_type
                               :	_ValueType1;
                               :      typedef typename iterator_traits<_InputIterator2>::value_type
                               :	_ValueType2;
                               :
                               :      // concept requirements
                               :      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
                               :      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
                               :      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
                               :				  _ValueType1, _ValueType2>)
                               :      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
                               :				  _ValueType2, _ValueType1>)
                               :      __glibcxx_requires_sorted_set_pred(__first1, __last1, __first2, __comp);
                               :      __glibcxx_requires_sorted_set_pred(__first2, __last2, __first1, __comp);
                               :
                               :      while (__first1 != __last1 && __first2 != __last2)
                               :	if (__comp(*__first2, *__first1))
                               :	  return false;
                               :	else if(__comp(*__first1, *__first2))
                               :	  ++__first1;
                               :	else
                               :	  ++__first1, ++__first2;
                               :
                               :      return __first2 == __last2;
                               :    }
                               :
                               :  // nth_element
                               :  // merge
                               :  // set_difference
                               :  // set_intersection
                               :  // set_union
                               :  // stable_sort
                               :  // set_symmetric_difference
                               :  // min_element
                               :  // max_element
                               :
                               :  /**
                               :   *  @brief  Permute range into the next @e dictionary ordering.
                               :   *  @ingroup sorting_algorithms
                               :   *  @param  __first  Start of range.
                               :   *  @param  __last   End of range.
                               :   *  @return  False if wrapped to first permutation, true otherwise.
                               :   *
                               :   *  Treats all permutations of the range as a set of @e dictionary sorted
                               :   *  sequences.  Permutes the current sequence into the next one of this set.
                               :   *  Returns true if there are more sequences to generate.  If the sequence
                               :   *  is the largest of the set, the smallest is generated and false returned.
                               :  */
                               :  template<typename _BidirectionalIterator>
                               :    bool
                               :    next_permutation(_BidirectionalIterator __first,
                               :		     _BidirectionalIterator __last)
                               :    {
                               :      // concept requirements
                               :      __glibcxx_function_requires(_BidirectionalIteratorConcept<
                               :				  _BidirectionalIterator>)
                               :      __glibcxx_function_requires(_LessThanComparableConcept<
                               :	    typename iterator_traits<_BidirectionalIterator>::value_type>)
                               :      __glibcxx_requires_valid_range(__first, __last);
                               :
                               :      if (__first == __last)
                               :	return false;
                               :      _BidirectionalIterator __i = __first;
                               :      ++__i;
                               :      if (__i == __last)
                               :	return false;
                               :      __i = __last;
                               :      --__i;
                               :
                               :      for(;;)
                               :	{
                               :	  _BidirectionalIterator __ii = __i;
                               :	  --__i;
                               :	  if (*__i < *__ii)
                               :	    {
                               :	      _BidirectionalIterator __j = __last;
                               :	      while (!(*__i < *--__j))
                               :		{}
                               :	      std::iter_swap(__i, __j);
                               :	      std::reverse(__ii, __last);
                               :	      return true;
                               :	    }
                               :	  if (__i == __first)
                               :	    {
                               :	      std::reverse(__first, __last);
                               :	      return false;
                               :	    }
                               :	}
                               :    }
                               :
                               :  /**
                               :   *  @brief  Permute range into the next @e dictionary ordering using
                               :   *          comparison functor.
                               :   *  @ingroup sorting_algorithms
                               :   *  @param  __first  Start of range.
                               :   *  @param  __last   End of range.
                               :   *  @param  __comp   A comparison functor.
                               :   *  @return  False if wrapped to first permutation, true otherwise.
                               :   *
                               :   *  Treats all permutations of the range [__first,__last) as a set of
                               :   *  @e dictionary sorted sequences ordered by @p __comp.  Permutes the current
                               :   *  sequence into the next one of this set.  Returns true if there are more
                               :   *  sequences to generate.  If the sequence is the largest of the set, the
                               :   *  smallest is generated and false returned.
                               :  */
                               :  template<typename _BidirectionalIterator, typename _Compare>
                               :    bool
                               :    next_permutation(_BidirectionalIterator __first,
                               :		     _BidirectionalIterator __last, _Compare __comp)
                               :    {
                               :      // concept requirements
                               :      __glibcxx_function_requires(_BidirectionalIteratorConcept<
                               :				  _BidirectionalIterator>)
                               :      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
                               :	    typename iterator_traits<_BidirectionalIterator>::value_type,
                               :	    typename iterator_traits<_BidirectionalIterator>::value_type>)
                               :      __glibcxx_requires_valid_range(__first, __last);
                               :
                               :      if (__first == __last)
                               :	return false;
                               :      _BidirectionalIterator __i = __first;
                               :      ++__i;
                               :      if (__i == __last)
                               :	return false;
                               :      __i = __last;
                               :      --__i;
                               :
                               :      for(;;)
                               :	{
                               :	  _BidirectionalIterator __ii = __i;
                               :	  --__i;
                               :	  if (__comp(*__i, *__ii))
                               :	    {
                               :	      _BidirectionalIterator __j = __last;
                               :	      while (!bool(__comp(*__i, *--__j)))
                               :		{}
                               :	      std::iter_swap(__i, __j);
                               :	      std::reverse(__ii, __last);
                               :	      return true;
                               :	    }
                               :	  if (__i == __first)
                               :	    {
                               :	      std::reverse(__first, __last);
                               :	      return false;
                               :	    }
                               :	}
                               :    }
                               :
                               :  /**
                               :   *  @brief  Permute range into the previous @e dictionary ordering.
                               :   *  @ingroup sorting_algorithms
                               :   *  @param  __first  Start of range.
                               :   *  @param  __last   End of range.
                               :   *  @return  False if wrapped to last permutation, true otherwise.
                               :   *
                               :   *  Treats all permutations of the range as a set of @e dictionary sorted
                               :   *  sequences.  Permutes the current sequence into the previous one of this
                               :   *  set.  Returns true if there are more sequences to generate.  If the
                               :   *  sequence is the smallest of the set, the largest is generated and false
                               :   *  returned.
                               :  */
                               :  template<typename _BidirectionalIterator>
                               :    bool
                               :    prev_permutation(_BidirectionalIterator __first,
                               :		     _BidirectionalIterator __last)
                               :    {
                               :      // concept requirements
                               :      __glibcxx_function_requires(_BidirectionalIteratorConcept<
                               :				  _BidirectionalIterator>)
                               :      __glibcxx_function_requires(_LessThanComparableConcept<
                               :	    typename iterator_traits<_BidirectionalIterator>::value_type>)
                               :      __glibcxx_requires_valid_range(__first, __last);
                               :
                               :      if (__first == __last)
                               :	return false;
                               :      _BidirectionalIterator __i = __first;
                               :      ++__i;
                               :      if (__i == __last)
                               :	return false;
                               :      __i = __last;
                               :      --__i;
                               :
                               :      for(;;)
                               :	{
                               :	  _BidirectionalIterator __ii = __i;
                               :	  --__i;
                               :	  if (*__ii < *__i)
                               :	    {
                               :	      _BidirectionalIterator __j = __last;
                               :	      while (!(*--__j < *__i))
                               :		{}
                               :	      std::iter_swap(__i, __j);
                               :	      std::reverse(__ii, __last);
                               :	      return true;
                               :	    }
                               :	  if (__i == __first)
                               :	    {
                               :	      std::reverse(__first, __last);
                               :	      return false;
                               :	    }
                               :	}
                               :    }
                               :
                               :  /**
                               :   *  @brief  Permute range into the previous @e dictionary ordering using
                               :   *          comparison functor.
                               :   *  @ingroup sorting_algorithms
                               :   *  @param  __first  Start of range.
                               :   *  @param  __last   End of range.
                               :   *  @param  __comp   A comparison functor.
                               :   *  @return  False if wrapped to last permutation, true otherwise.
                               :   *
                               :   *  Treats all permutations of the range [__first,__last) as a set of
                               :   *  @e dictionary sorted sequences ordered by @p __comp.  Permutes the current
                               :   *  sequence into the previous one of this set.  Returns true if there are
                               :   *  more sequences to generate.  If the sequence is the smallest of the set,
                               :   *  the largest is generated and false returned.
                               :  */
                               :  template<typename _BidirectionalIterator, typename _Compare>
                               :    bool
                               :    prev_permutation(_BidirectionalIterator __first,
                               :		     _BidirectionalIterator __last, _Compare __comp)
                               :    {
                               :      // concept requirements
                               :      __glibcxx_function_requires(_BidirectionalIteratorConcept<
                               :				  _BidirectionalIterator>)
                               :      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
                               :	    typename iterator_traits<_BidirectionalIterator>::value_type,
                               :	    typename iterator_traits<_BidirectionalIterator>::value_type>)
                               :      __glibcxx_requires_valid_range(__first, __last);
                               :
                               :      if (__first == __last)
                               :	return false;
                               :      _BidirectionalIterator __i = __first;
                               :      ++__i;
                               :      if (__i == __last)
                               :	return false;
                               :      __i = __last;
                               :      --__i;
                               :
                               :      for(;;)
                               :	{
                               :	  _BidirectionalIterator __ii = __i;
                               :	  --__i;
                               :	  if (__comp(*__ii, *__i))
                               :	    {
                               :	      _BidirectionalIterator __j = __last;
                               :	      while (!bool(__comp(*--__j, *__i)))
                               :		{}
                               :	      std::iter_swap(__i, __j);
                               :	      std::reverse(__ii, __last);
                               :	      return true;
                               :	    }
                               :	  if (__i == __first)
                               :	    {
                               :	      std::reverse(__first, __last);
                               :	      return false;
                               :	    }
                               :	}
                               :    }
                               :
                               :  // replace
                               :  // replace_if
                               :
                               :  /**
                               :   *  @brief Copy a sequence, replacing each element of one value with another
                               :   *         value.
                               :   *  @param  __first      An input iterator.
                               :   *  @param  __last       An input iterator.
                               :   *  @param  __result     An output iterator.
                               :   *  @param  __old_value  The value to be replaced.
                               :   *  @param  __new_value  The replacement value.
                               :   *  @return   The end of the output sequence, @p result+(last-first).
                               :   *
                               :   *  Copies each element in the input range @p [__first,__last) to the
                               :   *  output range @p [__result,__result+(__last-__first)) replacing elements
                               :   *  equal to @p __old_value with @p __new_value.
                               :  */
                               :  template<typename _InputIterator, typename _OutputIterator, typename _Tp>
                               :    _OutputIterator
                               :    replace_copy(_InputIterator __first, _InputIterator __last,
                               :		 _OutputIterator __result,
                               :		 const _Tp& __old_value, const _Tp& __new_value)
                               :    {
                               :      // concept requirements
                               :      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
                               :      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                               :	    typename iterator_traits<_InputIterator>::value_type>)
                               :      __glibcxx_function_requires(_EqualOpConcept<
                               :	    typename iterator_traits<_InputIterator>::value_type, _Tp>)
                               :      __glibcxx_requires_valid_range(__first, __last);
                               :
                               :      for (; __first != __last; ++__first, ++__result)
                               :	if (*__first == __old_value)
                               :	  *__result = __new_value;
                               :	else
                               :	  *__result = *__first;
                               :      return __result;
                               :    }
                               :
                               :  /**
                               :   *  @brief Copy a sequence, replacing each value for which a predicate
                               :   *         returns true with another value.
                               :   *  @ingroup mutating_algorithms
                               :   *  @param  __first      An input iterator.
                               :   *  @param  __last       An input iterator.
                               :   *  @param  __result     An output iterator.
                               :   *  @param  __pred       A predicate.
                               :   *  @param  __new_value  The replacement value.
                               :   *  @return   The end of the output sequence, @p __result+(__last-__first).
                               :   *
                               :   *  Copies each element in the range @p [__first,__last) to the range
                               :   *  @p [__result,__result+(__last-__first)) replacing elements for which
                               :   *  @p __pred returns true with @p __new_value.
                               :  */
                               :  template<typename _InputIterator, typename _OutputIterator,
                               :	   typename _Predicate, typename _Tp>
                               :    _OutputIterator
                               :    replace_copy_if(_InputIterator __first, _InputIterator __last,
                               :		    _OutputIterator __result,
                               :		    _Predicate __pred, const _Tp& __new_value)
                               :    {
                               :      // concept requirements
                               :      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
                               :      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                               :	    typename iterator_traits<_InputIterator>::value_type>)
                               :      __glibcxx_function_requires(_UnaryPredicateConcept<_Predicate,
                               :	    typename iterator_traits<_InputIterator>::value_type>)
                               :      __glibcxx_requires_valid_range(__first, __last);
                               :
                               :      for (; __first != __last; ++__first, ++__result)
                               :	if (__pred(*__first))
                               :	  *__result = __new_value;
                               :	else
                               :	  *__result = *__first;
                               :      return __result;
                               :    }
                               :
                               :#if __cplusplus >= 201103L
                               :  /**
                               :   *  @brief  Determines whether the elements of a sequence are sorted.
                               :   *  @ingroup sorting_algorithms
                               :   *  @param  __first   An iterator.
                               :   *  @param  __last    Another iterator.
                               :   *  @return  True if the elements are sorted, false otherwise.
                               :  */
                               :  template<typename _ForwardIterator>
                               :    inline bool
                               :    is_sorted(_ForwardIterator __first, _ForwardIterator __last)
                               :    { return std::is_sorted_until(__first, __last) == __last; }
                               :
                               :  /**
                               :   *  @brief  Determines whether the elements of a sequence are sorted
                               :   *          according to a comparison functor.
                               :   *  @ingroup sorting_algorithms
                               :   *  @param  __first   An iterator.
                               :   *  @param  __last    Another iterator.
                               :   *  @param  __comp    A comparison functor.
                               :   *  @return  True if the elements are sorted, false otherwise.
                               :  */
                               :  template<typename _ForwardIterator, typename _Compare>
                               :    inline bool
                               :    is_sorted(_ForwardIterator __first, _ForwardIterator __last,
                               :	      _Compare __comp)
                               :    { return std::is_sorted_until(__first, __last, __comp) == __last; }
                               :
                               :  /**
                               :   *  @brief  Determines the end of a sorted sequence.
                               :   *  @ingroup sorting_algorithms
                               :   *  @param  __first   An iterator.
                               :   *  @param  __last    Another iterator.
                               :   *  @return  An iterator pointing to the last iterator i in [__first, __last)
                               :   *           for which the range [__first, i) is sorted.
                               :  */
                               :  template<typename _ForwardIterator>
                               :    _ForwardIterator
                               :    is_sorted_until(_ForwardIterator __first, _ForwardIterator __last)
                               :    {
                               :      // concept requirements
                               :      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                               :      __glibcxx_function_requires(_LessThanComparableConcept<
                               :	    typename iterator_traits<_ForwardIterator>::value_type>)
                               :      __glibcxx_requires_valid_range(__first, __last);
                               :
                               :      if (__first == __last)
                               :	return __last;
                               :
                               :      _ForwardIterator __next = __first;
                               :      for (++__next; __next != __last; __first = __next, ++__next)
                               :	if (*__next < *__first)
                               :	  return __next;
                               :      return __next;
                               :    }
                               :
                               :  /**
                               :   *  @brief  Determines the end of a sorted sequence using comparison functor.
                               :   *  @ingroup sorting_algorithms
                               :   *  @param  __first   An iterator.
                               :   *  @param  __last    Another iterator.
                               :   *  @param  __comp    A comparison functor.
                               :   *  @return  An iterator pointing to the last iterator i in [__first, __last)
                               :   *           for which the range [__first, i) is sorted.
                               :  */
                               :  template<typename _ForwardIterator, typename _Compare>
                               :    _ForwardIterator
                               :    is_sorted_until(_ForwardIterator __first, _ForwardIterator __last,
                               :		    _Compare __comp)
                               :    {
                               :      // concept requirements
                               :      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                               :      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
                               :	    typename iterator_traits<_ForwardIterator>::value_type,
                               :	    typename iterator_traits<_ForwardIterator>::value_type>)
                               :      __glibcxx_requires_valid_range(__first, __last);
                               :
                               :      if (__first == __last)
                               :	return __last;
                               :
                               :      _ForwardIterator __next = __first;
                               :      for (++__next; __next != __last; __first = __next, ++__next)
                               :	if (__comp(*__next, *__first))
                               :	  return __next;
                               :      return __next;
                               :    }
                               :
                               :  /**
                               :   *  @brief  Determines min and max at once as an ordered pair.
                               :   *  @ingroup sorting_algorithms
                               :   *  @param  __a  A thing of arbitrary type.
                               :   *  @param  __b  Another thing of arbitrary type.
                               :   *  @return A pair(__b, __a) if __b is smaller than __a, pair(__a,
                               :   *  __b) otherwise.
                               :  */
                               :  template<typename _Tp>
                               :    inline pair<const _Tp&, const _Tp&>
                               :    minmax(const _Tp& __a, const _Tp& __b)
                               :    {
                               :      // concept requirements
                               :      __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)
                               :
                               :      return __b < __a ? pair<const _Tp&, const _Tp&>(__b, __a)
                               :	               : pair<const _Tp&, const _Tp&>(__a, __b);
                               :    }
                               :
                               :  /**
                               :   *  @brief  Determines min and max at once as an ordered pair.
                               :   *  @ingroup sorting_algorithms
                               :   *  @param  __a  A thing of arbitrary type.
                               :   *  @param  __b  Another thing of arbitrary type.
                               :   *  @param  __comp  A @link comparison_functors comparison functor @endlink.
                               :   *  @return A pair(__b, __a) if __b is smaller than __a, pair(__a,
                               :   *  __b) otherwise.
                               :  */
                               :  template<typename _Tp, typename _Compare>
                               :    inline pair<const _Tp&, const _Tp&>
                               :    minmax(const _Tp& __a, const _Tp& __b, _Compare __comp)
                               :    {
                               :      return __comp(__b, __a) ? pair<const _Tp&, const _Tp&>(__b, __a)
                               :	                      : pair<const _Tp&, const _Tp&>(__a, __b);
                               :    }
                               :
                               :  /**
                               :   *  @brief  Return a pair of iterators pointing to the minimum and maximum
                               :   *          elements in a range.
                               :   *  @ingroup sorting_algorithms
                               :   *  @param  __first  Start of range.
                               :   *  @param  __last   End of range.
                               :   *  @return  make_pair(m, M), where m is the first iterator i in 
                               :   *           [__first, __last) such that no other element in the range is
                               :   *           smaller, and where M is the last iterator i in [__first, __last)
                               :   *           such that no other element in the range is larger.
                               :  */
                               :  template<typename _ForwardIterator>
                               :    pair<_ForwardIterator, _ForwardIterator>
                               :    minmax_element(_ForwardIterator __first, _ForwardIterator __last)
                               :    {
                               :      // concept requirements
                               :      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                               :      __glibcxx_function_requires(_LessThanComparableConcept<
                               :	    typename iterator_traits<_ForwardIterator>::value_type>)
                               :      __glibcxx_requires_valid_range(__first, __last);
                               :
                               :      _ForwardIterator __next = __first;
                               :      if (__first == __last
                               :	  || ++__next == __last)
                               :	return std::make_pair(__first, __first);
                               :
                               :      _ForwardIterator __min, __max;
                               :      if (*__next < *__first)
                               :	{
                               :	  __min = __next;
                               :	  __max = __first;
                               :	}
                               :      else
                               :	{
                               :	  __min = __first;
                               :	  __max = __next;
                               :	}
                               :
                               :      __first = __next;
                               :      ++__first;
                               :
                               :      while (__first != __last)
                               :	{
                               :	  __next = __first;
                               :	  if (++__next == __last)
                               :	    {
                               :	      if (*__first < *__min)
                               :		__min = __first;
                               :	      else if (!(*__first < *__max))
                               :		__max = __first;
                               :	      break;
                               :	    }
                               :
                               :	  if (*__next < *__first)
                               :	    {
                               :	      if (*__next < *__min)
                               :		__min = __next;
                               :	      if (!(*__first < *__max))
                               :		__max = __first;
                               :	    }
                               :	  else
                               :	    {
                               :	      if (*__first < *__min)
                               :		__min = __first;
                               :	      if (!(*__next < *__max))
                               :		__max = __next;
                               :	    }
                               :
                               :	  __first = __next;
                               :	  ++__first;
                               :	}
                               :
                               :      return std::make_pair(__min, __max);
                               :    }
                               :
                               :  /**
                               :   *  @brief  Return a pair of iterators pointing to the minimum and maximum
                               :   *          elements in a range.
                               :   *  @ingroup sorting_algorithms
                               :   *  @param  __first  Start of range.
                               :   *  @param  __last   End of range.
                               :   *  @param  __comp   Comparison functor.
                               :   *  @return  make_pair(m, M), where m is the first iterator i in 
                               :   *           [__first, __last) such that no other element in the range is
                               :   *           smaller, and where M is the last iterator i in [__first, __last)
                               :   *           such that no other element in the range is larger.
                               :  */
                               :  template<typename _ForwardIterator, typename _Compare>
                               :    pair<_ForwardIterator, _ForwardIterator>
                               :    minmax_element(_ForwardIterator __first, _ForwardIterator __last,
                               :		   _Compare __comp)
                               :    {
                               :      // concept requirements
                               :      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                               :      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
                               :	    typename iterator_traits<_ForwardIterator>::value_type,
                               :	    typename iterator_traits<_ForwardIterator>::value_type>)
                               :      __glibcxx_requires_valid_range(__first, __last);
                               :
                               :      _ForwardIterator __next = __first;
                               :      if (__first == __last
                               :	  || ++__next == __last)
                               :	return std::make_pair(__first, __first);
                               :
                               :      _ForwardIterator __min, __max;
                               :      if (__comp(*__next, *__first))
                               :	{
                               :	  __min = __next;
                               :	  __max = __first;
                               :	}
                               :      else
                               :	{
                               :	  __min = __first;
                               :	  __max = __next;
                               :	}
                               :
                               :      __first = __next;
                               :      ++__first;
                               :
                               :      while (__first != __last)
                               :	{
                               :	  __next = __first;
                               :	  if (++__next == __last)
                               :	    {
                               :	      if (__comp(*__first, *__min))
                               :		__min = __first;
                               :	      else if (!__comp(*__first, *__max))
                               :		__max = __first;
                               :	      break;
                               :	    }
                               :
                               :	  if (__comp(*__next, *__first))
                               :	    {
                               :	      if (__comp(*__next, *__min))
                               :		__min = __next;
                               :	      if (!__comp(*__first, *__max))
                               :		__max = __first;
                               :	    }
                               :	  else
                               :	    {
                               :	      if (__comp(*__first, *__min))
                               :		__min = __first;
                               :	      if (!__comp(*__next, *__max))
                               :		__max = __next;
                               :	    }
                               :
                               :	  __first = __next;
                               :	  ++__first;
                               :	}
                               :
                               :      return std::make_pair(__min, __max);
                               :    }
                               :
                               :  // N2722 + DR 915.
                               :  template<typename _Tp>
                               :    inline _Tp
                               :    min(initializer_list<_Tp> __l)
                               :    { return *std::min_element(__l.begin(), __l.end()); }
                               :
                               :  template<typename _Tp, typename _Compare>
                               :    inline _Tp
                               :    min(initializer_list<_Tp> __l, _Compare __comp)
                               :    { return *std::min_element(__l.begin(), __l.end(), __comp); }
                               :
                               :  template<typename _Tp>
                               :    inline _Tp
                               :    max(initializer_list<_Tp> __l)
                               :    { return *std::max_element(__l.begin(), __l.end()); }
                               :
                               :  template<typename _Tp, typename _Compare>
                               :    inline _Tp
                               :    max(initializer_list<_Tp> __l, _Compare __comp)
                               :    { return *std::max_element(__l.begin(), __l.end(), __comp); }
                               :
                               :  template<typename _Tp>
                               :    inline pair<_Tp, _Tp>
                               :    minmax(initializer_list<_Tp> __l)
                               :    {
                               :      pair<const _Tp*, const _Tp*> __p =
                               :	std::minmax_element(__l.begin(), __l.end());
                               :      return std::make_pair(*__p.first, *__p.second);
                               :    }
                               :
                               :  template<typename _Tp, typename _Compare>
                               :    inline pair<_Tp, _Tp>
                               :    minmax(initializer_list<_Tp> __l, _Compare __comp)
                               :    {
                               :      pair<const _Tp*, const _Tp*> __p =
                               :	std::minmax_element(__l.begin(), __l.end(), __comp);
                               :      return std::make_pair(*__p.first, *__p.second);
                               :    }
                               :
                               :  /**
                               :   *  @brief  Checks whether a permutaion of the second sequence is equal
                               :   *          to the first sequence.
                               :   *  @ingroup non_mutating_algorithms
                               :   *  @param  __first1  Start of first range.
                               :   *  @param  __last1   End of first range.
                               :   *  @param  __first2  Start of second range.
                               :   *  @return true if there exists a permutation of the elements in the range
                               :   *          [__first2, __first2 + (__last1 - __first1)), beginning with 
                               :   *          ForwardIterator2 begin, such that equal(__first1, __last1, begin)
                               :   *          returns true; otherwise, returns false.
                               :  */
                               :  template<typename _ForwardIterator1, typename _ForwardIterator2>
                               :    bool
                               :    is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
                               :		   _ForwardIterator2 __first2)
                               :    {
                               :      // Efficiently compare identical prefixes:  O(N) if sequences
                               :      // have the same elements in the same order.
                               :      for (; __first1 != __last1; ++__first1, ++__first2)
                               :	if (!(*__first1 == *__first2))
                               :	  break;
                               :
                               :      if (__first1 == __last1)
                               :	return true;
                               :
                               :      // Establish __last2 assuming equal ranges by iterating over the
                               :      // rest of the list.
                               :      _ForwardIterator2 __last2 = __first2;
                               :      std::advance(__last2, std::distance(__first1, __last1));
                               :      for (_ForwardIterator1 __scan = __first1; __scan != __last1; ++__scan)
                               :	{
                               :	  if (__scan != _GLIBCXX_STD_A::find(__first1, __scan, *__scan))
                               :	    continue; // We've seen this one before.
                               :
                               :	  auto __matches = std::count(__first2, __last2, *__scan);
                               :	  if (0 == __matches
                               :	      || std::count(__scan, __last1, *__scan) != __matches)
                               :	    return false;
                               :	}
                               :      return true;
                               :    }
                               :
                               :  /**
                               :   *  @brief  Checks whether a permutation of the second sequence is equal
                               :   *          to the first sequence.
                               :   *  @ingroup non_mutating_algorithms
                               :   *  @param  __first1  Start of first range.
                               :   *  @param  __last1   End of first range.
                               :   *  @param  __first2  Start of second range.
                               :   *  @param  __pred    A binary predicate.
                               :   *  @return true if there exists a permutation of the elements in
                               :   *          the range [__first2, __first2 + (__last1 - __first1)),
                               :   *          beginning with ForwardIterator2 begin, such that
                               :   *          equal(__first1, __last1, __begin, __pred) returns true;
                               :   *          otherwise, returns false.
                               :  */
                               :  template<typename _ForwardIterator1, typename _ForwardIterator2,
                               :	   typename _BinaryPredicate>
                               :    bool
                               :    is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
                               :		   _ForwardIterator2 __first2, _BinaryPredicate __pred)
                               :    {
                               :      // Efficiently compare identical prefixes:  O(N) if sequences
                               :      // have the same elements in the same order.
                               :      for (; __first1 != __last1; ++__first1, ++__first2)
                               :	if (!bool(__pred(*__first1, *__first2)))
                               :	  break;
                               :
                               :      if (__first1 == __last1)
                               :	return true;
                               :
                               :      // Establish __last2 assuming equal ranges by iterating over the
                               :      // rest of the list.
                               :      _ForwardIterator2 __last2 = __first2;
                               :      std::advance(__last2, std::distance(__first1, __last1));
                               :      for (_ForwardIterator1 __scan = __first1; __scan != __last1; ++__scan)
                               :	{
                               :	  using std::placeholders::_1;
                               :
                               :	  if (__scan != _GLIBCXX_STD_A::find_if(__first1, __scan,
                               :						std::bind(__pred, _1, *__scan)))
                               :	    continue; // We've seen this one before.
                               :	  
                               :	  auto __matches = std::count_if(__first2, __last2,
                               :					 std::bind(__pred, _1, *__scan));
                               :	  if (0 == __matches
                               :	      || std::count_if(__scan, __last1,
                               :			       std::bind(__pred, _1, *__scan)) != __matches)
                               :	    return false;
                               :	}
                               :      return true;
                               :    }
                               :
                               :#ifdef _GLIBCXX_USE_C99_STDINT_TR1
                               :  /**
                               :   *  @brief Shuffle the elements of a sequence using a uniform random
                               :   *         number generator.
                               :   *  @ingroup mutating_algorithms
                               :   *  @param  __first   A forward iterator.
                               :   *  @param  __last    A forward iterator.
                               :   *  @param  __g       A UniformRandomNumberGenerator (26.5.1.3).
                               :   *  @return  Nothing.
                               :   *
                               :   *  Reorders the elements in the range @p [__first,__last) using @p __g to
                               :   *  provide random numbers.
                               :  */
                               :  template<typename _RandomAccessIterator,
                               :	   typename _UniformRandomNumberGenerator>
                               :    void
                               :    shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,
                               :	    _UniformRandomNumberGenerator&& __g)
                               :    {
                               :      // concept requirements
                               :      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
                               :	    _RandomAccessIterator>)
                               :      __glibcxx_requires_valid_range(__first, __last);
                               :
                               :      if (__first == __last)
                               :	return;
                               :
                               :      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
                               :	_DistanceType;
                               :
                               :      typedef typename std::make_unsigned<_DistanceType>::type __ud_type;
                               :      typedef typename std::uniform_int_distribution<__ud_type> __distr_type;
                               :      typedef typename __distr_type::param_type __p_type;
                               :      __distr_type __d;
                               :
                               :      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
                               :	std::iter_swap(__i, __first + __d(__g, __p_type(0, __i - __first)));
                               :    }
                               :#endif
                               :
                               :#endif // C++11
                               :
                               :_GLIBCXX_END_NAMESPACE_VERSION
                               :
                               :_GLIBCXX_BEGIN_NAMESPACE_ALGO
                               :
                               :  /**
                               :   *  @brief Apply a function to every element of a sequence.
                               :   *  @ingroup non_mutating_algorithms
                               :   *  @param  __first  An input iterator.
                               :   *  @param  __last   An input iterator.
                               :   *  @param  __f      A unary function object.
                               :   *  @return   @p __f (std::move(@p __f) in C++0x).
                               :   *
                               :   *  Applies the function object @p __f to each element in the range
                               :   *  @p [first,last).  @p __f must not modify the order of the sequence.
                               :   *  If @p __f has a return value it is ignored.
                               :  */
                               :  template<typename _InputIterator, typename _Function>
                               :    _Function
                               :    for_each(_InputIterator __first, _InputIterator __last, _Function __f)
                               :    {
                               :      // concept requirements
                               :      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
                               :      __glibcxx_requires_valid_range(__first, __last);
                               :      for (; __first != __last; ++__first)
                               :	__f(*__first);
                               :      return _GLIBCXX_MOVE(__f);
                               :    }
                               :
                               :  /**
                               :   *  @brief Find the first occurrence of a value in a sequence.
                               :   *  @ingroup non_mutating_algorithms
                               :   *  @param  __first  An input iterator.
                               :   *  @param  __last   An input iterator.
                               :   *  @param  __val    The value to find.
                               :   *  @return   The first iterator @c i in the range @p [__first,__last)
                               :   *  such that @c *i == @p __val, or @p __last if no such iterator exists.
                               :  */
                               :  template<typename _InputIterator, typename _Tp>
                               :    inline _InputIterator
                               :    find(_InputIterator __first, _InputIterator __last,
                               :	 const _Tp& __val)
                               :    {
                               :      // concept requirements
                               :      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
                               :      __glibcxx_function_requires(_EqualOpConcept<
                               :		typename iterator_traits<_InputIterator>::value_type, _Tp>)
                               :      __glibcxx_requires_valid_range(__first, __last);
                               :      return std::__find(__first, __last, __val,
                               :		         std::__iterator_category(__first));
                               :    }
                               :
                               :  /**
                               :   *  @brief Find the first element in a sequence for which a
                               :   *         predicate is true.
                               :   *  @ingroup non_mutating_algorithms
                               :   *  @param  __first  An input iterator.
                               :   *  @param  __last   An input iterator.
                               :   *  @param  __pred   A predicate.
                               :   *  @return   The first iterator @c i in the range @p [__first,__last)
                               :   *  such that @p __pred(*i) is true, or @p __last if no such iterator exists.
                               :  */
                               :  template<typename _InputIterator, typename _Predicate>
                               :    inline _InputIterator
                               :    find_if(_InputIterator __first, _InputIterator __last,
                               :	    _Predicate __pred)
                               :    {
                               :      // concept requirements
                               :      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
                               :      __glibcxx_function_requires(_UnaryPredicateConcept<_Predicate,
                               :	      typename iterator_traits<_InputIterator>::value_type>)
                               :      __glibcxx_requires_valid_range(__first, __last);
                               :      return std::__find_if(__first, __last, __pred,
                               :			    std::__iterator_category(__first));
                               :    }
                               :
                               :  /**
                               :   *  @brief  Find element from a set in a sequence.
                               :   *  @ingroup non_mutating_algorithms
                               :   *  @param  __first1  Start of range to search.
                               :   *  @param  __last1   End of range to search.
                               :   *  @param  __first2  Start of match candidates.
                               :   *  @param  __last2   End of match candidates.
                               :   *  @return   The first iterator @c i in the range
                               :   *  @p [__first1,__last1) such that @c *i == @p *(i2) such that i2 is an
                               :   *  iterator in [__first2,__last2), or @p __last1 if no such iterator exists.
                               :   *
                               :   *  Searches the range @p [__first1,__last1) for an element that is
                               :   *  equal to some element in the range [__first2,__last2).  If
                               :   *  found, returns an iterator in the range [__first1,__last1),
                               :   *  otherwise returns @p __last1.
                               :  */
                               :  template<typename _InputIterator, typename _ForwardIterator>
                               :    _InputIterator
                               :    find_first_of(_InputIterator __first1, _InputIterator __last1,
                               :		  _ForwardIterator __first2, _ForwardIterator __last2)
                               :    {
                               :      // concept requirements
                               :      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
                               :      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                               :      __glibcxx_function_requires(_EqualOpConcept<
                               :	    typename iterator_traits<_InputIterator>::value_type,
                               :	    typename iterator_traits<_ForwardIterator>::value_type>)
                               :      __glibcxx_requires_valid_range(__first1, __last1);
                               :      __glibcxx_requires_valid_range(__first2, __last2);
                               :
                               :      for (; __first1 != __last1; ++__first1)
                               :	for (_ForwardIterator __iter = __first2; __iter != __last2; ++__iter)
                               :	  if (*__first1 == *__iter)
                               :	    return __first1;
                               :      return __last1;
                               :    }
                               :
                               :  /**
                               :   *  @brief  Find element from a set in a sequence using a predicate.
                               :   *  @ingroup non_mutating_algorithms
                               :   *  @param  __first1  Start of range to search.
                               :   *  @param  __last1   End of range to search.
                               :   *  @param  __first2  Start of match candidates.
                               :   *  @param  __last2   End of match candidates.
                               :   *  @param  __comp    Predicate to use.
                               :   *  @return   The first iterator @c i in the range
                               :   *  @p [__first1,__last1) such that @c comp(*i, @p *(i2)) is true
                               :   *  and i2 is an iterator in [__first2,__last2), or @p __last1 if no
                               :   *  such iterator exists.
                               :   *
                               :
                               :   *  Searches the range @p [__first1,__last1) for an element that is
                               :   *  equal to some element in the range [__first2,__last2).  If
                               :   *  found, returns an iterator in the range [__first1,__last1),
                               :   *  otherwise returns @p __last1.
                               :  */
                               :  template<typename _InputIterator, typename _ForwardIterator,
                               :	   typename _BinaryPredicate>
                               :    _InputIterator
                               :    find_first_of(_InputIterator __first1, _InputIterator __last1,
                               :		  _ForwardIterator __first2, _ForwardIterator __last2,
                               :		  _BinaryPredicate __comp)
                               :    {
                               :      // concept requirements
                               :      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
                               :      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                               :      __glibcxx_function_requires(_BinaryPredicateConcept<_BinaryPredicate,
                               :	    typename iterator_traits<_InputIterator>::value_type,
                               :	    typename iterator_traits<_ForwardIterator>::value_type>)
                               :      __glibcxx_requires_valid_range(__first1, __last1);
                               :      __glibcxx_requires_valid_range(__first2, __last2);
                               :
                               :      for (; __first1 != __last1; ++__first1)
                               :	for (_ForwardIterator __iter = __first2; __iter != __last2; ++__iter)
                               :	  if (__comp(*__first1, *__iter))
                               :	    return __first1;
                               :      return __last1;
                               :    }
                               :
                               :  /**
                               :   *  @brief Find two adjacent values in a sequence that are equal.
                               :   *  @ingroup non_mutating_algorithms
                               :   *  @param  __first  A forward iterator.
                               :   *  @param  __last   A forward iterator.
                               :   *  @return   The first iterator @c i such that @c i and @c i+1 are both
                               :   *  valid iterators in @p [__first,__last) and such that @c *i == @c *(i+1),
                               :   *  or @p __last if no such iterator exists.
                               :  */
                               :  template<typename _ForwardIterator>
                               :    _ForwardIterator
                               :    adjacent_find(_ForwardIterator __first, _ForwardIterator __last)
                               :    {
                               :      // concept requirements
                               :      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                               :      __glibcxx_function_requires(_EqualityComparableConcept<
                               :	    typename iterator_traits<_ForwardIterator>::value_type>)
                               :      __glibcxx_requires_valid_range(__first, __last);
                               :      if (__first == __last)
                               :	return __last;
                               :      _ForwardIterator __next = __first;
                               :      while(++__next != __last)
                               :	{
                               :	  if (*__first == *__next)
                               :	    return __first;
                               :	  __first = __next;
                               :	}
                               :      return __last;
                               :    }
                               :
                               :  /**
                               :   *  @brief Find two adjacent values in a sequence using a predicate.
                               :   *  @ingroup non_mutating_algorithms
                               :   *  @param  __first         A forward iterator.
                               :   *  @param  __last          A forward iterator.
                               :   *  @param  __binary_pred   A binary predicate.
                               :   *  @return   The first iterator @c i such that @c i and @c i+1 are both
                               :   *  valid iterators in @p [__first,__last) and such that
                               :   *  @p __binary_pred(*i,*(i+1)) is true, or @p __last if no such iterator
                               :   *  exists.
                               :  */
                               :  template<typename _ForwardIterator, typename _BinaryPredicate>
                               :    _ForwardIterator
                               :    adjacent_find(_ForwardIterator __first, _ForwardIterator __last,
                               :		  _BinaryPredicate __binary_pred)
                               :    {
                               :      // concept requirements
                               :      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                               :      __glibcxx_function_requires(_BinaryPredicateConcept<_BinaryPredicate,
                               :	    typename iterator_traits<_ForwardIterator>::value_type,
                               :	    typename iterator_traits<_ForwardIterator>::value_type>)
                               :      __glibcxx_requires_valid_range(__first, __last);
                               :      if (__first == __last)
                               :	return __last;
                               :      _ForwardIterator __next = __first;
                               :      while(++__next != __last)
                               :	{
                               :	  if (__binary_pred(*__first, *__next))
                               :	    return __first;
                               :	  __first = __next;
                               :	}
                               :      return __last;
                               :    }
                               :
                               :  /**
                               :   *  @brief Count the number of copies of a value in a sequence.
                               :   *  @ingroup non_mutating_algorithms
                               :   *  @param  __first  An input iterator.
                               :   *  @param  __last   An input iterator.
                               :   *  @param  __value  The value to be counted.
                               :   *  @return   The number of iterators @c i in the range @p [__first,__last)
                               :   *  for which @c *i == @p __value
                               :  */
                               :  template<typename _InputIterator, typename _Tp>
                               :    typename iterator_traits<_InputIterator>::difference_type
                               :    count(_InputIterator __first, _InputIterator __last, const _Tp& __value)
                               :    {
                               :      // concept requirements
                               :      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
                               :      __glibcxx_function_requires(_EqualOpConcept<
                               :	typename iterator_traits<_InputIterator>::value_type, _Tp>)
                               :      __glibcxx_requires_valid_range(__first, __last);
                               :      typename iterator_traits<_InputIterator>::difference_type __n = 0;
                               :      for (; __first != __last; ++__first)
                               :	if (*__first == __value)
                               :	  ++__n;
                               :      return __n;
                               :    }
                               :
                               :  /**
                               :   *  @brief Count the elements of a sequence for which a predicate is true.
                               :   *  @ingroup non_mutating_algorithms
                               :   *  @param  __first  An input iterator.
                               :   *  @param  __last   An input iterator.
                               :   *  @param  __pred   A predicate.
                               :   *  @return   The number of iterators @c i in the range @p [__first,__last)
                               :   *  for which @p __pred(*i) is true.
                               :  */
                               :  template<typename _InputIterator, typename _Predicate>
                               :    typename iterator_traits<_InputIterator>::difference_type
                               :    count_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)
                               :    {
                               :      // concept requirements
                               :      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
                               :      __glibcxx_function_requires(_UnaryPredicateConcept<_Predicate,
                               :	    typename iterator_traits<_InputIterator>::value_type>)
                               :      __glibcxx_requires_valid_range(__first, __last);
                               :      typename iterator_traits<_InputIterator>::difference_type __n = 0;
                               :      for (; __first != __last; ++__first)
                               :	if (__pred(*__first))
                               :	  ++__n;
                               :      return __n;
                               :    }
                               :
                               :  /**
                               :   *  @brief Search a sequence for a matching sub-sequence.
                               :   *  @ingroup non_mutating_algorithms
                               :   *  @param  __first1  A forward iterator.
                               :   *  @param  __last1   A forward iterator.
                               :   *  @param  __first2  A forward iterator.
                               :   *  @param  __last2   A forward iterator.
                               :   *  @return The first iterator @c i in the range @p
                               :   *  [__first1,__last1-(__last2-__first2)) such that @c *(i+N) == @p
                               :   *  *(__first2+N) for each @c N in the range @p
                               :   *  [0,__last2-__first2), or @p __last1 if no such iterator exists.
                               :   *
                               :   *  Searches the range @p [__first1,__last1) for a sub-sequence that
                               :   *  compares equal value-by-value with the sequence given by @p
                               :   *  [__first2,__last2) and returns an iterator to the first element
                               :   *  of the sub-sequence, or @p __last1 if the sub-sequence is not
                               :   *  found.
                               :   *
                               :   *  Because the sub-sequence must lie completely within the range @p
                               :   *  [__first1,__last1) it must start at a position less than @p
                               :   *  __last1-(__last2-__first2) where @p __last2-__first2 is the
                               :   *  length of the sub-sequence.
                               :   *
                               :   *  This means that the returned iterator @c i will be in the range
                               :   *  @p [__first1,__last1-(__last2-__first2))
                               :  */
                               :  template<typename _ForwardIterator1, typename _ForwardIterator2>
                               :    _ForwardIterator1
                               :    search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
                               :	   _ForwardIterator2 __first2, _ForwardIterator2 __last2)
                               :    {
                               :      // concept requirements
                               :      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator1>)
                               :      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator2>)
                               :      __glibcxx_function_requires(_EqualOpConcept<
                               :	    typename iterator_traits<_ForwardIterator1>::value_type,
                               :	    typename iterator_traits<_ForwardIterator2>::value_type>)
                               :      __glibcxx_requires_valid_range(__first1, __last1);
                               :      __glibcxx_requires_valid_range(__first2, __last2);
                               :
                               :      // Test for empty ranges
                               :      if (__first1 == __last1 || __first2 == __last2)
                               :	return __first1;
                               :
                               :      // Test for a pattern of length 1.
                               :      _ForwardIterator2 __p1(__first2);
                               :      if (++__p1 == __last2)
                               :	return _GLIBCXX_STD_A::find(__first1, __last1, *__first2);
                               :
                               :      // General case.
                               :      _ForwardIterator2 __p;
                               :      _ForwardIterator1 __current = __first1;
                               :
                               :      for (;;)
                               :	{
                               :	  __first1 = _GLIBCXX_STD_A::find(__first1, __last1, *__first2);
                               :	  if (__first1 == __last1)
                               :	    return __last1;
                               :
                               :	  __p = __p1;
                               :	  __current = __first1;
                               :	  if (++__current == __last1)
                               :	    return __last1;
                               :
                               :	  while (*__current == *__p)
                               :	    {
                               :	      if (++__p == __last2)
                               :		return __first1;
                               :	      if (++__current == __last1)
                               :		return __last1;
                               :	    }
                               :	  ++__first1;
                               :	}
                               :      return __first1;
                               :    }
                               :
                               :  /**
                               :   *  @brief Search a sequence for a matching sub-sequence using a predicate.
                               :   *  @ingroup non_mutating_algorithms
                               :   *  @param  __first1     A forward iterator.
                               :   *  @param  __last1      A forward iterator.
                               :   *  @param  __first2     A forward iterator.
                               :   *  @param  __last2      A forward iterator.
                               :   *  @param  __predicate  A binary predicate.
                               :   *  @return   The first iterator @c i in the range
                               :   *  @p [__first1,__last1-(__last2-__first2)) such that
                               :   *  @p __predicate(*(i+N),*(__first2+N)) is true for each @c N in the range
                               :   *  @p [0,__last2-__first2), or @p __last1 if no such iterator exists.
                               :   *
                               :   *  Searches the range @p [__first1,__last1) for a sub-sequence that
                               :   *  compares equal value-by-value with the sequence given by @p
                               :   *  [__first2,__last2), using @p __predicate to determine equality,
                               :   *  and returns an iterator to the first element of the
                               :   *  sub-sequence, or @p __last1 if no such iterator exists.
                               :   *
                               :   *  @see search(_ForwardIter1, _ForwardIter1, _ForwardIter2, _ForwardIter2)
                               :  */
                               :  template<typename _ForwardIterator1, typename _ForwardIterator2,
                               :	   typename _BinaryPredicate>
                               :    _ForwardIterator1
                               :    search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
                               :	   _ForwardIterator2 __first2, _ForwardIterator2 __last2,
                               :	   _BinaryPredicate  __predicate)
                               :    {
                               :      // concept requirements
                               :      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator1>)
                               :      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator2>)
                               :      __glibcxx_function_requires(_BinaryPredicateConcept<_BinaryPredicate,
                               :	    typename iterator_traits<_ForwardIterator1>::value_type,
                               :	    typename iterator_traits<_ForwardIterator2>::value_type>)
                               :      __glibcxx_requires_valid_range(__first1, __last1);
                               :      __glibcxx_requires_valid_range(__first2, __last2);
                               :
                               :      // Test for empty ranges
                               :      if (__first1 == __last1 || __first2 == __last2)
                               :	return __first1;
                               :
                               :      // Test for a pattern of length 1.
                               :      _ForwardIterator2 __p1(__first2);
                               :      if (++__p1 == __last2)
                               :	{
                               :	  while (__first1 != __last1
                               :		 && !bool(__predicate(*__first1, *__first2)))
                               :	    ++__first1;
                               :	  return __first1;
                               :	}
                               :
                               :      // General case.
                               :      _ForwardIterator2 __p;
                               :      _ForwardIterator1 __current = __first1;
                               :
                               :      for (;;)
                               :	{
                               :	  while (__first1 != __last1
                               :		 && !bool(__predicate(*__first1, *__first2)))
                               :	    ++__first1;
                               :	  if (__first1 == __last1)
                               :	    return __last1;
                               :
                               :	  __p = __p1;
                               :	  __current = __first1;
                               :	  if (++__current == __last1)
                               :	    return __last1;
                               :
                               :	  while (__predicate(*__current, *__p))
                               :	    {
                               :	      if (++__p == __last2)
                               :		return __first1;
                               :	      if (++__current == __last1)
                               :		return __last1;
                               :	    }
                               :	  ++__first1;
                               :	}
                               :      return __first1;
                               :    }
                               :
                               :
                               :  /**
                               :   *  @brief Search a sequence for a number of consecutive values.
                               :   *  @ingroup non_mutating_algorithms
                               :   *  @param  __first  A forward iterator.
                               :   *  @param  __last   A forward iterator.
                               :   *  @param  __count  The number of consecutive values.
                               :   *  @param  __val    The value to find.
                               :   *  @return The first iterator @c i in the range @p
                               :   *  [__first,__last-__count) such that @c *(i+N) == @p __val for
                               :   *  each @c N in the range @p [0,__count), or @p __last if no such
                               :   *  iterator exists.
                               :   *
                               :   *  Searches the range @p [__first,__last) for @p count consecutive elements
                               :   *  equal to @p __val.
                               :  */
                               :  template<typename _ForwardIterator, typename _Integer, typename _Tp>
                               :    _ForwardIterator
                               :    search_n(_ForwardIterator __first, _ForwardIterator __last,
                               :	     _Integer __count, const _Tp& __val)
                               :    {
                               :      // concept requirements
                               :      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                               :      __glibcxx_function_requires(_EqualOpConcept<
                               :	typename iterator_traits<_ForwardIterator>::value_type, _Tp>)
                               :      __glibcxx_requires_valid_range(__first, __last);
                               :
                               :      if (__count <= 0)
                               :	return __first;
                               :      if (__count == 1)
                               :	return _GLIBCXX_STD_A::find(__first, __last, __val);
                               :      return std::__search_n(__first, __last, __count, __val,
                               :			     std::__iterator_category(__first));
                               :    }
                               :
                               :
                               :  /**
                               :   *  @brief Search a sequence for a number of consecutive values using a
                               :   *         predicate.
                               :   *  @ingroup non_mutating_algorithms
                               :   *  @param  __first        A forward iterator.
                               :   *  @param  __last         A forward iterator.
                               :   *  @param  __count        The number of consecutive values.
                               :   *  @param  __val          The value to find.
                               :   *  @param  __binary_pred  A binary predicate.
                               :   *  @return The first iterator @c i in the range @p
                               :   *  [__first,__last-__count) such that @p
                               :   *  __binary_pred(*(i+N),__val) is true for each @c N in the range
                               :   *  @p [0,__count), or @p __last if no such iterator exists.
                               :   *
                               :   *  Searches the range @p [__first,__last) for @p __count
                               :   *  consecutive elements for which the predicate returns true.
                               :  */
                               :  template<typename _ForwardIterator, typename _Integer, typename _Tp,
                               :           typename _BinaryPredicate>
                               :    _ForwardIterator
                               :    search_n(_ForwardIterator __first, _ForwardIterator __last,
                               :	     _Integer __count, const _Tp& __val,
                               :	     _BinaryPredicate __binary_pred)
                               :    {
                               :      // concept requirements
                               :      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                               :      __glibcxx_function_requires(_BinaryPredicateConcept<_BinaryPredicate,
                               :	    typename iterator_traits<_ForwardIterator>::value_type, _Tp>)
                               :      __glibcxx_requires_valid_range(__first, __last);
                               :
                               :      if (__count <= 0)
                               :	return __first;
                               :      if (__count == 1)
                               :	{
                               :	  while (__first != __last && !bool(__binary_pred(*__first, __val)))
                               :	    ++__first;
                               :	  return __first;
                               :	}
                               :      return std::__search_n(__first, __last, __count, __val, __binary_pred,
                               :			     std::__iterator_category(__first));
                               :    }
                               :
                               :
                               :  /**
                               :   *  @brief Perform an operation on a sequence.
                               :   *  @ingroup mutating_algorithms
                               :   *  @param  __first     An input iterator.
                               :   *  @param  __last      An input iterator.
                               :   *  @param  __result    An output iterator.
                               :   *  @param  __unary_op  A unary operator.
                               :   *  @return   An output iterator equal to @p __result+(__last-__first).
                               :   *
                               :   *  Applies the operator to each element in the input range and assigns
                               :   *  the results to successive elements of the output sequence.
                               :   *  Evaluates @p *(__result+N)=unary_op(*(__first+N)) for each @c N in the
                               :   *  range @p [0,__last-__first).
                               :   *
                               :   *  @p unary_op must not alter its argument.
                               :  */
                               :  template<typename _InputIterator, typename _OutputIterator,
                               :	   typename _UnaryOperation>
                               :    _OutputIterator
                               :    transform(_InputIterator __first, _InputIterator __last,
                               :	      _OutputIterator __result, _UnaryOperation __unary_op)
                               :    {
                               :      // concept requirements
                               :      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
                               :      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                               :            // "the type returned by a _UnaryOperation"
                               :            __typeof__(__unary_op(*__first))>)
                               :      __glibcxx_requires_valid_range(__first, __last);
                               :
                               :      for (; __first != __last; ++__first, ++__result)
                               :	*__result = __unary_op(*__first);
                               :      return __result;
                               :    }
                               :
                               :  /**
                               :   *  @brief Perform an operation on corresponding elements of two sequences.
                               :   *  @ingroup mutating_algorithms
                               :   *  @param  __first1     An input iterator.
                               :   *  @param  __last1      An input iterator.
                               :   *  @param  __first2     An input iterator.
                               :   *  @param  __result     An output iterator.
                               :   *  @param  __binary_op  A binary operator.
                               :   *  @return   An output iterator equal to @p result+(last-first).
                               :   *
                               :   *  Applies the operator to the corresponding elements in the two
                               :   *  input ranges and assigns the results to successive elements of the
                               :   *  output sequence.
                               :   *  Evaluates @p
                               :   *  *(__result+N)=__binary_op(*(__first1+N),*(__first2+N)) for each
                               :   *  @c N in the range @p [0,__last1-__first1).
                               :   *
                               :   *  @p binary_op must not alter either of its arguments.
                               :  */
                               :  template<typename _InputIterator1, typename _InputIterator2,
                               :	   typename _OutputIterator, typename _BinaryOperation>
                               :    _OutputIterator
                               :    transform(_InputIterator1 __first1, _InputIterator1 __last1,
                               :	      _InputIterator2 __first2, _OutputIterator __result,
                               :	      _BinaryOperation __binary_op)
                               :    {
                               :      // concept requirements
                               :      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
                               :      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
                               :      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                               :            // "the type returned by a _BinaryOperation"
                               :            __typeof__(__binary_op(*__first1,*__first2))>)
                               :      __glibcxx_requires_valid_range(__first1, __last1);
                               :
                               :      for (; __first1 != __last1; ++__first1, ++__first2, ++__result)
                               :	*__result = __binary_op(*__first1, *__first2);
                               :      return __result;
                               :    }
                               :
                               :  /**
                               :   *  @brief Replace each occurrence of one value in a sequence with another
                               :   *         value.
                               :   *  @ingroup mutating_algorithms
                               :   *  @param  __first      A forward iterator.
                               :   *  @param  __last       A forward iterator.
                               :   *  @param  __old_value  The value to be replaced.
                               :   *  @param  __new_value  The replacement value.
                               :   *  @return   replace() returns no value.
                               :   *
                               :   *  For each iterator @c i in the range @p [__first,__last) if @c *i ==
                               :   *  @p __old_value then the assignment @c *i = @p __new_value is performed.
                               :  */
                               :  template<typename _ForwardIterator, typename _Tp>
                               :    void
                               :    replace(_ForwardIterator __first, _ForwardIterator __last,
                               :	    const _Tp& __old_value, const _Tp& __new_value)
                               :    {
                               :      // concept requirements
                               :      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
                               :				  _ForwardIterator>)
                               :      __glibcxx_function_requires(_EqualOpConcept<
                               :	    typename iterator_traits<_ForwardIterator>::value_type, _Tp>)
                               :      __glibcxx_function_requires(_ConvertibleConcept<_Tp,
                               :	    typename iterator_traits<_ForwardIterator>::value_type>)
                               :      __glibcxx_requires_valid_range(__first, __last);
                               :
                               :      for (; __first != __last; ++__first)
                               :	if (*__first == __old_value)
                               :	  *__first = __new_value;
                               :    }
                               :
                               :  /**
                               :   *  @brief Replace each value in a sequence for which a predicate returns
                               :   *         true with another value.
                               :   *  @ingroup mutating_algorithms
                               :   *  @param  __first      A forward iterator.
                               :   *  @param  __last       A forward iterator.
                               :   *  @param  __pred       A predicate.
                               :   *  @param  __new_value  The replacement value.
                               :   *  @return   replace_if() returns no value.
                               :   *
                               :   *  For each iterator @c i in the range @p [__first,__last) if @p __pred(*i)
                               :   *  is true then the assignment @c *i = @p __new_value is performed.
                               :  */
                               :  template<typename _ForwardIterator, typename _Predicate, typename _Tp>
                               :    void
                               :    replace_if(_ForwardIterator __first, _ForwardIterator __last,
                               :	       _Predicate __pred, const _Tp& __new_value)
                               :    {
                               :      // concept requirements
                               :      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
                               :				  _ForwardIterator>)
                               :      __glibcxx_function_requires(_ConvertibleConcept<_Tp,
                               :	    typename iterator_traits<_ForwardIterator>::value_type>)
                               :      __glibcxx_function_requires(_UnaryPredicateConcept<_Predicate,
                               :	    typename iterator_traits<_ForwardIterator>::value_type>)
                               :      __glibcxx_requires_valid_range(__first, __last);
                               :
                               :      for (; __first != __last; ++__first)
                               :	if (__pred(*__first))
                               :	  *__first = __new_value;
                               :    }
                               :
                               :  /**
                               :   *  @brief Assign the result of a function object to each value in a
                               :   *         sequence.
                               :   *  @ingroup mutating_algorithms
                               :   *  @param  __first  A forward iterator.
                               :   *  @param  __last   A forward iterator.
                               :   *  @param  __gen    A function object taking no arguments and returning
                               :   *                 std::iterator_traits<_ForwardIterator>::value_type
                               :   *  @return   generate() returns no value.
                               :   *
                               :   *  Performs the assignment @c *i = @p __gen() for each @c i in the range
                               :   *  @p [__first,__last).
                               :  */
                               :  template<typename _ForwardIterator, typename _Generator>
                               :    void
                               :    generate(_ForwardIterator __first, _ForwardIterator __last,
                               :	     _Generator __gen)
                               :    {
                               :      // concept requirements
                               :      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                               :      __glibcxx_function_requires(_GeneratorConcept<_Generator,
                               :	    typename iterator_traits<_ForwardIterator>::value_type>)
                               :      __glibcxx_requires_valid_range(__first, __last);
                               :
                               :      for (; __first != __last; ++__first)
                               :	*__first = __gen();
                               :    }
                               :
                               :  /**
                               :   *  @brief Assign the result of a function object to each value in a
                               :   *         sequence.
                               :   *  @ingroup mutating_algorithms
                               :   *  @param  __first  A forward iterator.
                               :   *  @param  __n      The length of the sequence.
                               :   *  @param  __gen    A function object taking no arguments and returning
                               :   *                 std::iterator_traits<_ForwardIterator>::value_type
                               :   *  @return   The end of the sequence, @p __first+__n
                               :   *
                               :   *  Performs the assignment @c *i = @p __gen() for each @c i in the range
                               :   *  @p [__first,__first+__n).
                               :   *
                               :   *  _GLIBCXX_RESOLVE_LIB_DEFECTS
                               :   *  DR 865. More algorithms that throw away information
                               :  */
                               :  template<typename _OutputIterator, typename _Size, typename _Generator>
                               :    _OutputIterator
                               :    generate_n(_OutputIterator __first, _Size __n, _Generator __gen)
                               :    {
                               :      // concept requirements
                               :      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                               :            // "the type returned by a _Generator"
                               :            __typeof__(__gen())>)
                               :
                               :      for (__decltype(__n + 0) __niter = __n;
                               :	   __niter > 0; --__niter, ++__first)
                               :	*__first = __gen();
                               :      return __first;
                               :    }
                               :
                               :
                               :  /**
                               :   *  @brief Copy a sequence, removing consecutive duplicate values.
                               :   *  @ingroup mutating_algorithms
                               :   *  @param  __first   An input iterator.
                               :   *  @param  __last    An input iterator.
                               :   *  @param  __result  An output iterator.
                               :   *  @return   An iterator designating the end of the resulting sequence.
                               :   *
                               :   *  Copies each element in the range @p [__first,__last) to the range
                               :   *  beginning at @p __result, except that only the first element is copied
                               :   *  from groups of consecutive elements that compare equal.
                               :   *  unique_copy() is stable, so the relative order of elements that are
                               :   *  copied is unchanged.
                               :   *
                               :   *  _GLIBCXX_RESOLVE_LIB_DEFECTS
                               :   *  DR 241. Does unique_copy() require CopyConstructible and Assignable?
                               :   *  
                               :   *  _GLIBCXX_RESOLVE_LIB_DEFECTS
                               :   *  DR 538. 241 again: Does unique_copy() require CopyConstructible and 
                               :   *  Assignable?
                               :  */
                               :  template<typename _InputIterator, typename _OutputIterator>
                               :    inline _OutputIterator
                               :    unique_copy(_InputIterator __first, _InputIterator __last,
                               :		_OutputIterator __result)
                               :    {
                               :      // concept requirements
                               :      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
                               :      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                               :	    typename iterator_traits<_InputIterator>::value_type>)
                               :      __glibcxx_function_requires(_EqualityComparableConcept<
                               :	    typename iterator_traits<_InputIterator>::value_type>)
                               :      __glibcxx_requires_valid_range(__first, __last);
                               :
                               :      if (__first == __last)
                               :	return __result;
                               :      return std::__unique_copy(__first, __last, __result,
                               :				std::__iterator_category(__first),
                               :				std::__iterator_category(__result));
                               :    }
                               :
                               :  /**
                               :   *  @brief Copy a sequence, removing consecutive values using a predicate.
                               :   *  @ingroup mutating_algorithms
                               :   *  @param  __first        An input iterator.
                               :   *  @param  __last         An input iterator.
                               :   *  @param  __result       An output iterator.
                               :   *  @param  __binary_pred  A binary predicate.
                               :   *  @return   An iterator designating the end of the resulting sequence.
                               :   *
                               :   *  Copies each element in the range @p [__first,__last) to the range
                               :   *  beginning at @p __result, except that only the first element is copied
                               :   *  from groups of consecutive elements for which @p __binary_pred returns
                               :   *  true.
                               :   *  unique_copy() is stable, so the relative order of elements that are
                               :   *  copied is unchanged.
                               :   *
                               :   *  _GLIBCXX_RESOLVE_LIB_DEFECTS
                               :   *  DR 241. Does unique_copy() require CopyConstructible and Assignable?
                               :  */
                               :  template<typename _InputIterator, typename _OutputIterator,
                               :	   typename _BinaryPredicate>
                               :    inline _OutputIterator
                               :    unique_copy(_InputIterator __first, _InputIterator __last,
                               :		_OutputIterator __result,
                               :		_BinaryPredicate __binary_pred)
                               :    {
                               :      // concept requirements -- predicates checked later
                               :      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
                               :      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                               :	    typename iterator_traits<_InputIterator>::value_type>)
                               :      __glibcxx_requires_valid_range(__first, __last);
                               :
                               :      if (__first == __last)
                               :	return __result;
                               :      return std::__unique_copy(__first, __last, __result, __binary_pred,
                               :				std::__iterator_category(__first),
                               :				std::__iterator_category(__result));
                               :    }
                               :
                               :
                               :  /**
                               :   *  @brief Randomly shuffle the elements of a sequence.
                               :   *  @ingroup mutating_algorithms
                               :   *  @param  __first   A forward iterator.
                               :   *  @param  __last    A forward iterator.
                               :   *  @return  Nothing.
                               :   *
                               :   *  Reorder the elements in the range @p [__first,__last) using a random
                               :   *  distribution, so that every possible ordering of the sequence is
                               :   *  equally likely.
                               :  */
                               :  template<typename _RandomAccessIterator>
                               :    inline void
                               :    random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last)
                               :    {
                               :      // concept requirements
                               :      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
                               :	    _RandomAccessIterator>)
                               :      __glibcxx_requires_valid_range(__first, __last);
                               :
                               :      if (__first != __last)
                               :	for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
                               :	  std::iter_swap(__i, __first + (std::rand() % ((__i - __first) + 1)));
                               :    }
                               :
                               :  /**
                               :   *  @brief Shuffle the elements of a sequence using a random number
                               :   *         generator.
                               :   *  @ingroup mutating_algorithms
                               :   *  @param  __first   A forward iterator.
                               :   *  @param  __last    A forward iterator.
                               :   *  @param  __rand    The RNG functor or function.
                               :   *  @return  Nothing.
                               :   *
                               :   *  Reorders the elements in the range @p [__first,__last) using @p __rand to
                               :   *  provide a random distribution. Calling @p __rand(N) for a positive
                               :   *  integer @p N should return a randomly chosen integer from the
                               :   *  range [0,N).
                               :  */
                               :  template<typename _RandomAccessIterator, typename _RandomNumberGenerator>
                               :    void
                               :    random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,
                               :#if __cplusplus >= 201103L
                               :		   _RandomNumberGenerator&& __rand)
                               :#else
                               :		   _RandomNumberGenerator& __rand)
                               :#endif
                               :    {
                               :      // concept requirements
                               :      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
                               :	    _RandomAccessIterator>)
                               :      __glibcxx_requires_valid_range(__first, __last);
                               :
                               :      if (__first == __last)
                               :	return;
                               :      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
                               :	std::iter_swap(__i, __first + __rand((__i - __first) + 1));
                               :    }
                               :
                               :
                               :  /**
                               :   *  @brief Move elements for which a predicate is true to the beginning
                               :   *         of a sequence.
                               :   *  @ingroup mutating_algorithms
                               :   *  @param  __first   A forward iterator.
                               :   *  @param  __last    A forward iterator.
                               :   *  @param  __pred    A predicate functor.
                               :   *  @return  An iterator @p middle such that @p __pred(i) is true for each
                               :   *  iterator @p i in the range @p [__first,middle) and false for each @p i
                               :   *  in the range @p [middle,__last).
                               :   *
                               :   *  @p __pred must not modify its operand. @p partition() does not preserve
                               :   *  the relative ordering of elements in each group, use
                               :   *  @p stable_partition() if this is needed.
                               :  */
                               :  template<typename _ForwardIterator, typename _Predicate>
                               :    inline _ForwardIterator
                               :    partition(_ForwardIterator __first, _ForwardIterator __last,
                               :	      _Predicate   __pred)
                               :    {
                               :      // concept requirements
                               :      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
                               :				  _ForwardIterator>)
                               :      __glibcxx_function_requires(_UnaryPredicateConcept<_Predicate,
                               :	    typename iterator_traits<_ForwardIterator>::value_type>)
                               :      __glibcxx_requires_valid_range(__first, __last);
                               :
                               :      return std::__partition(__first, __last, __pred,
                               :			      std::__iterator_category(__first));
                               :    }
                               :
                               :
                               :
                               :  /**
                               :   *  @brief Sort the smallest elements of a sequence.
                               :   *  @ingroup sorting_algorithms
                               :   *  @param  __first   An iterator.
                               :   *  @param  __middle  Another iterator.
                               :   *  @param  __last    Another iterator.
                               :   *  @return  Nothing.
                               :   *
                               :   *  Sorts the smallest @p (__middle-__first) elements in the range
                               :   *  @p [first,last) and moves them to the range @p [__first,__middle). The
                               :   *  order of the remaining elements in the range @p [__middle,__last) is
                               :   *  undefined.
                               :   *  After the sort if @e i and @e j are iterators in the range
                               :   *  @p [__first,__middle) such that i precedes j and @e k is an iterator in
                               :   *  the range @p [__middle,__last) then *j<*i and *k<*i are both false.
                               :  */
                               :  template<typename _RandomAccessIterator>
                               :    inline void
                               :    partial_sort(_RandomAccessIterator __first,
                               :		 _RandomAccessIterator __middle,
                               :		 _RandomAccessIterator __last)
                               :    {
                               :      typedef typename iterator_traits<_RandomAccessIterator>::value_type
                               :	_ValueType;
                               :
                               :      // concept requirements
                               :      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
                               :	    _RandomAccessIterator>)
                               :      __glibcxx_function_requires(_LessThanComparableConcept<_ValueType>)
                               :      __glibcxx_requires_valid_range(__first, __middle);
                               :      __glibcxx_requires_valid_range(__middle, __last);
                               :
                               :      std::__heap_select(__first, __middle, __last);
                               :      std::sort_heap(__first, __middle);
                               :    }
                               :
                               :  /**
                               :   *  @brief Sort the smallest elements of a sequence using a predicate
                               :   *         for comparison.
                               :   *  @ingroup sorting_algorithms
                               :   *  @param  __first   An iterator.
                               :   *  @param  __middle  Another iterator.
                               :   *  @param  __last    Another iterator.
                               :   *  @param  __comp    A comparison functor.
                               :   *  @return  Nothing.
                               :   *
                               :   *  Sorts the smallest @p (__middle-__first) elements in the range
                               :   *  @p [__first,__last) and moves them to the range @p [__first,__middle). The
                               :   *  order of the remaining elements in the range @p [__middle,__last) is
                               :   *  undefined.
                               :   *  After the sort if @e i and @e j are iterators in the range
                               :   *  @p [__first,__middle) such that i precedes j and @e k is an iterator in
                               :   *  the range @p [__middle,__last) then @p *__comp(j,*i) and @p __comp(*k,*i)
                               :   *  are both false.
                               :  */
                               :  template<typename _RandomAccessIterator, typename _Compare>
                               :    inline void
                               :    partial_sort(_RandomAccessIterator __first,
                               :		 _RandomAccessIterator __middle,
                               :		 _RandomAccessIterator __last,
                               :		 _Compare __comp)
                               :    {
                               :      typedef typename iterator_traits<_RandomAccessIterator>::value_type
                               :	_ValueType;
                               :
                               :      // concept requirements
                               :      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
                               :	    _RandomAccessIterator>)
                               :      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
                               :				  _ValueType, _ValueType>)
                               :      __glibcxx_requires_valid_range(__first, __middle);
                               :      __glibcxx_requires_valid_range(__middle, __last);
                               :
                               :      std::__heap_select(__first, __middle, __last, __comp);
                               :      std::sort_heap(__first, __middle, __comp);
                               :    }
                               :
                               :  /**
                               :   *  @brief Sort a sequence just enough to find a particular position.
                               :   *  @ingroup sorting_algorithms
                               :   *  @param  __first   An iterator.
                               :   *  @param  __nth     Another iterator.
                               :   *  @param  __last    Another iterator.
                               :   *  @return  Nothing.
                               :   *
                               :   *  Rearranges the elements in the range @p [__first,__last) so that @p *__nth
                               :   *  is the same element that would have been in that position had the
                               :   *  whole sequence been sorted. The elements either side of @p *__nth are
                               :   *  not completely sorted, but for any iterator @e i in the range
                               :   *  @p [__first,__nth) and any iterator @e j in the range @p [__nth,__last) it
                               :   *  holds that *j < *i is false.
                               :  */
                               :  template<typename _RandomAccessIterator>
                               :    inline void
                               :    nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth,
                               :		_RandomAccessIterator __last)
                               :    {
                               :      typedef typename iterator_traits<_RandomAccessIterator>::value_type
                               :	_ValueType;
                               :
                               :      // concept requirements
                               :      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
                               :				  _RandomAccessIterator>)
                               :      __glibcxx_function_requires(_LessThanComparableConcept<_ValueType>)
                               :      __glibcxx_requires_valid_range(__first, __nth);
                               :      __glibcxx_requires_valid_range(__nth, __last);
                               :
                               :      if (__first == __last || __nth == __last)
                               :	return;
                               :
                               :      std::__introselect(__first, __nth, __last,
                               :			 std::__lg(__last - __first) * 2);
                               :    }
                               :
                               :  /**
                               :   *  @brief Sort a sequence just enough to find a particular position
                               :   *         using a predicate for comparison.
                               :   *  @ingroup sorting_algorithms
                               :   *  @param  __first   An iterator.
                               :   *  @param  __nth     Another iterator.
                               :   *  @param  __last    Another iterator.
                               :   *  @param  __comp    A comparison functor.
                               :   *  @return  Nothing.
                               :   *
                               :   *  Rearranges the elements in the range @p [__first,__last) so that @p *__nth
                               :   *  is the same element that would have been in that position had the
                               :   *  whole sequence been sorted. The elements either side of @p *__nth are
                               :   *  not completely sorted, but for any iterator @e i in the range
                               :   *  @p [__first,__nth) and any iterator @e j in the range @p [__nth,__last) it
                               :   *  holds that @p __comp(*j,*i) is false.
                               :  */
                               :  template<typename _RandomAccessIterator, typename _Compare>
                               :    inline void
                               :    nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth,
                               :		_RandomAccessIterator __last, _Compare __comp)
                               :    {
                               :      typedef typename iterator_traits<_RandomAccessIterator>::value_type
                               :	_ValueType;
                               :
                               :      // concept requirements
                               :      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
                               :				  _RandomAccessIterator>)
                               :      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
                               :				  _ValueType, _ValueType>)
                               :      __glibcxx_requires_valid_range(__first, __nth);
                               :      __glibcxx_requires_valid_range(__nth, __last);
                               :
                               :      if (__first == __last || __nth == __last)
                               :	return;
                               :
                               :      std::__introselect(__first, __nth, __last,
                               :			 std::__lg(__last - __first) * 2, __comp);
                               :    }
                               :
                               :
                               :  /**
                               :   *  @brief Sort the elements of a sequence.
                               :   *  @ingroup sorting_algorithms
                               :   *  @param  __first   An iterator.
                               :   *  @param  __last    Another iterator.
                               :   *  @return  Nothing.
                               :   *
                               :   *  Sorts the elements in the range @p [__first,__last) in ascending order,
                               :   *  such that for each iterator @e i in the range @p [__first,__last-1),  
                               :   *  *(i+1)<*i is false.
                               :   *
                               :   *  The relative ordering of equivalent elements is not preserved, use
                               :   *  @p stable_sort() if this is needed.
                               :  */
                               :  template<typename _RandomAccessIterator>
                               :    inline void
                               :    sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
                               :    {
                               :      typedef typename iterator_traits<_RandomAccessIterator>::value_type
                               :	_ValueType;
                               :
                               :      // concept requirements
                               :      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
                               :	    _RandomAccessIterator>)
                               :      __glibcxx_function_requires(_LessThanComparableConcept<_ValueType>)
                               :      __glibcxx_requires_valid_range(__first, __last);
                               :
                               :      if (__first != __last)
                               :	{
                               :	  std::__introsort_loop(__first, __last,
                               :				std::__lg(__last - __first) * 2);
                               :	  std::__final_insertion_sort(__first, __last);
                               :	}
                               :    }
                               :
                               :  /**
                               :   *  @brief Sort the elements of a sequence using a predicate for comparison.
                               :   *  @ingroup sorting_algorithms
                               :   *  @param  __first   An iterator.
                               :   *  @param  __last    Another iterator.
                               :   *  @param  __comp    A comparison functor.
                               :   *  @return  Nothing.
                               :   *
                               :   *  Sorts the elements in the range @p [__first,__last) in ascending order,
                               :   *  such that @p __comp(*(i+1),*i) is false for every iterator @e i in the
                               :   *  range @p [__first,__last-1).
                               :   *
                               :   *  The relative ordering of equivalent elements is not preserved, use
                               :   *  @p stable_sort() if this is needed.
                               :  */
                               :  template<typename _RandomAccessIterator, typename _Compare>
                               :    inline void
                               :    sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
                               :	 _Compare __comp)
                               :    {
                               :      typedef typename iterator_traits<_RandomAccessIterator>::value_type
                               :	_ValueType;
                               :
                               :      // concept requirements
                               :      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
                               :	    _RandomAccessIterator>)
                               :      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare, _ValueType,
                               :				  _ValueType>)
                               :      __glibcxx_requires_valid_range(__first, __last);
                               :
                               :      if (__first != __last)
                               :	{
                               :	  std::__introsort_loop(__first, __last,
                               :				std::__lg(__last - __first) * 2, __comp);
                               :	  std::__final_insertion_sort(__first, __last, __comp);
                               :	}
                               :    }
                               :
                               :  /**
                               :   *  @brief Merges two sorted ranges.
                               :   *  @ingroup sorting_algorithms
                               :   *  @param  __first1  An iterator.
                               :   *  @param  __first2  Another iterator.
                               :   *  @param  __last1   Another iterator.
                               :   *  @param  __last2   Another iterator.
                               :   *  @param  __result  An iterator pointing to the end of the merged range.
                               :   *  @return         An iterator pointing to the first element <em>not less
                               :   *                  than</em> @e val.
                               :   *
                               :   *  Merges the ranges @p [__first1,__last1) and @p [__first2,__last2) into
                               :   *  the sorted range @p [__result, __result + (__last1-__first1) +
                               :   *  (__last2-__first2)).  Both input ranges must be sorted, and the
                               :   *  output range must not overlap with either of the input ranges.
                               :   *  The sort is @e stable, that is, for equivalent elements in the
                               :   *  two ranges, elements from the first range will always come
                               :   *  before elements from the second.
                               :  */
                               :  template<typename _InputIterator1, typename _InputIterator2,
                               :	   typename _OutputIterator>
                               :    _OutputIterator
                               :    merge(_InputIterator1 __first1, _InputIterator1 __last1,
                               :	  _InputIterator2 __first2, _InputIterator2 __last2,
                               :	  _OutputIterator __result)
                               :    {
                               :      typedef typename iterator_traits<_InputIterator1>::value_type
                               :	_ValueType1;
                               :      typedef typename iterator_traits<_InputIterator2>::value_type
                               :	_ValueType2;
                               :
                               :      // concept requirements
                               :      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
                               :      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
                               :      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                               :				  _ValueType1>)
                               :      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                               :				  _ValueType2>)
                               :      __glibcxx_function_requires(_LessThanOpConcept<_ValueType2, _ValueType1>)	
                               :      __glibcxx_requires_sorted_set(__first1, __last1, __first2);
                               :      __glibcxx_requires_sorted_set(__first2, __last2, __first1);
                               :
                               :      while (__first1 != __last1 && __first2 != __last2)
                               :	{
                               :	  if (*__first2 < *__first1)
                               :	    {
                               :	      *__result = *__first2;
                               :	      ++__first2;
                               :	    }
                               :	  else
                               :	    {
                               :	      *__result = *__first1;
                               :	      ++__first1;
                               :	    }
                               :	  ++__result;
                               :	}
                               :      return std::copy(__first2, __last2, std::copy(__first1, __last1,
                               :						    __result));
                               :    }
                               :
                               :  /**
                               :   *  @brief Merges two sorted ranges.
                               :   *  @ingroup sorting_algorithms
                               :   *  @param  __first1  An iterator.
                               :   *  @param  __first2  Another iterator.
                               :   *  @param  __last1   Another iterator.
                               :   *  @param  __last2   Another iterator.
                               :   *  @param  __result  An iterator pointing to the end of the merged range.
                               :   *  @param  __comp    A functor to use for comparisons.
                               :   *  @return         An iterator pointing to the first element "not less
                               :   *                  than" @e val.
                               :   *
                               :   *  Merges the ranges @p [__first1,__last1) and @p [__first2,__last2) into
                               :   *  the sorted range @p [__result, __result + (__last1-__first1) +
                               :   *  (__last2-__first2)).  Both input ranges must be sorted, and the
                               :   *  output range must not overlap with either of the input ranges.
                               :   *  The sort is @e stable, that is, for equivalent elements in the
                               :   *  two ranges, elements from the first range will always come
                               :   *  before elements from the second.
                               :   *
                               :   *  The comparison function should have the same effects on ordering as
                               :   *  the function used for the initial sort.
                               :  */
                               :  template<typename _InputIterator1, typename _InputIterator2,
                               :	   typename _OutputIterator, typename _Compare>
                               :    _OutputIterator
                               :    merge(_InputIterator1 __first1, _InputIterator1 __last1,
                               :	  _InputIterator2 __first2, _InputIterator2 __last2,
                               :	  _OutputIterator __result, _Compare __comp)
                               :    {
                               :      typedef typename iterator_traits<_InputIterator1>::value_type
                               :	_ValueType1;
                               :      typedef typename iterator_traits<_InputIterator2>::value_type
                               :	_ValueType2;
                               :
                               :      // concept requirements
                               :      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
                               :      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
                               :      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                               :				  _ValueType1>)
                               :      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                               :				  _ValueType2>)
                               :      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
                               :				  _ValueType2, _ValueType1>)
                               :      __glibcxx_requires_sorted_set_pred(__first1, __last1, __first2, __comp);
                               :      __glibcxx_requires_sorted_set_pred(__first2, __last2, __first1, __comp);
                               :
                               :      while (__first1 != __last1 && __first2 != __last2)
                               :	{
                               :	  if (__comp(*__first2, *__first1))
                               :	    {
                               :	      *__result = *__first2;
                               :	      ++__first2;
                               :	    }
                               :	  else
                               :	    {
                               :	      *__result = *__first1;
                               :	      ++__first1;
                               :	    }
                               :	  ++__result;
                               :	}
                               :      return std::copy(__first2, __last2, std::copy(__first1, __last1,
                               :						    __result));
                               :    }
                               :
                               :
                               :  /**
                               :   *  @brief Sort the elements of a sequence, preserving the relative order
                               :   *         of equivalent elements.
                               :   *  @ingroup sorting_algorithms
                               :   *  @param  __first   An iterator.
                               :   *  @param  __last    Another iterator.
                               :   *  @return  Nothing.
                               :   *
                               :   *  Sorts the elements in the range @p [__first,__last) in ascending order,
                               :   *  such that for each iterator @p i in the range @p [__first,__last-1),
                               :   *  @p *(i+1)<*i is false.
                               :   *
                               :   *  The relative ordering of equivalent elements is preserved, so any two
                               :   *  elements @p x and @p y in the range @p [__first,__last) such that
                               :   *  @p x<y is false and @p y<x is false will have the same relative
                               :   *  ordering after calling @p stable_sort().
                               :  */
                               :  template<typename _RandomAccessIterator>
                               :    inline void
                               :    stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
                               :    {
                               :      typedef typename iterator_traits<_RandomAccessIterator>::value_type
                               :	_ValueType;
                               :      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
                               :	_DistanceType;
                               :
                               :      // concept requirements
                               :      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
                               :	    _RandomAccessIterator>)
                               :      __glibcxx_function_requires(_LessThanComparableConcept<_ValueType>)
                               :      __glibcxx_requires_valid_range(__first, __last);
                               :
                               :      _Temporary_buffer<_RandomAccessIterator, _ValueType> __buf(__first,
                               :								 __last);
                               :      if (__buf.begin() == 0)
                               :	std::__inplace_stable_sort(__first, __last);
                               :      else
                               :	std::__stable_sort_adaptive(__first, __last, __buf.begin(),
                               :				    _DistanceType(__buf.size()));
                               :    }
                               :
                               :  /**
                               :   *  @brief Sort the elements of a sequence using a predicate for comparison,
                               :   *         preserving the relative order of equivalent elements.
                               :   *  @ingroup sorting_algorithms
                               :   *  @param  __first   An iterator.
                               :   *  @param  __last    Another iterator.
                               :   *  @param  __comp    A comparison functor.
                               :   *  @return  Nothing.
                               :   *
                               :   *  Sorts the elements in the range @p [__first,__last) in ascending order,
                               :   *  such that for each iterator @p i in the range @p [__first,__last-1),
                               :   *  @p __comp(*(i+1),*i) is false.
                               :   *
                               :   *  The relative ordering of equivalent elements is preserved, so any two
                               :   *  elements @p x and @p y in the range @p [__first,__last) such that
                               :   *  @p __comp(x,y) is false and @p __comp(y,x) is false will have the same
                               :   *  relative ordering after calling @p stable_sort().
                               :  */
                               :  template<typename _RandomAccessIterator, typename _Compare>
                               :    inline void
                               :    stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
                               :		_Compare __comp)
                               :    {
                               :      typedef typename iterator_traits<_RandomAccessIterator>::value_type
                               :	_ValueType;
                               :      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
                               :	_DistanceType;
                               :
                               :      // concept requirements
                               :      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
                               :	    _RandomAccessIterator>)
                               :      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
                               :				  _ValueType,
                               :				  _ValueType>)
                               :      __glibcxx_requires_valid_range(__first, __last);
                               :
                               :      _Temporary_buffer<_RandomAccessIterator, _ValueType> __buf(__first,
                               :								 __last);
                               :      if (__buf.begin() == 0)
     2  0.0017     0       0   :	std::__inplace_stable_sort(__first, __last, __comp);
                               :      else
     1 8.5e-04     0       0   :	std::__stable_sort_adaptive(__first, __last, __buf.begin(),
                               :				    _DistanceType(__buf.size()), __comp);
                               :    }
                               :
                               :
                               :  /**
                               :   *  @brief Return the union of two sorted ranges.
                               :   *  @ingroup set_algorithms
                               :   *  @param  __first1  Start of first range.
                               :   *  @param  __last1   End of first range.
                               :   *  @param  __first2  Start of second range.
                               :   *  @param  __last2   End of second range.
                               :   *  @return  End of the output range.
                               :   *  @ingroup set_algorithms
                               :   *
                               :   *  This operation iterates over both ranges, copying elements present in
                               :   *  each range in order to the output range.  Iterators increment for each
                               :   *  range.  When the current element of one range is less than the other,
                               :   *  that element is copied and the iterator advanced.  If an element is
                               :   *  contained in both ranges, the element from the first range is copied and
                               :   *  both ranges advance.  The output range may not overlap either input
                               :   *  range.
                               :  */
                               :  template<typename _InputIterator1, typename _InputIterator2,
                               :	   typename _OutputIterator>
                               :    _OutputIterator
                               :    set_union(_InputIterator1 __first1, _InputIterator1 __last1,
                               :	      _InputIterator2 __first2, _InputIterator2 __last2,
                               :	      _OutputIterator __result)
                               :    {
                               :      typedef typename iterator_traits<_InputIterator1>::value_type
                               :	_ValueType1;
                               :      typedef typename iterator_traits<_InputIterator2>::value_type
                               :	_ValueType2;
                               :
                               :      // concept requirements
                               :      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
                               :      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
                               :      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                               :				  _ValueType1>)
                               :      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                               :				  _ValueType2>)
                               :      __glibcxx_function_requires(_LessThanOpConcept<_ValueType1, _ValueType2>)
                               :      __glibcxx_function_requires(_LessThanOpConcept<_ValueType2, _ValueType1>)
                               :      __glibcxx_requires_sorted_set(__first1, __last1, __first2);
                               :      __glibcxx_requires_sorted_set(__first2, __last2, __first1);
                               :
                               :      while (__first1 != __last1 && __first2 != __last2)
                               :	{
                               :	  if (*__first1 < *__first2)
                               :	    {
                               :	      *__result = *__first1;
                               :	      ++__first1;
                               :	    }
                               :	  else if (*__first2 < *__first1)
                               :	    {
                               :	      *__result = *__first2;
                               :	      ++__first2;
                               :	    }
                               :	  else
                               :	    {
                               :	      *__result = *__first1;
                               :	      ++__first1;
                               :	      ++__first2;
                               :	    }
                               :	  ++__result;
                               :	}
                               :      return std::copy(__first2, __last2, std::copy(__first1, __last1,
                               :						    __result));
                               :    }
                               :
                               :  /**
                               :   *  @brief Return the union of two sorted ranges using a comparison functor.
                               :   *  @ingroup set_algorithms
                               :   *  @param  __first1  Start of first range.
                               :   *  @param  __last1   End of first range.
                               :   *  @param  __first2  Start of second range.
                               :   *  @param  __last2   End of second range.
                               :   *  @param  __comp    The comparison functor.
                               :   *  @return  End of the output range.
                               :   *  @ingroup set_algorithms
                               :   *
                               :   *  This operation iterates over both ranges, copying elements present in
                               :   *  each range in order to the output range.  Iterators increment for each
                               :   *  range.  When the current element of one range is less than the other
                               :   *  according to @p __comp, that element is copied and the iterator advanced.
                               :   *  If an equivalent element according to @p __comp is contained in both
                               :   *  ranges, the element from the first range is copied and both ranges
                               :   *  advance.  The output range may not overlap either input range.
                               :  */
                               :  template<typename _InputIterator1, typename _InputIterator2,
                               :	   typename _OutputIterator, typename _Compare>
                               :    _OutputIterator
                               :    set_union(_InputIterator1 __first1, _InputIterator1 __last1,
                               :	      _InputIterator2 __first2, _InputIterator2 __last2,
                               :	      _OutputIterator __result, _Compare __comp)
                               :    {
                               :      typedef typename iterator_traits<_InputIterator1>::value_type
                               :	_ValueType1;
                               :      typedef typename iterator_traits<_InputIterator2>::value_type
                               :	_ValueType2;
                               :
                               :      // concept requirements
                               :      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
                               :      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
                               :      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                               :				  _ValueType1>)
                               :      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                               :				  _ValueType2>)
                               :      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
                               :				  _ValueType1, _ValueType2>)
                               :      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
                               :				  _ValueType2, _ValueType1>)
                               :      __glibcxx_requires_sorted_set_pred(__first1, __last1, __first2, __comp);
                               :      __glibcxx_requires_sorted_set_pred(__first2, __last2, __first1, __comp);
                               :
                               :      while (__first1 != __last1 && __first2 != __last2)
                               :	{
                               :	  if (__comp(*__first1, *__first2))
                               :	    {
                               :	      *__result = *__first1;
                               :	      ++__first1;
                               :	    }
                               :	  else if (__comp(*__first2, *__first1))
                               :	    {
                               :	      *__result = *__first2;
                               :	      ++__first2;
                               :	    }
                               :	  else
                               :	    {
                               :	      *__result = *__first1;
                               :	      ++__first1;
                               :	      ++__first2;
                               :	    }
                               :	  ++__result;
                               :	}
                               :      return std::copy(__first2, __last2, std::copy(__first1, __last1,
                               :						    __result));
                               :    }
                               :
                               :  /**
                               :   *  @brief Return the intersection of two sorted ranges.
                               :   *  @ingroup set_algorithms
                               :   *  @param  __first1  Start of first range.
                               :   *  @param  __last1   End of first range.
                               :   *  @param  __first2  Start of second range.
                               :   *  @param  __last2   End of second range.
                               :   *  @return  End of the output range.
                               :   *  @ingroup set_algorithms
                               :   *
                               :   *  This operation iterates over both ranges, copying elements present in
                               :   *  both ranges in order to the output range.  Iterators increment for each
                               :   *  range.  When the current element of one range is less than the other,
                               :   *  that iterator advances.  If an element is contained in both ranges, the
                               :   *  element from the first range is copied and both ranges advance.  The
                               :   *  output range may not overlap either input range.
                               :  */
                               :  template<typename _InputIterator1, typename _InputIterator2,
                               :	   typename _OutputIterator>
                               :    _OutputIterator
                               :    set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
                               :		     _InputIterator2 __first2, _InputIterator2 __last2,
                               :		     _OutputIterator __result)
                               :    {
                               :      typedef typename iterator_traits<_InputIterator1>::value_type
                               :	_ValueType1;
                               :      typedef typename iterator_traits<_InputIterator2>::value_type
                               :	_ValueType2;
                               :
                               :      // concept requirements
                               :      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
                               :      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
                               :      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                               :				  _ValueType1>)
                               :      __glibcxx_function_requires(_LessThanOpConcept<_ValueType1, _ValueType2>)
                               :      __glibcxx_function_requires(_LessThanOpConcept<_ValueType2, _ValueType1>)
                               :      __glibcxx_requires_sorted_set(__first1, __last1, __first2);
                               :      __glibcxx_requires_sorted_set(__first2, __last2, __first1);
                               :
                               :      while (__first1 != __last1 && __first2 != __last2)
                               :	if (*__first1 < *__first2)
                               :	  ++__first1;
                               :	else if (*__first2 < *__first1)
                               :	  ++__first2;
                               :	else
                               :	  {
                               :	    *__result = *__first1;
                               :	    ++__first1;
                               :	    ++__first2;
                               :	    ++__result;
                               :	  }
                               :      return __result;
                               :    }
                               :
                               :  /**
                               :   *  @brief Return the intersection of two sorted ranges using comparison
                               :   *  functor.
                               :   *  @ingroup set_algorithms
                               :   *  @param  __first1  Start of first range.
                               :   *  @param  __last1   End of first range.
                               :   *  @param  __first2  Start of second range.
                               :   *  @param  __last2   End of second range.
                               :   *  @param  __comp    The comparison functor.
                               :   *  @return  End of the output range.
                               :   *  @ingroup set_algorithms
                               :   *
                               :   *  This operation iterates over both ranges, copying elements present in
                               :   *  both ranges in order to the output range.  Iterators increment for each
                               :   *  range.  When the current element of one range is less than the other
                               :   *  according to @p __comp, that iterator advances.  If an element is
                               :   *  contained in both ranges according to @p __comp, the element from the
                               :   *  first range is copied and both ranges advance.  The output range may not
                               :   *  overlap either input range.
                               :  */
                               :  template<typename _InputIterator1, typename _InputIterator2,
                               :	   typename _OutputIterator, typename _Compare>
                               :    _OutputIterator
                               :    set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
                               :		     _InputIterator2 __first2, _InputIterator2 __last2,
                               :		     _OutputIterator __result, _Compare __comp)
                               :    {
                               :      typedef typename iterator_traits<_InputIterator1>::value_type
                               :	_ValueType1;
                               :      typedef typename iterator_traits<_InputIterator2>::value_type
                               :	_ValueType2;
                               :
                               :      // concept requirements
                               :      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
                               :      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
                               :      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                               :				  _ValueType1>)
                               :      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
                               :				  _ValueType1, _ValueType2>)
                               :      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
                               :				  _ValueType2, _ValueType1>)
                               :      __glibcxx_requires_sorted_set_pred(__first1, __last1, __first2, __comp);
                               :      __glibcxx_requires_sorted_set_pred(__first2, __last2, __first1, __comp);
                               :
                               :      while (__first1 != __last1 && __first2 != __last2)
                               :	if (__comp(*__first1, *__first2))
                               :	  ++__first1;
                               :	else if (__comp(*__first2, *__first1))
                               :	  ++__first2;
                               :	else
                               :	  {
                               :	    *__result = *__first1;
                               :	    ++__first1;
                               :	    ++__first2;
                               :	    ++__result;
                               :	  }
                               :      return __result;
                               :    }
                               :
                               :  /**
                               :   *  @brief Return the difference of two sorted ranges.
                               :   *  @ingroup set_algorithms
                               :   *  @param  __first1  Start of first range.
                               :   *  @param  __last1   End of first range.
                               :   *  @param  __first2  Start of second range.
                               :   *  @param  __last2   End of second range.
                               :   *  @return  End of the output range.
                               :   *  @ingroup set_algorithms
                               :   *
                               :   *  This operation iterates over both ranges, copying elements present in
                               :   *  the first range but not the second in order to the output range.
                               :   *  Iterators increment for each range.  When the current element of the
                               :   *  first range is less than the second, that element is copied and the
                               :   *  iterator advances.  If the current element of the second range is less,
                               :   *  the iterator advances, but no element is copied.  If an element is
                               :   *  contained in both ranges, no elements are copied and both ranges
                               :   *  advance.  The output range may not overlap either input range.
                               :  */
                               :  template<typename _InputIterator1, typename _InputIterator2,
                               :	   typename _OutputIterator>
                               :    _OutputIterator
                               :    set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
                               :		   _InputIterator2 __first2, _InputIterator2 __last2,
                               :		   _OutputIterator __result)
                               :    {
                               :      typedef typename iterator_traits<_InputIterator1>::value_type
                               :	_ValueType1;
                               :      typedef typename iterator_traits<_InputIterator2>::value_type
                               :	_ValueType2;
                               :
                               :      // concept requirements
                               :      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
                               :      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
                               :      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                               :				  _ValueType1>)
                               :      __glibcxx_function_requires(_LessThanOpConcept<_ValueType1, _ValueType2>)
                               :      __glibcxx_function_requires(_LessThanOpConcept<_ValueType2, _ValueType1>)	
                               :      __glibcxx_requires_sorted_set(__first1, __last1, __first2);
                               :      __glibcxx_requires_sorted_set(__first2, __last2, __first1);
                               :
                               :      while (__first1 != __last1 && __first2 != __last2)
                               :	if (*__first1 < *__first2)
                               :	  {
                               :	    *__result = *__first1;
                               :	    ++__first1;
                               :	    ++__result;
                               :	  }
                               :	else if (*__first2 < *__first1)
                               :	  ++__first2;
                               :	else
                               :	  {
                               :	    ++__first1;
                               :	    ++__first2;
                               :	  }
                               :      return std::copy(__first1, __last1, __result);
                               :    }
                               :
                               :  /**
                               :   *  @brief  Return the difference of two sorted ranges using comparison
                               :   *  functor.
                               :   *  @ingroup set_algorithms
                               :   *  @param  __first1  Start of first range.
                               :   *  @param  __last1   End of first range.
                               :   *  @param  __first2  Start of second range.
                               :   *  @param  __last2   End of second range.
                               :   *  @param  __comp    The comparison functor.
                               :   *  @return  End of the output range.
                               :   *  @ingroup set_algorithms
                               :   *
                               :   *  This operation iterates over both ranges, copying elements present in
                               :   *  the first range but not the second in order to the output range.
                               :   *  Iterators increment for each range.  When the current element of the
                               :   *  first range is less than the second according to @p __comp, that element
                               :   *  is copied and the iterator advances.  If the current element of the
                               :   *  second range is less, no element is copied and the iterator advances.
                               :   *  If an element is contained in both ranges according to @p __comp, no
                               :   *  elements are copied and both ranges advance.  The output range may not
                               :   *  overlap either input range.
                               :  */
                               :  template<typename _InputIterator1, typename _InputIterator2,
                               :	   typename _OutputIterator, typename _Compare>
                               :    _OutputIterator
                               :    set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
                               :		   _InputIterator2 __first2, _InputIterator2 __last2,
                               :		   _OutputIterator __result, _Compare __comp)
                               :    {
                               :      typedef typename iterator_traits<_InputIterator1>::value_type
                               :	_ValueType1;
                               :      typedef typename iterator_traits<_InputIterator2>::value_type
                               :	_ValueType2;
                               :
                               :      // concept requirements
                               :      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
                               :      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
                               :      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                               :				  _ValueType1>)
                               :      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
                               :				  _ValueType1, _ValueType2>)
                               :      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
                               :				  _ValueType2, _ValueType1>)
                               :      __glibcxx_requires_sorted_set_pred(__first1, __last1, __first2, __comp);
                               :      __glibcxx_requires_sorted_set_pred(__first2, __last2, __first1, __comp);
                               :
                               :      while (__first1 != __last1 && __first2 != __last2)
                               :	if (__comp(*__first1, *__first2))
                               :	  {
                               :	    *__result = *__first1;
                               :	    ++__first1;
                               :	    ++__result;
                               :	  }
                               :	else if (__comp(*__first2, *__first1))
                               :	  ++__first2;
                               :	else
                               :	  {
                               :	    ++__first1;
                               :	    ++__first2;
                               :	  }
                               :      return std::copy(__first1, __last1, __result);
                               :    }
                               :
                               :  /**
                               :   *  @brief  Return the symmetric difference of two sorted ranges.
                               :   *  @ingroup set_algorithms
                               :   *  @param  __first1  Start of first range.
                               :   *  @param  __last1   End of first range.
                               :   *  @param  __first2  Start of second range.
                               :   *  @param  __last2   End of second range.
                               :   *  @return  End of the output range.
                               :   *  @ingroup set_algorithms
                               :   *
                               :   *  This operation iterates over both ranges, copying elements present in
                               :   *  one range but not the other in order to the output range.  Iterators
                               :   *  increment for each range.  When the current element of one range is less
                               :   *  than the other, that element is copied and the iterator advances.  If an
                               :   *  element is contained in both ranges, no elements are copied and both
                               :   *  ranges advance.  The output range may not overlap either input range.
                               :  */
                               :  template<typename _InputIterator1, typename _InputIterator2,
                               :	   typename _OutputIterator>
                               :    _OutputIterator
                               :    set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
                               :			     _InputIterator2 __first2, _InputIterator2 __last2,
                               :			     _OutputIterator __result)
                               :    {
                               :      typedef typename iterator_traits<_InputIterator1>::value_type
                               :	_ValueType1;
                               :      typedef typename iterator_traits<_InputIterator2>::value_type
                               :	_ValueType2;
                               :
                               :      // concept requirements
                               :      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
                               :      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
                               :      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                               :				  _ValueType1>)
                               :      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                               :				  _ValueType2>)
                               :      __glibcxx_function_requires(_LessThanOpConcept<_ValueType1, _ValueType2>)
                               :      __glibcxx_function_requires(_LessThanOpConcept<_ValueType2, _ValueType1>)	
                               :      __glibcxx_requires_sorted_set(__first1, __last1, __first2);
                               :      __glibcxx_requires_sorted_set(__first2, __last2, __first1);
                               :
                               :      while (__first1 != __last1 && __first2 != __last2)
                               :	if (*__first1 < *__first2)
                               :	  {
                               :	    *__result = *__first1;
                               :	    ++__first1;
                               :	    ++__result;
                               :	  }
                               :	else if (*__first2 < *__first1)
                               :	  {
                               :	    *__result = *__first2;
                               :	    ++__first2;
                               :	    ++__result;
                               :	  }
                               :	else
                               :	  {
                               :	    ++__first1;
                               :	    ++__first2;
                               :	  }
                               :      return std::copy(__first2, __last2, std::copy(__first1,
                               :						    __last1, __result));
                               :    }
                               :
                               :  /**
                               :   *  @brief  Return the symmetric difference of two sorted ranges using
                               :   *  comparison functor.
                               :   *  @ingroup set_algorithms
                               :   *  @param  __first1  Start of first range.
                               :   *  @param  __last1   End of first range.
                               :   *  @param  __first2  Start of second range.
                               :   *  @param  __last2   End of second range.
                               :   *  @param  __comp    The comparison functor.
                               :   *  @return  End of the output range.
                               :   *  @ingroup set_algorithms
                               :   *
                               :   *  This operation iterates over both ranges, copying elements present in
                               :   *  one range but not the other in order to the output range.  Iterators
                               :   *  increment for each range.  When the current element of one range is less
                               :   *  than the other according to @p comp, that element is copied and the
                               :   *  iterator advances.  If an element is contained in both ranges according
                               :   *  to @p __comp, no elements are copied and both ranges advance.  The output
                               :   *  range may not overlap either input range.
                               :  */
                               :  template<typename _InputIterator1, typename _InputIterator2,
                               :	   typename _OutputIterator, typename _Compare>
                               :    _OutputIterator
                               :    set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
                               :			     _InputIterator2 __first2, _InputIterator2 __last2,
                               :			     _OutputIterator __result,
                               :			     _Compare __comp)
                               :    {
                               :      typedef typename iterator_traits<_InputIterator1>::value_type
                               :	_ValueType1;
                               :      typedef typename iterator_traits<_InputIterator2>::value_type
                               :	_ValueType2;
                               :
                               :      // concept requirements
                               :      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
                               :      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
                               :      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                               :				  _ValueType1>)
                               :      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                               :				  _ValueType2>)
                               :      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
                               :				  _ValueType1, _ValueType2>)
                               :      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
                               :				  _ValueType2, _ValueType1>)
                               :      __glibcxx_requires_sorted_set_pred(__first1, __last1, __first2, __comp);
                               :      __glibcxx_requires_sorted_set_pred(__first2, __last2, __first1, __comp);
                               :
                               :      while (__first1 != __last1 && __first2 != __last2)
                               :	if (__comp(*__first1, *__first2))
                               :	  {
                               :	    *__result = *__first1;
                               :	    ++__first1;
                               :	    ++__result;
                               :	  }
                               :	else if (__comp(*__first2, *__first1))
                               :	  {
                               :	    *__result = *__first2;
                               :	    ++__first2;
                               :	    ++__result;
                               :	  }
                               :	else
                               :	  {
                               :	    ++__first1;
                               :	    ++__first2;
                               :	  }
                               :      return std::copy(__first2, __last2, 
                               :		       std::copy(__first1, __last1, __result));
                               :    }
                               :
                               :
                               :  /**
                               :   *  @brief  Return the minimum element in a range.
                               :   *  @ingroup sorting_algorithms
                               :   *  @param  __first  Start of range.
                               :   *  @param  __last   End of range.
                               :   *  @return  Iterator referencing the first instance of the smallest value.
                               :  */
                               :  template<typename _ForwardIterator>
                               :    _ForwardIterator
                               :    min_element(_ForwardIterator __first, _ForwardIterator __last)
                               :    {
                               :      // concept requirements
                               :      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                               :      __glibcxx_function_requires(_LessThanComparableConcept<
                               :	    typename iterator_traits<_ForwardIterator>::value_type>)
                               :      __glibcxx_requires_valid_range(__first, __last);
                               :
                               :      if (__first == __last)
                               :	return __first;
                               :      _ForwardIterator __result = __first;
                               :      while (++__first != __last)
                               :	if (*__first < *__result)
                               :	  __result = __first;
                               :      return __result;
                               :    }
                               :
                               :  /**
                               :   *  @brief  Return the minimum element in a range using comparison functor.
                               :   *  @ingroup sorting_algorithms
                               :   *  @param  __first  Start of range.
                               :   *  @param  __last   End of range.
                               :   *  @param  __comp   Comparison functor.
                               :   *  @return  Iterator referencing the first instance of the smallest value
                               :   *  according to __comp.
                               :  */
                               :  template<typename _ForwardIterator, typename _Compare>
                               :    _ForwardIterator
                               :    min_element(_ForwardIterator __first, _ForwardIterator __last,
                               :		_Compare __comp)
                               :    {
                               :      // concept requirements
                               :      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                               :      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
                               :	    typename iterator_traits<_ForwardIterator>::value_type,
                               :	    typename iterator_traits<_ForwardIterator>::value_type>)
                               :      __glibcxx_requires_valid_range(__first, __last);
                               :
                               :      if (__first == __last)
                               :	return __first;
                               :      _ForwardIterator __result = __first;
                               :      while (++__first != __last)
                               :	if (__comp(*__first, *__result))
                               :	  __result = __first;
                               :      return __result;
                               :    }
                               :
                               :  /**
                               :   *  @brief  Return the maximum element in a range.
                               :   *  @ingroup sorting_algorithms
                               :   *  @param  __first  Start of range.
                               :   *  @param  __last   End of range.
                               :   *  @return  Iterator referencing the first instance of the largest value.
                               :  */
                               :  template<typename _ForwardIterator>
                               :    _ForwardIterator
                               :    max_element(_ForwardIterator __first, _ForwardIterator __last)
                               :    {
                               :      // concept requirements
                               :      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                               :      __glibcxx_function_requires(_LessThanComparableConcept<
                               :	    typename iterator_traits<_ForwardIterator>::value_type>)
                               :      __glibcxx_requires_valid_range(__first, __last);
                               :
                               :      if (__first == __last)
                               :	return __first;
                               :      _ForwardIterator __result = __first;
                               :      while (++__first != __last)
                               :	if (*__result < *__first)
                               :	  __result = __first;
                               :      return __result;
                               :    }
                               :
                               :  /**
                               :   *  @brief  Return the maximum element in a range using comparison functor.
                               :   *  @ingroup sorting_algorithms
                               :   *  @param  __first  Start of range.
                               :   *  @param  __last   End of range.
                               :   *  @param  __comp   Comparison functor.
                               :   *  @return  Iterator referencing the first instance of the largest value
                               :   *  according to __comp.
                               :  */
                               :  template<typename _ForwardIterator, typename _Compare>
                               :    _ForwardIterator
                               :    max_element(_ForwardIterator __first, _ForwardIterator __last,
                               :		_Compare __comp)
                               :    {
                               :      // concept requirements
                               :      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                               :      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
                               :	    typename iterator_traits<_ForwardIterator>::value_type,
                               :	    typename iterator_traits<_ForwardIterator>::value_type>)
                               :      __glibcxx_requires_valid_range(__first, __last);
                               :
                               :      if (__first == __last) return __first;
                               :      _ForwardIterator __result = __first;
                               :      while (++__first != __last)
                               :	if (__comp(*__result, *__first))
                               :	  __result = __first;
                               :      return __result;
                               :    }
                               :
                               :_GLIBCXX_END_NAMESPACE_ALGO
                               :} // namespace std
                               :
                               :#endif /* _STL_ALGO_H */
/* 
 * Total samples for file : "/usr/include/c++/4.8/bits/vector.tcc"
 * 
 *    443  0.3769     2  0.1181
 */


                               :// Vector implementation (out of line) -*- C++ -*-
                               :
                               :// Copyright (C) 2001-2013 Free Software Foundation, Inc.
                               ://
                               :// This file is part of the GNU ISO C++ Library.  This library is free
                               :// software; you can redistribute it and/or modify it under the
                               :// terms of the GNU General Public License as published by the
                               :// Free Software Foundation; either version 3, or (at your option)
                               :// any later version.
                               :
                               :// This library is distributed in the hope that it will be useful,
                               :// but WITHOUT ANY WARRANTY; without even the implied warranty of
                               :// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                               :// GNU General Public License for more details.
                               :
                               :// Under Section 7 of GPL version 3, you are granted additional
                               :// permissions described in the GCC Runtime Library Exception, version
                               :// 3.1, as published by the Free Software Foundation.
                               :
                               :// You should have received a copy of the GNU General Public License and
                               :// a copy of the GCC Runtime Library Exception along with this program;
                               :// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                               :// <http://www.gnu.org/licenses/>.
                               :
                               :/*
                               : *
                               : * Copyright (c) 1994
                               : * Hewlett-Packard Company
                               : *
                               : * Permission to use, copy, modify, distribute and sell this software
                               : * and its documentation for any purpose is hereby granted without fee,
                               : * provided that the above copyright notice appear in all copies and
                               : * that both that copyright notice and this permission notice appear
                               : * in supporting documentation.  Hewlett-Packard Company makes no
                               : * representations about the suitability of this software for any
                               : * purpose.  It is provided "as is" without express or implied warranty.
                               : *
                               : *
                               : * Copyright (c) 1996
                               : * Silicon Graphics Computer Systems, Inc.
                               : *
                               : * Permission to use, copy, modify, distribute and sell this software
                               : * and its documentation for any purpose is hereby granted without fee,
                               : * provided that the above copyright notice appear in all copies and
                               : * that both that copyright notice and this permission notice appear
                               : * in supporting documentation.  Silicon Graphics makes no
                               : * representations about the suitability of this  software for any
                               : * purpose.  It is provided "as is" without express or implied warranty.
                               : */
                               :
                               :/** @file bits/vector.tcc
                               : *  This is an internal header file, included by other library headers.
                               : *  Do not attempt to use it directly. @headername{vector}
                               : */
                               :
                               :#ifndef _VECTOR_TCC
                               :#define _VECTOR_TCC 1
                               :
                               :namespace std _GLIBCXX_VISIBILITY(default)
                               :{
                               :_GLIBCXX_BEGIN_NAMESPACE_CONTAINER
                               :
                               :  template<typename _Tp, typename _Alloc>
                               :    void
                               :    vector<_Tp, _Alloc>::
                               :    reserve(size_type __n)
                               :    {
                               :      if (__n > this->max_size())
                               :	__throw_length_error(__N("vector::reserve"));
                               :      if (this->capacity() < __n)
                               :	{
                               :	  const size_type __old_size = size();
                               :	  pointer __tmp = _M_allocate_and_copy(__n,
                               :	    _GLIBCXX_MAKE_MOVE_IF_NOEXCEPT_ITERATOR(this->_M_impl._M_start),
                               :	    _GLIBCXX_MAKE_MOVE_IF_NOEXCEPT_ITERATOR(this->_M_impl._M_finish));
                               :	  std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
                               :			_M_get_Tp_allocator());
                               :	  _M_deallocate(this->_M_impl._M_start,
                               :			this->_M_impl._M_end_of_storage
                               :			- this->_M_impl._M_start);
                               :	  this->_M_impl._M_start = __tmp;
                               :	  this->_M_impl._M_finish = __tmp + __old_size;
                               :	  this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
                               :	}
                               :    }
                               :
                               :#if __cplusplus >= 201103L
                               :  template<typename _Tp, typename _Alloc>
                               :    template<typename... _Args>
                               :      void
                               :      vector<_Tp, _Alloc>::
                               :      emplace_back(_Args&&... __args)
                               :      {
    41  0.0349     0       0   :	if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
                               :	  {
                               :	    _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
                               :				     std::forward<_Args>(__args)...);
    42  0.0357     0       0   :	    ++this->_M_impl._M_finish;
                               :	  }
                               :	else
     1 8.5e-04     0       0   :	  _M_emplace_back_aux(std::forward<_Args>(__args)...);
                               :      }
                               :#endif
                               :
                               :  template<typename _Tp, typename _Alloc>
                               :    typename vector<_Tp, _Alloc>::iterator
                               :    vector<_Tp, _Alloc>:: /* std::vector<int, std::allocator<int> >::insert(__gnu_cxx::__normal_iterator<int*, std::vector<int, std::allocator<int> > >, int const&) total:     13  0.0111     0       0 */
                               :    insert(iterator __position, const value_type& __x)
                               :    {
                               :      const size_type __n = __position - begin();
                               :      if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage
                               :	  && __position == end())
                               :	{
                               :	  _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, __x);
                               :	  ++this->_M_impl._M_finish;
                               :	}
                               :      else
                               :	{
                               :#if __cplusplus >= 201103L
                               :	  if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
                               :	    {
     2  0.0017     0       0   :	      _Tp __x_copy = __x;
                               :	      _M_insert_aux(__position, std::move(__x_copy));
                               :	    }
                               :	  else
                               :#endif
     1 8.5e-04     0       0   :	    _M_insert_aux(__position, __x);
                               :	}
                               :      return iterator(this->_M_impl._M_start + __n);
                               :    }
                               :
                               :  template<typename _Tp, typename _Alloc>
                               :    typename vector<_Tp, _Alloc>::iterator
                               :    vector<_Tp, _Alloc>::
                               :    erase(iterator __position)
                               :    {
                               :      if (__position + 1 != end())
                               :	_GLIBCXX_MOVE3(__position + 1, end(), __position);
                               :      --this->_M_impl._M_finish;
                               :      _Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
                               :      return __position;
                               :    }
                               :
                               :  template<typename _Tp, typename _Alloc>
                               :    typename vector<_Tp, _Alloc>::iterator
                               :    vector<_Tp, _Alloc>::
                               :    erase(iterator __first, iterator __last)
                               :    {
                               :      if (__first != __last)
                               :	{
                               :	  if (__last != end())
                               :	    _GLIBCXX_MOVE3(__last, end(), __first);
                               :	  _M_erase_at_end(__first.base() + (end() - __last));
                               :	}
                               :      return __first;
                               :    }
                               :
                               :  template<typename _Tp, typename _Alloc>
                               :    vector<_Tp, _Alloc>&
                               :    vector<_Tp, _Alloc>::
                               :    operator=(const vector<_Tp, _Alloc>& __x)
                               :    {
                               :      if (&__x != this)
                               :	{
                               :#if __cplusplus >= 201103L
                               :	  if (_Alloc_traits::_S_propagate_on_copy_assign())
                               :	    {
                               :	      if (!_Alloc_traits::_S_always_equal()
                               :	          && _M_get_Tp_allocator() != __x._M_get_Tp_allocator())
                               :	        {
                               :		  // replacement allocator cannot free existing storage
                               :		  this->clear();
                               :		  _M_deallocate(this->_M_impl._M_start,
                               :				this->_M_impl._M_end_of_storage
                               :				- this->_M_impl._M_start);
                               :		  this->_M_impl._M_start = nullptr;
                               :		  this->_M_impl._M_finish = nullptr;
                               :		  this->_M_impl._M_end_of_storage = nullptr;
                               :		}
                               :	      std::__alloc_on_copy(_M_get_Tp_allocator(),
                               :				   __x._M_get_Tp_allocator());
                               :	    }
                               :#endif
                               :	  const size_type __xlen = __x.size();
                               :	  if (__xlen > capacity())
                               :	    {
                               :	      pointer __tmp = _M_allocate_and_copy(__xlen, __x.begin(),
                               :						   __x.end());
                               :	      std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
                               :			    _M_get_Tp_allocator());
                               :	      _M_deallocate(this->_M_impl._M_start,
                               :			    this->_M_impl._M_end_of_storage
                               :			    - this->_M_impl._M_start);
                               :	      this->_M_impl._M_start = __tmp;
                               :	      this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __xlen;
                               :	    }
                               :	  else if (size() >= __xlen)
                               :	    {
                               :	      std::_Destroy(std::copy(__x.begin(), __x.end(), begin()),
                               :			    end(), _M_get_Tp_allocator());
                               :	    }
                               :	  else
                               :	    {
                               :	      std::copy(__x._M_impl._M_start, __x._M_impl._M_start + size(),
                               :			this->_M_impl._M_start);
                               :	      std::__uninitialized_copy_a(__x._M_impl._M_start + size(),
                               :					  __x._M_impl._M_finish,
                               :					  this->_M_impl._M_finish,
                               :					  _M_get_Tp_allocator());
                               :	    }
                               :	  this->_M_impl._M_finish = this->_M_impl._M_start + __xlen;
                               :	}
                               :      return *this;
                               :    }
                               :
                               :  template<typename _Tp, typename _Alloc>
                               :    void
                               :    vector<_Tp, _Alloc>::
                               :    _M_fill_assign(size_t __n, const value_type& __val)
                               :    {
                               :      if (__n > capacity())
                               :	{
                               :	  vector __tmp(__n, __val, _M_get_Tp_allocator());
                               :	  __tmp.swap(*this);
                               :	}
                               :      else if (__n > size())
                               :	{
                               :	  std::fill(begin(), end(), __val);
                               :	  std::__uninitialized_fill_n_a(this->_M_impl._M_finish,
                               :					__n - size(), __val,
                               :					_M_get_Tp_allocator());
                               :	  this->_M_impl._M_finish += __n - size();
                               :	}
                               :      else
                               :        _M_erase_at_end(std::fill_n(this->_M_impl._M_start, __n, __val));
                               :    }
                               :
                               :  template<typename _Tp, typename _Alloc>
                               :    template<typename _InputIterator>
                               :      void
                               :      vector<_Tp, _Alloc>::
                               :      _M_assign_aux(_InputIterator __first, _InputIterator __last,
                               :		    std::input_iterator_tag)
                               :      {
                               :	pointer __cur(this->_M_impl._M_start);
                               :	for (; __first != __last && __cur != this->_M_impl._M_finish;
                               :	     ++__cur, ++__first)
                               :	  *__cur = *__first;
                               :	if (__first == __last)
                               :	  _M_erase_at_end(__cur);
                               :	else
                               :	  insert(end(), __first, __last);
                               :      }
                               :
                               :  template<typename _Tp, typename _Alloc>
                               :    template<typename _ForwardIterator>
                               :      void
                               :      vector<_Tp, _Alloc>::
                               :      _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
                               :		    std::forward_iterator_tag)
                               :      {
                               :	const size_type __len = std::distance(__first, __last);
                               :
                               :	if (__len > capacity())
                               :	  {
                               :	    pointer __tmp(_M_allocate_and_copy(__len, __first, __last));
                               :	    std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
                               :			  _M_get_Tp_allocator());
                               :	    _M_deallocate(this->_M_impl._M_start,
                               :			  this->_M_impl._M_end_of_storage
                               :			  - this->_M_impl._M_start);
                               :	    this->_M_impl._M_start = __tmp;
                               :	    this->_M_impl._M_finish = this->_M_impl._M_start + __len;
                               :	    this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
                               :	  }
                               :	else if (size() >= __len)
                               :	  _M_erase_at_end(std::copy(__first, __last, this->_M_impl._M_start));
                               :	else
                               :	  {
                               :	    _ForwardIterator __mid = __first;
                               :	    std::advance(__mid, size());
                               :	    std::copy(__first, __mid, this->_M_impl._M_start);
                               :	    this->_M_impl._M_finish =
                               :	      std::__uninitialized_copy_a(__mid, __last,
                               :					  this->_M_impl._M_finish,
                               :					  _M_get_Tp_allocator());
                               :	  }
                               :      }
                               :
                               :#if __cplusplus >= 201103L
                               :  template<typename _Tp, typename _Alloc>
                               :    template<typename... _Args>
                               :      typename vector<_Tp, _Alloc>::iterator
                               :      vector<_Tp, _Alloc>::
                               :      emplace(iterator __position, _Args&&... __args)
                               :      {
                               :	const size_type __n = __position - begin();
                               :	if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage
                               :	    && __position == end())
                               :	  {
                               :	    _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
                               :				     std::forward<_Args>(__args)...);
                               :	    ++this->_M_impl._M_finish;
                               :	  }
                               :	else
                               :	  _M_insert_aux(__position, std::forward<_Args>(__args)...);
                               :	return iterator(this->_M_impl._M_start + __n);
                               :      }
                               :
                               :  template<typename _Tp, typename _Alloc>
                               :    template<typename... _Args>
                               :      void
     1 8.5e-04     0       0   :      vector<_Tp, _Alloc>:: /* void std::vector<int, std::allocator<int> >::_M_insert_aux<int const&>(__gnu_cxx::__normal_iterator<int*, std::vector<int, std::allocator<int> > >, int const&) total:      5  0.0043     0       0 */
                               :      _M_insert_aux(iterator __position, _Args&&... __args)
                               :#else
                               :  template<typename _Tp, typename _Alloc>
                               :    void
                               :    vector<_Tp, _Alloc>::
                               :    _M_insert_aux(iterator __position, const _Tp& __x)
                               :#endif
                               :    {
                               :      if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
                               :	{
                               :	  _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
                               :			           _GLIBCXX_MOVE(*(this->_M_impl._M_finish
                               :				                   - 1)));
                               :	  ++this->_M_impl._M_finish;
                               :#if __cplusplus < 201103L
                               :	  _Tp __x_copy = __x;
                               :#endif
                               :	  _GLIBCXX_MOVE_BACKWARD3(__position.base(),
                               :				  this->_M_impl._M_finish - 2,
                               :				  this->_M_impl._M_finish - 1);
                               :#if __cplusplus < 201103L
                               :	  *__position = __x_copy;
                               :#else
                               :	  *__position = _Tp(std::forward<_Args>(__args)...);
                               :#endif
                               :	}
                               :      else
                               :	{
                               :	  const size_type __len =
                               :	    _M_check_len(size_type(1), "vector::_M_insert_aux");
                               :	  const size_type __elems_before = __position - begin();
                               :	  pointer __new_start(this->_M_allocate(__len));
                               :	  pointer __new_finish(__new_start);
                               :	  __try
                               :	    {
                               :	      // The order of the three operations is dictated by the C++0x
                               :	      // case, where the moves could alter a new element belonging
                               :	      // to the existing vector.  This is an issue only for callers
                               :	      // taking the element by const lvalue ref (see 23.1/13).
                               :	      _Alloc_traits::construct(this->_M_impl,
                               :		                       __new_start + __elems_before,
                               :#if __cplusplus >= 201103L
                               :				       std::forward<_Args>(__args)...);
                               :#else
                               :	                               __x);
                               :#endif
                               :	      __new_finish = 0;
                               :
                               :	      __new_finish
                               :		= std::__uninitialized_move_if_noexcept_a
                               :		(this->_M_impl._M_start, __position.base(),
                               :		 __new_start, _M_get_Tp_allocator());
                               :
                               :	      ++__new_finish;
                               :
                               :	      __new_finish
                               :		= std::__uninitialized_move_if_noexcept_a
                               :		(__position.base(), this->_M_impl._M_finish,
                               :		 __new_finish, _M_get_Tp_allocator());
                               :	    }
                               :          __catch(...)
                               :	    {
                               :	      if (!__new_finish)
                               :		_Alloc_traits::destroy(this->_M_impl,
                               :		                       __new_start + __elems_before);
                               :	      else
                               :		std::_Destroy(__new_start, __new_finish, _M_get_Tp_allocator());
                               :	      _M_deallocate(__new_start, __len);
                               :	      __throw_exception_again;
                               :	    }
                               :	  std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
                               :			_M_get_Tp_allocator());
                               :	  _M_deallocate(this->_M_impl._M_start,
                               :			this->_M_impl._M_end_of_storage
                               :			- this->_M_impl._M_start);
                               :	  this->_M_impl._M_start = __new_start;
                               :	  this->_M_impl._M_finish = __new_finish;
     1 8.5e-04     0       0   :	  this->_M_impl._M_end_of_storage = __new_start + __len;
                               :	}
                               :    }
                               :
                               :#if __cplusplus >= 201103L
                               :  template<typename _Tp, typename _Alloc>
                               :    template<typename... _Args>
                               :      void
    10  0.0085     1  0.0591   :      vector<_Tp, _Alloc>:: /* void std::vector<std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>, std::allocator<std::pair<int, int> > >, pair_cmp>, std::allocator<std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>, std::allocator<std::pair<int, int> > >, pair_cmp> > >::_M_emplace_back_aux<std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>, std::allocator<std::pair<int, int> > >, pair_cmp> const&>(std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>, std::allocator<std::pair<int, int> > >, pair_cmp> const&)     32  0.0272     0       0, void std::vector<Path*, std::allocator<Path*> >::_M_emplace_back_aux<Path* const&>(Path* const&)    113  0.0961     0       0, void std::vector<bitset, std::allocator<bitset> >::_M_emplace_back_aux<bitset const&>(bitset const&)   1530  1.3017    52  3.0715, void std::vector<std::pair<int, int>, std::allocator<std::pair<int, int> > >::_M_emplace_back_aux<std::pair<int, int> const&>(std::pair<int, int> const&)     34  0.0289     0       0, void std::vector<std::pair<int, int>, std::allocator<std::pair<int, int> > >::_M_emplace_back_aux<std::pair<int, int> >(std::pair<int, int>&&)    174  0.1480     0       0, total:   1883  1.6020    52  3.0715 */
                               :      _M_emplace_back_aux(_Args&&... __args)
                               :      {
                               :	const size_type __len =
                               :	  _M_check_len(size_type(1), "vector::_M_emplace_back_aux");
                               :	pointer __new_start(this->_M_allocate(__len));
                               :	pointer __new_finish(__new_start);
                               :	__try
                               :	  {
                               :	    _Alloc_traits::construct(this->_M_impl, __new_start + size(),
                               :				     std::forward<_Args>(__args)...);
                               :	    __new_finish = 0;
                               :
                               :	    __new_finish
                               :	      = std::__uninitialized_move_if_noexcept_a
                               :	      (this->_M_impl._M_start, this->_M_impl._M_finish,
                               :	       __new_start, _M_get_Tp_allocator());
                               :
     7  0.0060     0       0   :	    ++__new_finish;
                               :	  }
                               :	__catch(...)
                               :	  {
                               :	    if (!__new_finish)
                               :	      _Alloc_traits::destroy(this->_M_impl, __new_start + size());
                               :	    else
                               :	      std::_Destroy(__new_start, __new_finish, _M_get_Tp_allocator());
                               :	    _M_deallocate(__new_start, __len);
                               :	    __throw_exception_again;
                               :	  }
                               :	std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
                               :		      _M_get_Tp_allocator());
                               :	_M_deallocate(this->_M_impl._M_start,
                               :		      this->_M_impl._M_end_of_storage
                               :		      - this->_M_impl._M_start);
    21  0.0179     0       0   :	this->_M_impl._M_start = __new_start;
     6  0.0051     0       0   :	this->_M_impl._M_finish = __new_finish;
    39  0.0332     0       0   :	this->_M_impl._M_end_of_storage = __new_start + __len;
     8  0.0068     0       0   :      }
                               :#endif
                               :
                               :  template<typename _Tp, typename _Alloc>
                               :    void
                               :    vector<_Tp, _Alloc>::
                               :    _M_fill_insert(iterator __position, size_type __n, const value_type& __x)
                               :    {
                               :      if (__n != 0)
                               :	{
                               :	  if (size_type(this->_M_impl._M_end_of_storage
                               :			- this->_M_impl._M_finish) >= __n)
                               :	    {
                               :	      value_type __x_copy = __x;
                               :	      const size_type __elems_after = end() - __position;
                               :	      pointer __old_finish(this->_M_impl._M_finish);
                               :	      if (__elems_after > __n)
                               :		{
                               :		  std::__uninitialized_move_a(this->_M_impl._M_finish - __n,
                               :					      this->_M_impl._M_finish,
                               :					      this->_M_impl._M_finish,
                               :					      _M_get_Tp_allocator());
                               :		  this->_M_impl._M_finish += __n;
                               :		  _GLIBCXX_MOVE_BACKWARD3(__position.base(),
                               :					  __old_finish - __n, __old_finish);
                               :		  std::fill(__position.base(), __position.base() + __n,
                               :			    __x_copy);
                               :		}
                               :	      else
                               :		{
                               :		  std::__uninitialized_fill_n_a(this->_M_impl._M_finish,
                               :						__n - __elems_after,
                               :						__x_copy,
                               :						_M_get_Tp_allocator());
                               :		  this->_M_impl._M_finish += __n - __elems_after;
                               :		  std::__uninitialized_move_a(__position.base(), __old_finish,
                               :					      this->_M_impl._M_finish,
                               :					      _M_get_Tp_allocator());
                               :		  this->_M_impl._M_finish += __elems_after;
                               :		  std::fill(__position.base(), __old_finish, __x_copy);
                               :		}
                               :	    }
                               :	  else
                               :	    {
                               :	      const size_type __len =
                               :		_M_check_len(__n, "vector::_M_fill_insert");
                               :	      const size_type __elems_before = __position - begin();
                               :	      pointer __new_start(this->_M_allocate(__len));
                               :	      pointer __new_finish(__new_start);
                               :	      __try
                               :		{
                               :		  // See _M_insert_aux above.
                               :		  std::__uninitialized_fill_n_a(__new_start + __elems_before,
                               :						__n, __x,
                               :						_M_get_Tp_allocator());
                               :		  __new_finish = 0;
                               :
                               :		  __new_finish
                               :		    = std::__uninitialized_move_if_noexcept_a
                               :		    (this->_M_impl._M_start, __position.base(),
                               :		     __new_start, _M_get_Tp_allocator());
                               :
                               :		  __new_finish += __n;
                               :
                               :		  __new_finish
                               :		    = std::__uninitialized_move_if_noexcept_a
                               :		    (__position.base(), this->_M_impl._M_finish,
                               :		     __new_finish, _M_get_Tp_allocator());
                               :		}
                               :	      __catch(...)
                               :		{
                               :		  if (!__new_finish)
                               :		    std::_Destroy(__new_start + __elems_before,
                               :				  __new_start + __elems_before + __n,
                               :				  _M_get_Tp_allocator());
                               :		  else
                               :		    std::_Destroy(__new_start, __new_finish,
                               :				  _M_get_Tp_allocator());
                               :		  _M_deallocate(__new_start, __len);
                               :		  __throw_exception_again;
                               :		}
                               :	      std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
                               :			    _M_get_Tp_allocator());
                               :	      _M_deallocate(this->_M_impl._M_start,
                               :			    this->_M_impl._M_end_of_storage
                               :			    - this->_M_impl._M_start);
                               :	      this->_M_impl._M_start = __new_start;
                               :	      this->_M_impl._M_finish = __new_finish;
                               :	      this->_M_impl._M_end_of_storage = __new_start + __len;
                               :	    }
                               :	}
                               :    }
                               :
                               :#if __cplusplus >= 201103L
                               :  template<typename _Tp, typename _Alloc>
                               :    void
                               :    vector<_Tp, _Alloc>::
                               :    _M_default_append(size_type __n)
                               :    {
                               :      if (__n != 0)
                               :	{
                               :	  if (size_type(this->_M_impl._M_end_of_storage
                               :			- this->_M_impl._M_finish) >= __n)
                               :	    {
                               :	      std::__uninitialized_default_n_a(this->_M_impl._M_finish,
                               :					       __n, _M_get_Tp_allocator());
                               :	      this->_M_impl._M_finish += __n;
                               :	    }
                               :	  else
                               :	    {
                               :	      const size_type __len =
                               :		_M_check_len(__n, "vector::_M_default_append");
                               :	      const size_type __old_size = this->size();
                               :	      pointer __new_start(this->_M_allocate(__len));
                               :	      pointer __new_finish(__new_start);
                               :	      __try
                               :		{
                               :		  __new_finish
                               :		    = std::__uninitialized_move_if_noexcept_a
                               :		    (this->_M_impl._M_start, this->_M_impl._M_finish,
                               :		     __new_start, _M_get_Tp_allocator());
                               :		  std::__uninitialized_default_n_a(__new_finish, __n,
                               :						   _M_get_Tp_allocator());
                               :		  __new_finish += __n;
                               :		}
                               :	      __catch(...)
                               :		{
                               :		  std::_Destroy(__new_start, __new_finish,
                               :				_M_get_Tp_allocator());
                               :		  _M_deallocate(__new_start, __len);
                               :		  __throw_exception_again;
                               :		}
                               :	      std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
                               :			    _M_get_Tp_allocator());
                               :	      _M_deallocate(this->_M_impl._M_start,
                               :			    this->_M_impl._M_end_of_storage
                               :			    - this->_M_impl._M_start);
                               :	      this->_M_impl._M_start = __new_start;
                               :	      this->_M_impl._M_finish = __new_finish;
                               :	      this->_M_impl._M_end_of_storage = __new_start + __len;
                               :	    }
                               :	}
                               :    }
                               :
                               :  template<typename _Tp, typename _Alloc>
                               :    bool
                               :    vector<_Tp, _Alloc>::
                               :    _M_shrink_to_fit()
                               :    {
                               :      if (capacity() == size())
                               :	return false;
                               :      return std::__shrink_to_fit_aux<vector>::_S_do_it(*this);
                               :    }
                               :#endif
                               :
                               :  template<typename _Tp, typename _Alloc>
                               :    template<typename _InputIterator>
                               :      void
                               :      vector<_Tp, _Alloc>::
                               :      _M_range_insert(iterator __pos, _InputIterator __first,
                               :		      _InputIterator __last, std::input_iterator_tag)
                               :      {
                               :	for (; __first != __last; ++__first)
                               :	  {
                               :	    __pos = insert(__pos, *__first);
                               :	    ++__pos;
                               :	  }
                               :      }
                               :
                               :  template<typename _Tp, typename _Alloc>
                               :    template<typename _ForwardIterator>
                               :      void
                               :      vector<_Tp, _Alloc>::
                               :      _M_range_insert(iterator __position, _ForwardIterator __first,
                               :		      _ForwardIterator __last, std::forward_iterator_tag)
                               :      {
    49  0.0417     0       0   :	if (__first != __last)
                               :	  {
                               :	    const size_type __n = std::distance(__first, __last);
    60  0.0510     0       0   :	    if (size_type(this->_M_impl._M_end_of_storage
                               :			  - this->_M_impl._M_finish) >= __n)
                               :	      {
                               :		const size_type __elems_after = end() - __position;
                               :		pointer __old_finish(this->_M_impl._M_finish);
                               :		if (__elems_after > __n)
                               :		  {
                               :		    std::__uninitialized_move_a(this->_M_impl._M_finish - __n,
                               :						this->_M_impl._M_finish,
                               :						this->_M_impl._M_finish,
                               :						_M_get_Tp_allocator());
                               :		    this->_M_impl._M_finish += __n;
                               :		    _GLIBCXX_MOVE_BACKWARD3(__position.base(),
                               :					    __old_finish - __n, __old_finish);
                               :		    std::copy(__first, __last, __position);
                               :		  }
                               :		else
                               :		  {
                               :		    _ForwardIterator __mid = __first;
                               :		    std::advance(__mid, __elems_after);
                               :		    std::__uninitialized_copy_a(__mid, __last,
                               :						this->_M_impl._M_finish,
                               :						_M_get_Tp_allocator());
                               :		    this->_M_impl._M_finish += __n - __elems_after;
                               :		    std::__uninitialized_move_a(__position.base(),
                               :						__old_finish,
                               :						this->_M_impl._M_finish,
                               :						_M_get_Tp_allocator());
                               :		    this->_M_impl._M_finish += __elems_after;
                               :		    std::copy(__first, __mid, __position);
                               :		  }
                               :	      }
                               :	    else
                               :	      {
                               :		const size_type __len =
                               :		  _M_check_len(__n, "vector::_M_range_insert");
                               :		pointer __new_start(this->_M_allocate(__len));
                               :		pointer __new_finish(__new_start);
                               :		__try
                               :		  {
                               :		    __new_finish
                               :		      = std::__uninitialized_move_if_noexcept_a
                               :		      (this->_M_impl._M_start, __position.base(),
    10  0.0085     0       0   :		       __new_start, _M_get_Tp_allocator());
                               :		    __new_finish
                               :		      = std::__uninitialized_copy_a(__first, __last,
                               :						    __new_finish,
                               :						    _M_get_Tp_allocator());
                               :		    __new_finish
                               :		      = std::__uninitialized_move_if_noexcept_a
                               :		      (__position.base(), this->_M_impl._M_finish,
                               :		       __new_finish, _M_get_Tp_allocator());
                               :		  }
                               :		__catch(...)
                               :		  {
                               :		    std::_Destroy(__new_start, __new_finish,
                               :				  _M_get_Tp_allocator());
                               :		    _M_deallocate(__new_start, __len);
                               :		    __throw_exception_again;
                               :		  }
                               :		std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
                               :			      _M_get_Tp_allocator());
                               :		_M_deallocate(this->_M_impl._M_start,
                               :			      this->_M_impl._M_end_of_storage
    38  0.0323     0       0   :			      - this->_M_impl._M_start);
    27  0.0230     0       0   :		this->_M_impl._M_start = __new_start;
    14  0.0119     0       0   :		this->_M_impl._M_finish = __new_finish;
    65  0.0553     1  0.0591   :		this->_M_impl._M_end_of_storage = __new_start + __len;
                               :	      }
                               :	  }
                               :      }
                               :
                               :
                               :  // vector<bool>
                               :  template<typename _Alloc>
                               :    void
                               :    vector<bool, _Alloc>::
                               :    _M_reallocate(size_type __n)
                               :    {
                               :      _Bit_type* __q = this->_M_allocate(__n);
                               :      this->_M_impl._M_finish = _M_copy_aligned(begin(), end(),
                               :						iterator(__q, 0));
                               :      this->_M_deallocate();
                               :      this->_M_impl._M_start = iterator(__q, 0);
                               :      this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
                               :    }
                               :
                               :  template<typename _Alloc>
                               :    void
                               :    vector<bool, _Alloc>::
                               :    _M_fill_insert(iterator __position, size_type __n, bool __x)
                               :    {
                               :      if (__n == 0)
                               :	return;
                               :      if (capacity() - size() >= __n)
                               :	{
                               :	  std::copy_backward(__position, end(),
                               :			     this->_M_impl._M_finish + difference_type(__n));
                               :	  std::fill(__position, __position + difference_type(__n), __x);
                               :	  this->_M_impl._M_finish += difference_type(__n);
                               :	}
                               :      else
                               :	{
                               :	  const size_type __len = 
                               :	    _M_check_len(__n, "vector<bool>::_M_fill_insert");
                               :	  _Bit_type * __q = this->_M_allocate(__len);
                               :	  iterator __i = _M_copy_aligned(begin(), __position,
                               :					 iterator(__q, 0));
                               :	  std::fill(__i, __i + difference_type(__n), __x);
                               :	  this->_M_impl._M_finish = std::copy(__position, end(),
                               :					      __i + difference_type(__n));
                               :	  this->_M_deallocate();
                               :	  this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
                               :	  this->_M_impl._M_start = iterator(__q, 0);
                               :	}
                               :    }
                               :
                               :  template<typename _Alloc>
                               :    template<typename _ForwardIterator>
                               :      void
                               :      vector<bool, _Alloc>::
                               :      _M_insert_range(iterator __position, _ForwardIterator __first, 
                               :		      _ForwardIterator __last, std::forward_iterator_tag)
                               :      {
                               :	if (__first != __last)
                               :	  {
                               :	    size_type __n = std::distance(__first, __last);
                               :	    if (capacity() - size() >= __n)
                               :	      {
                               :		std::copy_backward(__position, end(),
                               :				   this->_M_impl._M_finish
                               :				   + difference_type(__n));
                               :		std::copy(__first, __last, __position);
                               :		this->_M_impl._M_finish += difference_type(__n);
                               :	      }
                               :	    else
                               :	      {
                               :		const size_type __len =
                               :		  _M_check_len(__n, "vector<bool>::_M_insert_range");
                               :		_Bit_type * __q = this->_M_allocate(__len);
                               :		iterator __i = _M_copy_aligned(begin(), __position,
                               :					       iterator(__q, 0));
                               :		__i = std::copy(__first, __last, __i);
                               :		this->_M_impl._M_finish = std::copy(__position, end(), __i);
                               :		this->_M_deallocate();
                               :		this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
                               :		this->_M_impl._M_start = iterator(__q, 0);
                               :	      }
                               :	  }
                               :      }
                               :
                               :  template<typename _Alloc>
                               :    void
                               :    vector<bool, _Alloc>::
                               :    _M_insert_aux(iterator __position, bool __x)
                               :    {
                               :      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_of_storage)
                               :	{
                               :	  std::copy_backward(__position, this->_M_impl._M_finish, 
                               :			     this->_M_impl._M_finish + 1);
                               :	  *__position = __x;
                               :	  ++this->_M_impl._M_finish;
                               :	}
                               :      else
                               :	{
                               :	  const size_type __len =
                               :	    _M_check_len(size_type(1), "vector<bool>::_M_insert_aux");
                               :	  _Bit_type * __q = this->_M_allocate(__len);
                               :	  iterator __i = _M_copy_aligned(begin(), __position,
                               :					 iterator(__q, 0));
                               :	  *__i++ = __x;
                               :	  this->_M_impl._M_finish = std::copy(__position, end(), __i);
                               :	  this->_M_deallocate();
                               :	  this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
                               :	  this->_M_impl._M_start = iterator(__q, 0);
                               :	}
                               :    }
                               :
                               :#if __cplusplus >= 201103L
                               :  template<typename _Alloc>
                               :    bool
                               :    vector<bool, _Alloc>::
                               :    _M_shrink_to_fit()
                               :    {
                               :      if (capacity() - size() < int(_S_word_bit))
                               :	return false;
                               :      __try
                               :	{
                               :	  _M_reallocate(size());
                               :	  return true;
                               :	}
                               :      __catch(...)
                               :	{ return false; }
                               :    }
                               :#endif
                               :
                               :_GLIBCXX_END_NAMESPACE_CONTAINER
                               :} // namespace std
                               :
                               :#if __cplusplus >= 201103L
                               :
                               :namespace std _GLIBCXX_VISIBILITY(default)
                               :{
                               :_GLIBCXX_BEGIN_NAMESPACE_VERSION
                               :
                               :  template<typename _Alloc>
                               :    size_t
                               :    hash<_GLIBCXX_STD_C::vector<bool, _Alloc>>::
                               :    operator()(const _GLIBCXX_STD_C::vector<bool, _Alloc>& __b) const noexcept
                               :    {
                               :      size_t __hash = 0;
                               :      using _GLIBCXX_STD_C::_S_word_bit;
                               :      using _GLIBCXX_STD_C::_Bit_type;
                               :
                               :      const size_t __words = __b.size() / _S_word_bit;
                               :      if (__words)
                               :	{
                               :	  const size_t __clength = __words * sizeof(_Bit_type);
                               :	  __hash = std::_Hash_impl::hash(__b._M_impl._M_start._M_p, __clength);
                               :	}
                               :
                               :      const size_t __extrabits = __b.size() % _S_word_bit;
                               :      if (__extrabits)
                               :	{
                               :	  _Bit_type __hiword = *__b._M_impl._M_finish._M_p;
                               :	  __hiword &= ~((~static_cast<_Bit_type>(0)) << __extrabits);
                               :
                               :	  const size_t __clength
                               :	    = (__extrabits + __CHAR_BIT__ - 1) / __CHAR_BIT__;
                               :	  if (__words)
                               :	    __hash = std::_Hash_impl::hash(&__hiword, __clength, __hash);
                               :	  else
                               :	    __hash = std::_Hash_impl::hash(&__hiword, __clength);
                               :	}
                               :
                               :      return __hash;
                               :    }
                               :
                               :_GLIBCXX_END_NAMESPACE_VERSION
                               :} // namespace std
                               :
                               :#endif // C++11
                               :
                               :#endif /* _VECTOR_TCC */
/* 
 * Total samples for file : "/usr/include/c++/4.8/bits/unordered_map.h"
 * 
 *    214  0.1821     3  0.1772
 */


                               :// unordered_map implementation -*- C++ -*-
                               :
                               :// Copyright (C) 2010-2013 Free Software Foundation, Inc.
                               ://
                               :// This file is part of the GNU ISO C++ Library.  This library is free
                               :// software; you can redistribute it and/or modify it under the
                               :// terms of the GNU General Public License as published by the
                               :// Free Software Foundation; either version 3, or (at your option)
                               :// any later version.
                               :
                               :// This library is distributed in the hope that it will be useful,
                               :// but WITHOUT ANY WARRANTY; without even the implied warranty of
                               :// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                               :// GNU General Public License for more details.
                               :
                               :// Under Section 7 of GPL version 3, you are granted additional
                               :// permissions described in the GCC Runtime Library Exception, version
                               :// 3.1, as published by the Free Software Foundation.
                               :
                               :// You should have received a copy of the GNU General Public License and
                               :// a copy of the GCC Runtime Library Exception along with this program;
                               :// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                               :// <http://www.gnu.org/licenses/>.
                               :
                               :/** @file bits/unordered_map.h
                               : *  This is an internal header file, included by other library headers.
                               : *  Do not attempt to use it directly. @headername{unordered_map}
                               : */
                               :
                               :#ifndef _UNORDERED_MAP_H
                               :#define _UNORDERED_MAP_H
                               :
                               :namespace std _GLIBCXX_VISIBILITY(default)
                               :{
                               :_GLIBCXX_BEGIN_NAMESPACE_CONTAINER
                               :
                               :  /// Base types for unordered_map.
                               :  template<bool _Cache>
                               :    using __umap_traits = __detail::_Hashtable_traits<_Cache, false, true>;
                               :
                               :  template<typename _Key,
                               :	   typename _Tp,
                               :	   typename _Hash = hash<_Key>,
                               :	   typename _Pred = std::equal_to<_Key>,
                               :	   typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >,
                               :	   typename _Tr = __umap_traits<__cache_default<_Key, _Hash>::value>>
                               :    using __umap_hashtable = _Hashtable<_Key, std::pair<const _Key, _Tp>,
                               :                                        _Alloc, __detail::_Select1st,
                               :				        _Pred, _Hash,
                               :				        __detail::_Mod_range_hashing,
                               :				        __detail::_Default_ranged_hash,
                               :				        __detail::_Prime_rehash_policy, _Tr>;
                               :
                               :  /// Base types for unordered_multimap.
                               :  template<bool _Cache>
                               :    using __ummap_traits = __detail::_Hashtable_traits<_Cache, false, false>;
                               :
                               :  template<typename _Key,
                               :	   typename _Tp,
                               :	   typename _Hash = hash<_Key>,
                               :	   typename _Pred = std::equal_to<_Key>,
                               :	   typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >,
                               :	   typename _Tr = __ummap_traits<__cache_default<_Key, _Hash>::value>>
                               :    using __ummap_hashtable = _Hashtable<_Key, std::pair<const _Key, _Tp>,
                               :					 _Alloc, __detail::_Select1st,
                               :					 _Pred, _Hash,
                               :					 __detail::_Mod_range_hashing,
                               :					 __detail::_Default_ranged_hash,
                               :					 __detail::_Prime_rehash_policy, _Tr>;
                               :
                               :  /**
                               :   *  @brief A standard container composed of unique keys (containing
                               :   *  at most one of each key value) that associates values of another type
                               :   *  with the keys.
                               :   *
                               :   *  @ingroup unordered_associative_containers
                               :   *
                               :   *  @tparam  _Key  Type of key objects.
                               :   *  @tparam  _Tp  Type of mapped objects.
                               :   *  @tparam  _Hash  Hashing function object type, defaults to hash<_Value>.
                               :   *  @tparam  _Pred  Predicate function object type, defaults
                               :   *                  to equal_to<_Value>.
                               :   *  @tparam  _Alloc  Allocator type, defaults to allocator<_Key>.
                               :   *
                               :   *  Meets the requirements of a <a href="tables.html#65">container</a>, and
                               :   *  <a href="tables.html#xx">unordered associative container</a>
                               :   *
                               :   * The resulting value type of the container is std::pair<const _Key, _Tp>.
                               :   *
                               :   *  Base is _Hashtable, dispatched at compile time via template
                               :   *  alias __umap_hashtable.
                               :   */
                               :  template<class _Key, class _Tp,
                               :	   class _Hash = hash<_Key>,
                               :	   class _Pred = std::equal_to<_Key>,
                               :	   class _Alloc = std::allocator<std::pair<const _Key, _Tp> > >
                               :    class unordered_map : __check_copy_constructible<_Alloc> /* std::unordered_map<std::pair<int, int>, std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>, std::allocator<std::pair<int, int> > >, pair_cmp>, pair_hash, std::equal_to<std::pair<int, int> >, std::allocator<std::pair<std::pair<int, int> const, std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>, std::allocator<std::pair<int, int> > >, pair_cmp> > > >::~unordered_map() total:    159  0.1353     8  0.4725 */
                               :    {
                               :      typedef __umap_hashtable<_Key, _Tp, _Hash, _Pred, _Alloc>  _Hashtable;
                               :      _Hashtable _M_h;
                               :
                               :    public:
                               :      // typedefs:
                               :      //@{
                               :      /// Public typedefs.
                               :      typedef typename _Hashtable::key_type	key_type;
                               :      typedef typename _Hashtable::value_type	value_type;
                               :      typedef typename _Hashtable::mapped_type	mapped_type;
                               :      typedef typename _Hashtable::hasher	hasher;
                               :      typedef typename _Hashtable::key_equal	key_equal;
                               :      typedef typename _Hashtable::allocator_type allocator_type;
                               :      //@}
                               :
                               :      //@{
                               :      ///  Iterator-related typedefs.
                               :      typedef typename allocator_type::pointer		pointer;
                               :      typedef typename allocator_type::const_pointer	const_pointer;
                               :      typedef typename allocator_type::reference	reference;
                               :      typedef typename allocator_type::const_reference	const_reference;
                               :      typedef typename _Hashtable::iterator		iterator;
                               :      typedef typename _Hashtable::const_iterator	const_iterator;
                               :      typedef typename _Hashtable::local_iterator	local_iterator;
                               :      typedef typename _Hashtable::const_local_iterator	const_local_iterator;
                               :      typedef typename _Hashtable::size_type		size_type;
                               :      typedef typename _Hashtable::difference_type	difference_type;
                               :      //@}
                               :
                               :      //construct/destroy/copy
                               :
                               :      /**
                               :       *  @brief  Default constructor creates no elements.
                               :       *  @param __n  Initial number of buckets.
                               :       *  @param __hf  A hash functor.
                               :       *  @param __eql  A key equality functor.
                               :       *  @param __a  An allocator object.
                               :       */
                               :      explicit
                               :      unordered_map(size_type __n = 10,
                               :		    const hasher& __hf = hasher(),
                               :		    const key_equal& __eql = key_equal(),
                               :		    const allocator_type& __a = allocator_type())
                               :      : _M_h(__n, __hf, __eql, __a)
                               :      { }
                               :
                               :      /**
                               :       *  @brief  Builds an %unordered_map from a range.
                               :       *  @param  __first  An input iterator.
                               :       *  @param  __last  An input iterator.
                               :       *  @param __n  Minimal initial number of buckets.
                               :       *  @param __hf  A hash functor.
                               :       *  @param __eql  A key equality functor.
                               :       *  @param __a  An allocator object.
                               :       *
                               :       *  Create an %unordered_map consisting of copies of the elements from
                               :       *  [__first,__last).  This is linear in N (where N is
                               :       *  distance(__first,__last)).
                               :       */
                               :      template<typename _InputIterator>
                               :	unordered_map(_InputIterator __f, _InputIterator __l,
                               :		      size_type __n = 0,
                               :		      const hasher& __hf = hasher(),
                               :		      const key_equal& __eql = key_equal(),
                               :		      const allocator_type& __a = allocator_type())
                               :	: _M_h(__f, __l, __n, __hf, __eql, __a)
                               :	{ }
                               :
                               :      /// Copy constructor.
                               :      unordered_map(const unordered_map&) = default;
                               :
                               :      /// Move constructor.
                               :      unordered_map(unordered_map&&) = default;
                               :
                               :      /**
                               :       *  @brief  Builds an %unordered_map from an initializer_list.
                               :       *  @param  __l  An initializer_list.
                               :       *  @param __n  Minimal initial number of buckets.
                               :       *  @param __hf  A hash functor.
                               :       *  @param __eql  A key equality functor.
                               :       *  @param  __a  An allocator object.
                               :       *
                               :       *  Create an %unordered_map consisting of copies of the elements in the
                               :       *  list. This is linear in N (where N is @a __l.size()).
                               :       */
                               :      unordered_map(initializer_list<value_type> __l,
                               :		    size_type __n = 0,
                               :		    const hasher& __hf = hasher(),
                               :		    const key_equal& __eql = key_equal(),
                               :		    const allocator_type& __a = allocator_type())
                               :	: _M_h(__l, __n, __hf, __eql, __a)
                               :      { }
                               :
                               :      /// Copy assignment operator.
                               :      unordered_map&
                               :      operator=(const unordered_map&) = default;
                               :
                               :      /// Move assignment operator.
                               :      unordered_map&
                               :      operator=(unordered_map&&) = default;
                               :
                               :      /**
                               :       *  @brief  %Unordered_map list assignment operator.
                               :       *  @param  __l  An initializer_list.
                               :       *
                               :       *  This function fills an %unordered_map with copies of the elements in
                               :       *  the initializer list @a __l.
                               :       *
                               :       *  Note that the assignment completely changes the %unordered_map and
                               :       *  that the resulting %unordered_map's size is the same as the number
                               :       *  of elements assigned.  Old data may be lost.
                               :       */
                               :      unordered_map&
                               :      operator=(initializer_list<value_type> __l)
                               :      {
                               :	_M_h = __l;
                               :	return *this;
                               :      }
                               :
                               :      ///  Returns the allocator object with which the %unordered_map was
                               :      ///  constructed.
                               :      allocator_type
                               :      get_allocator() const noexcept
                               :      { return _M_h.get_allocator(); }
                               :
                               :      // size and capacity:
                               :
                               :      ///  Returns true if the %unordered_map is empty.
                               :      bool
                               :      empty() const noexcept
                               :      { return _M_h.empty(); }
                               :
                               :      ///  Returns the size of the %unordered_map.
                               :      size_type
                               :      size() const noexcept
                               :      { return _M_h.size(); }
                               :
                               :      ///  Returns the maximum size of the %unordered_map.
                               :      size_type
                               :      max_size() const noexcept
                               :      { return _M_h.max_size(); }
                               :
                               :      // iterators.
                               :
                               :      /**
                               :       *  Returns a read/write iterator that points to the first element in the
                               :       *  %unordered_map.
                               :       */
                               :      iterator
                               :      begin() noexcept
                               :      { return _M_h.begin(); }
                               :
                               :      //@{
                               :      /**
                               :       *  Returns a read-only (constant) iterator that points to the first
                               :       *  element in the %unordered_map.
                               :       */
                               :      const_iterator
                               :      begin() const noexcept
                               :      { return _M_h.begin(); }
                               :
                               :      const_iterator
                               :      cbegin() const noexcept
                               :      { return _M_h.begin(); }
                               :      //@}
                               :
                               :      /**
                               :       *  Returns a read/write iterator that points one past the last element in
                               :       *  the %unordered_map.
                               :       */
                               :      iterator
                               :      end() noexcept
                               :      { return _M_h.end(); }
                               :
                               :      //@{
                               :      /**
                               :       *  Returns a read-only (constant) iterator that points one past the last
                               :       *  element in the %unordered_map.
                               :       */
                               :      const_iterator
                               :      end() const noexcept
                               :      { return _M_h.end(); }
                               :
                               :      const_iterator
                               :      cend() const noexcept
                               :      { return _M_h.end(); }
                               :      //@}
                               :
                               :      // modifiers.
                               :
                               :      /**
                               :       *  @brief Attempts to build and insert a std::pair into the %unordered_map.
                               :       *
                               :       *  @param __args  Arguments used to generate a new pair instance (see
                               :       *	        std::piecewise_contruct for passing arguments to each
                               :       *	        part of the pair constructor).
                               :       *
                               :       *  @return  A pair, of which the first element is an iterator that points
                               :       *           to the possibly inserted pair, and the second is a bool that
                               :       *           is true if the pair was actually inserted.
                               :       *
                               :       *  This function attempts to build and insert a (key, value) %pair into
                               :       *  the %unordered_map.
                               :       *  An %unordered_map relies on unique keys and thus a %pair is only
                               :       *  inserted if its first element (the key) is not already present in the
                               :       *  %unordered_map.
                               :       *
                               :       *  Insertion requires amortized constant time.
                               :       */
                               :      template<typename... _Args>
                               :	std::pair<iterator, bool>
                               :	emplace(_Args&&... __args)
                               :	{ return _M_h.emplace(std::forward<_Args>(__args)...); }
                               :
                               :      /**
                               :       *  @brief Attempts to build and insert a std::pair into the %unordered_map.
                               :       *
                               :       *  @param  __pos  An iterator that serves as a hint as to where the pair
                               :       *                should be inserted.
                               :       *  @param  __args  Arguments used to generate a new pair instance (see
                               :       *	         std::piecewise_contruct for passing arguments to each
                               :       *	         part of the pair constructor).
                               :       *  @return An iterator that points to the element with key of the
                               :       *          std::pair built from @a __args (may or may not be that
                               :       *          std::pair).
                               :       *
                               :       *  This function is not concerned about whether the insertion took place,
                               :       *  and thus does not return a boolean like the single-argument emplace()
                               :       *  does.
                               :       *  Note that the first parameter is only a hint and can potentially
                               :       *  improve the performance of the insertion process. A bad hint would
                               :       *  cause no gains in efficiency.
                               :       *
                               :       *  See
                               :       *  http://gcc.gnu.org/onlinedocs/libstdc++/manual/bk01pt07ch17.html
                               :       *  for more on @a hinting.
                               :       *
                               :       *  Insertion requires amortized constant time.
                               :       */
                               :      template<typename... _Args>
                               :	iterator
                               :	emplace_hint(const_iterator __pos, _Args&&... __args)
                               :	{ return _M_h.emplace_hint(__pos, std::forward<_Args>(__args)...); }
                               :
                               :      //@{
                               :      /**
                               :       *  @brief Attempts to insert a std::pair into the %unordered_map.
                               :
                               :       *  @param __x Pair to be inserted (see std::make_pair for easy
                               :       *	     creation of pairs).
                               :       *
                               :       *  @return  A pair, of which the first element is an iterator that 
                               :       *           points to the possibly inserted pair, and the second is 
                               :       *           a bool that is true if the pair was actually inserted.
                               :       *
                               :       *  This function attempts to insert a (key, value) %pair into the
                               :       *  %unordered_map. An %unordered_map relies on unique keys and thus a
                               :       *  %pair is only inserted if its first element (the key) is not already
                               :       *  present in the %unordered_map.
                               :       *
                               :       *  Insertion requires amortized constant time.
                               :       */
                               :      std::pair<iterator, bool>
                               :      insert(const value_type& __x)
                               :      { return _M_h.insert(__x); }
                               :
                               :      template<typename _Pair, typename = typename
                               :	       std::enable_if<std::is_constructible<value_type,
                               :						    _Pair&&>::value>::type>
                               :	std::pair<iterator, bool>
                               :	insert(_Pair&& __x)
                               :        { return _M_h.insert(std::forward<_Pair>(__x)); }
                               :      //@}
                               :
                               :      //@{
                               :      /**
                               :       *  @brief Attempts to insert a std::pair into the %unordered_map.
                               :       *  @param  __hint  An iterator that serves as a hint as to where the
                               :       *                 pair should be inserted.
                               :       *  @param  __x  Pair to be inserted (see std::make_pair for easy creation
                               :       *               of pairs).
                               :       *  @return An iterator that points to the element with key of
                               :       *           @a __x (may or may not be the %pair passed in).
                               :       *
                               :       *  This function is not concerned about whether the insertion took place,
                               :       *  and thus does not return a boolean like the single-argument insert()
                               :       *  does.  Note that the first parameter is only a hint and can
                               :       *  potentially improve the performance of the insertion process.  A bad
                               :       *  hint would cause no gains in efficiency.
                               :       *
                               :       *  See
                               :       *  http://gcc.gnu.org/onlinedocs/libstdc++/manual/bk01pt07ch17.html
                               :       *  for more on @a hinting.
                               :       *
                               :       *  Insertion requires amortized constant time.
                               :       */
                               :      iterator
                               :      insert(const_iterator __hint, const value_type& __x)
                               :      { return _M_h.insert(__hint, __x); }
                               :
                               :      template<typename _Pair, typename = typename
                               :	       std::enable_if<std::is_constructible<value_type,
                               :						    _Pair&&>::value>::type>
                               :	iterator
                               :	insert(const_iterator __hint, _Pair&& __x)
                               :	{ return _M_h.insert(__hint, std::forward<_Pair>(__x)); }
                               :      //@}
                               :
                               :      /**
                               :       *  @brief A template function that attempts to insert a range of
                               :       *  elements.
                               :       *  @param  __first  Iterator pointing to the start of the range to be
                               :       *                   inserted.
                               :       *  @param  __last  Iterator pointing to the end of the range.
                               :       *
                               :       *  Complexity similar to that of the range constructor.
                               :       */
                               :      template<typename _InputIterator>
                               :	void
                               :	insert(_InputIterator __first, _InputIterator __last)
                               :	{ _M_h.insert(__first, __last); }
                               :
                               :      /**
                               :       *  @brief Attempts to insert a list of elements into the %unordered_map.
                               :       *  @param  __l  A std::initializer_list<value_type> of elements
                               :       *               to be inserted.
                               :       *
                               :       *  Complexity similar to that of the range constructor.
                               :       */
                               :      void
                               :      insert(initializer_list<value_type> __l)
                               :      { _M_h.insert(__l); }
                               :
                               :      //@{
                               :      /**
                               :       *  @brief Erases an element from an %unordered_map.
                               :       *  @param  __position  An iterator pointing to the element to be erased.
                               :       *  @return An iterator pointing to the element immediately following
                               :       *          @a __position prior to the element being erased. If no such
                               :       *          element exists, end() is returned.
                               :       *
                               :       *  This function erases an element, pointed to by the given iterator,
                               :       *  from an %unordered_map.
                               :       *  Note that this function only erases the element, and that if the
                               :       *  element is itself a pointer, the pointed-to memory is not touched in
                               :       *  any way.  Managing the pointer is the user's responsibility.
                               :       */
                               :      iterator
                               :      erase(const_iterator __position)
                               :      { return _M_h.erase(__position); }
                               :
                               :      // LWG 2059.
                               :      iterator
                               :      erase(iterator __it)
                               :      { return _M_h.erase(__it); }
                               :      //@}
                               :
                               :      /**
                               :       *  @brief Erases elements according to the provided key.
                               :       *  @param  __x  Key of element to be erased.
                               :       *  @return  The number of elements erased.
                               :       *
                               :       *  This function erases all the elements located by the given key from
                               :       *  an %unordered_map. For an %unordered_map the result of this function
                               :       *  can only be 0 (not present) or 1 (present).
                               :       *  Note that this function only erases the element, and that if the
                               :       *  element is itself a pointer, the pointed-to memory is not touched in
                               :       *  any way.  Managing the pointer is the user's responsibility.
                               :       */
                               :      size_type
                               :      erase(const key_type& __x)
                               :      { return _M_h.erase(__x); }
                               :
                               :      /**
                               :       *  @brief Erases a [__first,__last) range of elements from an
                               :       *  %unordered_map.
                               :       *  @param  __first  Iterator pointing to the start of the range to be
                               :       *                  erased.
                               :       *  @param __last  Iterator pointing to the end of the range to
                               :       *                be erased.
                               :       *  @return The iterator @a __last.
                               :       *
                               :       *  This function erases a sequence of elements from an %unordered_map.
                               :       *  Note that this function only erases the elements, and that if
                               :       *  the element is itself a pointer, the pointed-to memory is not touched
                               :       *  in any way.  Managing the pointer is the user's responsibility.
                               :       */
                               :      iterator
                               :      erase(const_iterator __first, const_iterator __last)
                               :      { return _M_h.erase(__first, __last); }
                               :
                               :      /**
                               :       *  Erases all elements in an %unordered_map.
                               :       *  Note that this function only erases the elements, and that if the
                               :       *  elements themselves are pointers, the pointed-to memory is not touched
                               :       *  in any way.  Managing the pointer is the user's responsibility.
                               :       */
                               :      void
                               :      clear() noexcept
                               :      { _M_h.clear(); }
                               :
                               :      /**
                               :       *  @brief  Swaps data with another %unordered_map.
                               :       *  @param  __x  An %unordered_map of the same element and allocator
                               :       *  types.
                               :       *
                               :       *  This exchanges the elements between two %unordered_map in constant time.
                               :       *  Note that the global std::swap() function is specialized such that
                               :       *  std::swap(m1,m2) will feed to this function.
                               :       */
                               :      void
                               :      swap(unordered_map& __x)
                               :      { _M_h.swap(__x._M_h); }
                               :
                               :      // observers.
                               :
                               :      ///  Returns the hash functor object with which the %unordered_map was
                               :      ///  constructed.
                               :      hasher
                               :      hash_function() const
                               :      { return _M_h.hash_function(); }
                               :
                               :      ///  Returns the key comparison object with which the %unordered_map was
                               :      ///  constructed.
                               :      key_equal
                               :      key_eq() const
                               :      { return _M_h.key_eq(); }
                               :
                               :      // lookup.
                               :
                               :      //@{
                               :      /**
                               :       *  @brief Tries to locate an element in an %unordered_map.
                               :       *  @param  __x  Key to be located.
                               :       *  @return  Iterator pointing to sought-after element, or end() if not
                               :       *           found.
                               :       *
                               :       *  This function takes a key and tries to locate the element with which
                               :       *  the key matches.  If successful the function returns an iterator
                               :       *  pointing to the sought after element.  If unsuccessful it returns the
                               :       *  past-the-end ( @c end() ) iterator.
                               :       */
                               :      iterator
                               :      find(const key_type& __x)
                               :      { return _M_h.find(__x); }
                               :
                               :      const_iterator
                               :      find(const key_type& __x) const
                               :      { return _M_h.find(__x); }
                               :      //@}
                               :
                               :      /**
                               :       *  @brief  Finds the number of elements.
                               :       *  @param  __x  Key to count.
                               :       *  @return  Number of elements with specified key.
                               :       *
                               :       *  This function only makes sense for %unordered_multimap; for
                               :       *  %unordered_map the result will either be 0 (not present) or 1
                               :       *  (present).
                               :       */
                               :      size_type
                               :      count(const key_type& __x) const
                               :      { return _M_h.count(__x); }
                               :
                               :      //@{
                               :      /**
                               :       *  @brief Finds a subsequence matching given key.
                               :       *  @param  __x  Key to be located.
                               :       *  @return  Pair of iterators that possibly points to the subsequence
                               :       *           matching given key.
                               :       *
                               :       *  This function probably only makes sense for %unordered_multimap.
                               :       */
                               :      std::pair<iterator, iterator>
                               :      equal_range(const key_type& __x)
                               :      { return _M_h.equal_range(__x); }
                               :
                               :      std::pair<const_iterator, const_iterator>
                               :      equal_range(const key_type& __x) const
                               :      { return _M_h.equal_range(__x); }
                               :      //@}
                               :
                               :      //@{
                               :      /**
                               :       *  @brief  Subscript ( @c [] ) access to %unordered_map data.
                               :       *  @param  __k  The key for which data should be retrieved.
                               :       *  @return  A reference to the data of the (key,data) %pair.
                               :       *
                               :       *  Allows for easy lookup with the subscript ( @c [] )operator.  Returns
                               :       *  data associated with the key specified in subscript.  If the key does
                               :       *  not exist, a pair with that key is created using default values, which
                               :       *  is then returned.
                               :       *
                               :       *  Lookup requires constant time.
                               :       */
                               :      mapped_type&
                               :      operator[](const key_type& __k)
   210  0.1787     3  0.1772   :      { return _M_h[__k]; }
                               :
                               :      mapped_type&
                               :      operator[](key_type&& __k)
     4  0.0034     0       0   :      { return _M_h[std::move(__k)]; }
                               :      //@}
                               :
                               :      //@{
                               :      /**
                               :       *  @brief  Access to %unordered_map data.
                               :       *  @param  __k  The key for which data should be retrieved.
                               :       *  @return  A reference to the data whose key is equal to @a __k, if
                               :       *           such a data is present in the %unordered_map.
                               :       *  @throw  std::out_of_range  If no such data is present.
                               :       */
                               :      mapped_type&
                               :      at(const key_type& __k)
                               :      { return _M_h.at(__k); }
                               :
                               :      const mapped_type&
                               :      at(const key_type& __k) const
                               :      { return _M_h.at(__k); }
                               :      //@}
                               :
                               :      // bucket interface.
                               :
                               :      /// Returns the number of buckets of the %unordered_map.
                               :      size_type
                               :      bucket_count() const noexcept
                               :      { return _M_h.bucket_count(); }
                               :
                               :      /// Returns the maximum number of buckets of the %unordered_map.
                               :      size_type
                               :      max_bucket_count() const noexcept
                               :      { return _M_h.max_bucket_count(); }
                               :
                               :      /*
                               :       * @brief  Returns the number of elements in a given bucket.
                               :       * @param  __n  A bucket index.
                               :       * @return  The number of elements in the bucket.
                               :       */
                               :      size_type
                               :      bucket_size(size_type __n) const
                               :      { return _M_h.bucket_size(__n); }
                               :
                               :      /*
                               :       * @brief  Returns the bucket index of a given element.
                               :       * @param  __key  A key instance.
                               :       * @return  The key bucket index.
                               :       */
                               :      size_type
                               :      bucket(const key_type& __key) const
                               :      { return _M_h.bucket(__key); }
                               :      
                               :      /**
                               :       *  @brief  Returns a read/write iterator pointing to the first bucket
                               :       *         element.
                               :       *  @param  __n The bucket index.
                               :       *  @return  A read/write local iterator.
                               :       */
                               :      local_iterator
                               :      begin(size_type __n)
                               :      { return _M_h.begin(__n); }
                               :
                               :      //@{
                               :      /**
                               :       *  @brief  Returns a read-only (constant) iterator pointing to the first
                               :       *         bucket element.
                               :       *  @param  __n The bucket index.
                               :       *  @return  A read-only local iterator.
                               :       */
                               :      const_local_iterator
                               :      begin(size_type __n) const
                               :      { return _M_h.begin(__n); }
                               :
                               :      const_local_iterator
                               :      cbegin(size_type __n) const
                               :      { return _M_h.cbegin(__n); }
                               :      //@}
                               :
                               :      /**
                               :       *  @brief  Returns a read/write iterator pointing to one past the last
                               :       *         bucket elements.
                               :       *  @param  __n The bucket index.
                               :       *  @return  A read/write local iterator.
                               :       */
                               :      local_iterator
                               :      end(size_type __n)
                               :      { return _M_h.end(__n); }
                               :
                               :      //@{
                               :      /**
                               :       *  @brief  Returns a read-only (constant) iterator pointing to one past
                               :       *         the last bucket elements.
                               :       *  @param  __n The bucket index.
                               :       *  @return  A read-only local iterator.
                               :       */
                               :      const_local_iterator
                               :      end(size_type __n) const
                               :      { return _M_h.end(__n); }
                               :
                               :      const_local_iterator
                               :      cend(size_type __n) const
                               :      { return _M_h.cend(__n); }
                               :      //@}
                               :
                               :      // hash policy.
                               :
                               :      /// Returns the average number of elements per bucket.
                               :      float
                               :      load_factor() const noexcept
                               :      { return _M_h.load_factor(); }
                               :
                               :      /// Returns a positive number that the %unordered_map tries to keep the
                               :      /// load factor less than or equal to.
                               :      float
                               :      max_load_factor() const noexcept
                               :      { return _M_h.max_load_factor(); }
                               :
                               :      /**
                               :       *  @brief  Change the %unordered_map maximum load factor.
                               :       *  @param  __z The new maximum load factor.
                               :       */
                               :      void
                               :      max_load_factor(float __z)
                               :      { _M_h.max_load_factor(__z); }
                               :
                               :      /**
                               :       *  @brief  May rehash the %unordered_map.
                               :       *  @param  __n The new number of buckets.
                               :       *
                               :       *  Rehash will occur only if the new number of buckets respect the
                               :       *  %unordered_map maximum load factor.
                               :       */
                               :      void
                               :      rehash(size_type __n)
                               :      { _M_h.rehash(__n); }
                               :
                               :      /**
                               :       *  @brief  Prepare the %unordered_map for a specified number of
                               :       *          elements.
                               :       *  @param  __n Number of elements required.
                               :       *
                               :       *  Same as rehash(ceil(n / max_load_factor())).
                               :       */
                               :      void
                               :      reserve(size_type __n)
                               :      { _M_h.reserve(__n); }
                               :
                               :      template<typename _Key1, typename _Tp1, typename _Hash1, typename _Pred1,
                               :	       typename _Alloc1>
                               :        friend bool
                               :      operator==(const unordered_map<_Key1, _Tp1, _Hash1, _Pred1, _Alloc1>&,
                               :		 const unordered_map<_Key1, _Tp1, _Hash1, _Pred1, _Alloc1>&);
                               :    };
                               :
                               :  /**
                               :   *  @brief A standard container composed of equivalent keys
                               :   *  (possibly containing multiple of each key value) that associates
                               :   *  values of another type with the keys.
                               :   *
                               :   *  @ingroup unordered_associative_containers
                               :   *
                               :   *  @tparam  _Key  Type of key objects.
                               :   *  @tparam  _Tp  Type of mapped objects.
                               :   *  @tparam  _Hash  Hashing function object type, defaults to hash<_Value>.
                               :   *  @tparam  _Pred  Predicate function object type, defaults
                               :   *                  to equal_to<_Value>.
                               :   *  @tparam  _Alloc  Allocator type, defaults to allocator<_Key>.
                               :   *
                               :   *  Meets the requirements of a <a href="tables.html#65">container</a>, and
                               :   *  <a href="tables.html#xx">unordered associative container</a>
                               :   *
                               :   * The resulting value type of the container is std::pair<const _Key, _Tp>.
                               :   *
                               :   *  Base is _Hashtable, dispatched at compile time via template
                               :   *  alias __ummap_hashtable.
                               :   */
                               :  template<class _Key, class _Tp,
                               :	   class _Hash = hash<_Key>,
                               :	   class _Pred = std::equal_to<_Key>,
                               :	   class _Alloc = std::allocator<std::pair<const _Key, _Tp> > >
                               :    class unordered_multimap : __check_copy_constructible<_Alloc>
                               :    {
                               :      typedef __ummap_hashtable<_Key, _Tp, _Hash, _Pred, _Alloc>  _Hashtable;
                               :      _Hashtable _M_h;
                               :
                               :    public:
                               :      // typedefs:
                               :      //@{
                               :      /// Public typedefs.
                               :      typedef typename _Hashtable::key_type	key_type;
                               :      typedef typename _Hashtable::value_type	value_type;
                               :      typedef typename _Hashtable::mapped_type	mapped_type;
                               :      typedef typename _Hashtable::hasher	hasher;
                               :      typedef typename _Hashtable::key_equal	key_equal;
                               :      typedef typename _Hashtable::allocator_type allocator_type;
                               :      //@}
                               :
                               :      //@{
                               :      ///  Iterator-related typedefs.
                               :      typedef typename allocator_type::pointer		pointer;
                               :      typedef typename allocator_type::const_pointer	const_pointer;
                               :      typedef typename allocator_type::reference	reference;
                               :      typedef typename allocator_type::const_reference	const_reference;
                               :      typedef typename _Hashtable::iterator		iterator;
                               :      typedef typename _Hashtable::const_iterator	const_iterator;
                               :      typedef typename _Hashtable::local_iterator	local_iterator;
                               :      typedef typename _Hashtable::const_local_iterator	const_local_iterator;
                               :      typedef typename _Hashtable::size_type		size_type;
                               :      typedef typename _Hashtable::difference_type	difference_type;
                               :      //@}
                               :
                               :      //construct/destroy/copy
                               :
                               :      /**
                               :       *  @brief  Default constructor creates no elements.
                               :       *  @param __n  Initial number of buckets.
                               :       *  @param __hf  A hash functor.
                               :       *  @param __eql  A key equality functor.
                               :       *  @param __a  An allocator object.
                               :       */
                               :      explicit
                               :      unordered_multimap(size_type __n = 10,
                               :			 const hasher& __hf = hasher(),
                               :			 const key_equal& __eql = key_equal(),
                               :			 const allocator_type& __a = allocator_type())
                               :      : _M_h(__n, __hf, __eql, __a)
                               :      { }
                               :
                               :      /**
                               :       *  @brief  Builds an %unordered_multimap from a range.
                               :       *  @param  __first  An input iterator.
                               :       *  @param  __last  An input iterator.
                               :       *  @param __n  Minimal initial number of buckets.
                               :       *  @param __hf  A hash functor.
                               :       *  @param __eql  A key equality functor.
                               :       *  @param __a  An allocator object.
                               :       *
                               :       *  Create an %unordered_multimap consisting of copies of the elements
                               :       *  from [__first,__last).  This is linear in N (where N is
                               :       *  distance(__first,__last)).
                               :       */
                               :      template<typename _InputIterator>
                               :	unordered_multimap(_InputIterator __f, _InputIterator __l,
                               :			   size_type __n = 0,
                               :			   const hasher& __hf = hasher(),
                               :			   const key_equal& __eql = key_equal(),
                               :			   const allocator_type& __a = allocator_type())
                               :	: _M_h(__f, __l, __n, __hf, __eql, __a)
                               :	{ }
                               :
                               :      /// Copy constructor.
                               :      unordered_multimap(const unordered_multimap&) = default;
                               :
                               :      /// Move constructor.
                               :      unordered_multimap(unordered_multimap&&) = default;
                               :
                               :      /**
                               :       *  @brief  Builds an %unordered_multimap from an initializer_list.
                               :       *  @param  __l  An initializer_list.
                               :       *  @param __n  Minimal initial number of buckets.
                               :       *  @param __hf  A hash functor.
                               :       *  @param __eql  A key equality functor.
                               :       *  @param  __a  An allocator object.
                               :       *
                               :       *  Create an %unordered_multimap consisting of copies of the elements in
                               :       *  the list. This is linear in N (where N is @a __l.size()).
                               :       */
                               :      unordered_multimap(initializer_list<value_type> __l,
                               :			 size_type __n = 0,
                               :			 const hasher& __hf = hasher(),
                               :			 const key_equal& __eql = key_equal(),
                               :			 const allocator_type& __a = allocator_type())
                               :	: _M_h(__l, __n, __hf, __eql, __a)
                               :      { }
                               :
                               :      /// Copy assignment operator.
                               :      unordered_multimap&
                               :      operator=(const unordered_multimap&) = default;
                               :
                               :      /// Move assignment operator.
                               :      unordered_multimap&
                               :      operator=(unordered_multimap&&) = default;
                               :
                               :      /**
                               :       *  @brief  %Unordered_multimap list assignment operator.
                               :       *  @param  __l  An initializer_list.
                               :       *
                               :       *  This function fills an %unordered_multimap with copies of the elements
                               :       *  in the initializer list @a __l.
                               :       *
                               :       *  Note that the assignment completely changes the %unordered_multimap
                               :       *  and that the resulting %unordered_multimap's size is the same as the
                               :       *  number of elements assigned.  Old data may be lost.
                               :       */
                               :      unordered_multimap&
                               :      operator=(initializer_list<value_type> __l)
                               :      {
                               :	_M_h = __l;
                               :	return *this;
                               :      }
                               :
                               :      ///  Returns the allocator object with which the %unordered_multimap was
                               :      ///  constructed.
                               :      allocator_type
                               :      get_allocator() const noexcept
                               :      { return _M_h.get_allocator(); }
                               :
                               :      // size and capacity:
                               :
                               :      ///  Returns true if the %unordered_multimap is empty.
                               :      bool
                               :      empty() const noexcept
                               :      { return _M_h.empty(); }
                               :
                               :      ///  Returns the size of the %unordered_multimap.
                               :      size_type
                               :      size() const noexcept
                               :      { return _M_h.size(); }
                               :
                               :      ///  Returns the maximum size of the %unordered_multimap.
                               :      size_type
                               :      max_size() const noexcept
                               :      { return _M_h.max_size(); }
                               :
                               :      // iterators.
                               :
                               :      /**
                               :       *  Returns a read/write iterator that points to the first element in the
                               :       *  %unordered_multimap.
                               :       */
                               :      iterator
                               :      begin() noexcept
                               :      { return _M_h.begin(); }
                               :
                               :      //@{
                               :      /**
                               :       *  Returns a read-only (constant) iterator that points to the first
                               :       *  element in the %unordered_multimap.
                               :       */
                               :      const_iterator
                               :      begin() const noexcept
                               :      { return _M_h.begin(); }
                               :
                               :      const_iterator
                               :      cbegin() const noexcept
                               :      { return _M_h.begin(); }
                               :      //@}
                               :
                               :      /**
                               :       *  Returns a read/write iterator that points one past the last element in
                               :       *  the %unordered_multimap.
                               :       */
                               :      iterator
                               :      end() noexcept
                               :      { return _M_h.end(); }
                               :
                               :      //@{
                               :      /**
                               :       *  Returns a read-only (constant) iterator that points one past the last
                               :       *  element in the %unordered_multimap.
                               :       */
                               :      const_iterator
                               :      end() const noexcept
                               :      { return _M_h.end(); }
                               :
                               :      const_iterator
                               :      cend() const noexcept
                               :      { return _M_h.end(); }
                               :      //@}
                               :
                               :      // modifiers.
                               :
                               :      /**
                               :       *  @brief Attempts to build and insert a std::pair into the
                               :       *  %unordered_multimap.
                               :       *
                               :       *  @param __args  Arguments used to generate a new pair instance (see
                               :       *	        std::piecewise_contruct for passing arguments to each
                               :       *	        part of the pair constructor).
                               :       *
                               :       *  @return  An iterator that points to the inserted pair.
                               :       *
                               :       *  This function attempts to build and insert a (key, value) %pair into
                               :       *  the %unordered_multimap.
                               :       *
                               :       *  Insertion requires amortized constant time.
                               :       */
                               :      template<typename... _Args>
                               :	iterator
                               :	emplace(_Args&&... __args)
                               :	{ return _M_h.emplace(std::forward<_Args>(__args)...); }
                               :
                               :      /**
                               :       *  @brief Attempts to build and insert a std::pair into the %unordered_multimap.
                               :       *
                               :       *  @param  __pos  An iterator that serves as a hint as to where the pair
                               :       *                should be inserted.
                               :       *  @param  __args  Arguments used to generate a new pair instance (see
                               :       *	         std::piecewise_contruct for passing arguments to each
                               :       *	         part of the pair constructor).
                               :       *  @return An iterator that points to the element with key of the
                               :       *          std::pair built from @a __args.
                               :       *
                               :       *  Note that the first parameter is only a hint and can potentially
                               :       *  improve the performance of the insertion process. A bad hint would
                               :       *  cause no gains in efficiency.
                               :       *
                               :       *  See
                               :       *  http://gcc.gnu.org/onlinedocs/libstdc++/manual/bk01pt07ch17.html
                               :       *  for more on @a hinting.
                               :       *
                               :       *  Insertion requires amortized constant time.
                               :       */
                               :      template<typename... _Args>
                               :	iterator
                               :	emplace_hint(const_iterator __pos, _Args&&... __args)
                               :	{ return _M_h.emplace_hint(__pos, std::forward<_Args>(__args)...); }
                               :
                               :      //@{
                               :      /**
                               :       *  @brief Inserts a std::pair into the %unordered_multimap.
                               :       *  @param __x Pair to be inserted (see std::make_pair for easy
                               :       *	     creation of pairs).
                               :       *
                               :       *  @return  An iterator that points to the inserted pair.
                               :       *
                               :       *  Insertion requires amortized constant time.
                               :       */
                               :      iterator
                               :      insert(const value_type& __x)
                               :      { return _M_h.insert(__x); }
                               :
                               :      template<typename _Pair, typename = typename
                               :	       std::enable_if<std::is_constructible<value_type,
                               :						    _Pair&&>::value>::type>
                               :	iterator
                               :	insert(_Pair&& __x)
                               :        { return _M_h.insert(std::forward<_Pair>(__x)); }
                               :      //@}
                               :
                               :      //@{
                               :      /**
                               :       *  @brief Inserts a std::pair into the %unordered_multimap.
                               :       *  @param  __hint  An iterator that serves as a hint as to where the
                               :       *                 pair should be inserted.
                               :       *  @param  __x  Pair to be inserted (see std::make_pair for easy creation
                               :       *               of pairs).
                               :       *  @return An iterator that points to the element with key of
                               :       *           @a __x (may or may not be the %pair passed in).
                               :       *
                               :       *  Note that the first parameter is only a hint and can potentially
                               :       *  improve the performance of the insertion process.  A bad hint would
                               :       *  cause no gains in efficiency.
                               :       *
                               :       *  See
                               :       *  http://gcc.gnu.org/onlinedocs/libstdc++/manual/bk01pt07ch17.html
                               :       *  for more on @a hinting.
                               :       *
                               :       *  Insertion requires amortized constant time.
                               :       */
                               :      iterator
                               :      insert(const_iterator __hint, const value_type& __x)
                               :      { return _M_h.insert(__hint, __x); }
                               :
                               :      template<typename _Pair, typename = typename
                               :	       std::enable_if<std::is_constructible<value_type,
                               :						    _Pair&&>::value>::type>
                               :	iterator
                               :	insert(const_iterator __hint, _Pair&& __x)
                               :        { return _M_h.insert(__hint, std::forward<_Pair>(__x)); }
                               :      //@}
                               :
                               :      /**
                               :       *  @brief A template function that attempts to insert a range of
                               :       *  elements.
                               :       *  @param  __first  Iterator pointing to the start of the range to be
                               :       *                   inserted.
                               :       *  @param  __last  Iterator pointing to the end of the range.
                               :       *
                               :       *  Complexity similar to that of the range constructor.
                               :       */
                               :      template<typename _InputIterator>
                               :	void
                               :	insert(_InputIterator __first, _InputIterator __last)
                               :	{ _M_h.insert(__first, __last); }
                               :
                               :      /**
                               :       *  @brief Attempts to insert a list of elements into the
                               :       *  %unordered_multimap.
                               :       *  @param  __l  A std::initializer_list<value_type> of elements
                               :       *               to be inserted.
                               :       *
                               :       *  Complexity similar to that of the range constructor.
                               :       */
                               :      void
                               :      insert(initializer_list<value_type> __l)
                               :      { _M_h.insert(__l); }
                               :
                               :      //@{
                               :      /**
                               :       *  @brief Erases an element from an %unordered_multimap.
                               :       *  @param  __position  An iterator pointing to the element to be erased.
                               :       *  @return An iterator pointing to the element immediately following
                               :       *          @a __position prior to the element being erased. If no such
                               :       *          element exists, end() is returned.
                               :       *
                               :       *  This function erases an element, pointed to by the given iterator,
                               :       *  from an %unordered_multimap.
                               :       *  Note that this function only erases the element, and that if the
                               :       *  element is itself a pointer, the pointed-to memory is not touched in
                               :       *  any way.  Managing the pointer is the user's responsibility.
                               :       */
                               :      iterator
                               :      erase(const_iterator __position)
                               :      { return _M_h.erase(__position); }
                               :
                               :      // LWG 2059.
                               :      iterator
                               :      erase(iterator __it)
                               :      { return _M_h.erase(__it); }
                               :      //@}
                               :
                               :      /**
                               :       *  @brief Erases elements according to the provided key.
                               :       *  @param  __x  Key of elements to be erased.
                               :       *  @return  The number of elements erased.
                               :       *
                               :       *  This function erases all the elements located by the given key from
                               :       *  an %unordered_multimap.
                               :       *  Note that this function only erases the element, and that if the
                               :       *  element is itself a pointer, the pointed-to memory is not touched in
                               :       *  any way.  Managing the pointer is the user's responsibility.
                               :       */
                               :      size_type
                               :      erase(const key_type& __x)
                               :      { return _M_h.erase(__x); }
                               :
                               :      /**
                               :       *  @brief Erases a [__first,__last) range of elements from an
                               :       *  %unordered_multimap.
                               :       *  @param  __first  Iterator pointing to the start of the range to be
                               :       *                  erased.
                               :       *  @param __last  Iterator pointing to the end of the range to
                               :       *                be erased.
                               :       *  @return The iterator @a __last.
                               :       *
                               :       *  This function erases a sequence of elements from an
                               :       *  %unordered_multimap.
                               :       *  Note that this function only erases the elements, and that if
                               :       *  the element is itself a pointer, the pointed-to memory is not touched
                               :       *  in any way.  Managing the pointer is the user's responsibility.
                               :       */
                               :      iterator
                               :      erase(const_iterator __first, const_iterator __last)
                               :      { return _M_h.erase(__first, __last); }
                               :
                               :      /**
                               :       *  Erases all elements in an %unordered_multimap.
                               :       *  Note that this function only erases the elements, and that if the
                               :       *  elements themselves are pointers, the pointed-to memory is not touched
                               :       *  in any way.  Managing the pointer is the user's responsibility.
                               :       */
                               :      void
                               :      clear() noexcept
                               :      { _M_h.clear(); }
                               :
                               :      /**
                               :       *  @brief  Swaps data with another %unordered_multimap.
                               :       *  @param  __x  An %unordered_multimap of the same element and allocator
                               :       *  types.
                               :       *
                               :       *  This exchanges the elements between two %unordered_multimap in
                               :       *  constant time.
                               :       *  Note that the global std::swap() function is specialized such that
                               :       *  std::swap(m1,m2) will feed to this function.
                               :       */
                               :      void
                               :      swap(unordered_multimap& __x)
                               :      { _M_h.swap(__x._M_h); }
                               :
                               :      // observers.
                               :
                               :      ///  Returns the hash functor object with which the %unordered_multimap
                               :      ///  was constructed.
                               :      hasher
                               :      hash_function() const
                               :      { return _M_h.hash_function(); }
                               :
                               :      ///  Returns the key comparison object with which the %unordered_multimap
                               :      ///  was constructed.
                               :      key_equal
                               :      key_eq() const
                               :      { return _M_h.key_eq(); }
                               :
                               :      // lookup.
                               :
                               :      //@{
                               :      /**
                               :       *  @brief Tries to locate an element in an %unordered_multimap.
                               :       *  @param  __x  Key to be located.
                               :       *  @return  Iterator pointing to sought-after element, or end() if not
                               :       *           found.
                               :       *
                               :       *  This function takes a key and tries to locate the element with which
                               :       *  the key matches.  If successful the function returns an iterator
                               :       *  pointing to the sought after element.  If unsuccessful it returns the
                               :       *  past-the-end ( @c end() ) iterator.
                               :       */
                               :      iterator
                               :      find(const key_type& __x)
                               :      { return _M_h.find(__x); }
                               :
                               :      const_iterator
                               :      find(const key_type& __x) const
                               :      { return _M_h.find(__x); }
                               :      //@}
                               :
                               :      /**
                               :       *  @brief  Finds the number of elements.
                               :       *  @param  __x  Key to count.
                               :       *  @return  Number of elements with specified key.
                               :       */
                               :      size_type
                               :      count(const key_type& __x) const
                               :      { return _M_h.count(__x); }
                               :
                               :      //@{
                               :      /**
                               :       *  @brief Finds a subsequence matching given key.
                               :       *  @param  __x  Key to be located.
                               :       *  @return  Pair of iterators that possibly points to the subsequence
                               :       *           matching given key.
                               :       */
                               :      std::pair<iterator, iterator>
                               :      equal_range(const key_type& __x)
                               :      { return _M_h.equal_range(__x); }
                               :
                               :      std::pair<const_iterator, const_iterator>
                               :      equal_range(const key_type& __x) const
                               :      { return _M_h.equal_range(__x); }
                               :      //@}
                               :
                               :      // bucket interface.
                               :
                               :      /// Returns the number of buckets of the %unordered_multimap.
                               :      size_type
                               :      bucket_count() const noexcept
                               :      { return _M_h.bucket_count(); }
                               :
                               :      /// Returns the maximum number of buckets of the %unordered_multimap.
                               :      size_type
                               :      max_bucket_count() const noexcept
                               :      { return _M_h.max_bucket_count(); }
                               :
                               :      /*
                               :       * @brief  Returns the number of elements in a given bucket.
                               :       * @param  __n  A bucket index.
                               :       * @return  The number of elements in the bucket.
                               :       */
                               :      size_type
                               :      bucket_size(size_type __n) const
                               :      { return _M_h.bucket_size(__n); }
                               :
                               :      /*
                               :       * @brief  Returns the bucket index of a given element.
                               :       * @param  __key  A key instance.
                               :       * @return  The key bucket index.
                               :       */
                               :      size_type
                               :      bucket(const key_type& __key) const
                               :      { return _M_h.bucket(__key); }
                               :      
                               :      /**
                               :       *  @brief  Returns a read/write iterator pointing to the first bucket
                               :       *         element.
                               :       *  @param  __n The bucket index.
                               :       *  @return  A read/write local iterator.
                               :       */
                               :      local_iterator
                               :      begin(size_type __n)
                               :      { return _M_h.begin(__n); }
                               :
                               :      //@{
                               :      /**
                               :       *  @brief  Returns a read-only (constant) iterator pointing to the first
                               :       *         bucket element.
                               :       *  @param  __n The bucket index.
                               :       *  @return  A read-only local iterator.
                               :       */
                               :      const_local_iterator
                               :      begin(size_type __n) const
                               :      { return _M_h.begin(__n); }
                               :
                               :      const_local_iterator
                               :      cbegin(size_type __n) const
                               :      { return _M_h.cbegin(__n); }
                               :      //@}
                               :
                               :      /**
                               :       *  @brief  Returns a read/write iterator pointing to one past the last
                               :       *         bucket elements.
                               :       *  @param  __n The bucket index.
                               :       *  @return  A read/write local iterator.
                               :       */
                               :      local_iterator
                               :      end(size_type __n)
                               :      { return _M_h.end(__n); }
                               :
                               :      //@{
                               :      /**
                               :       *  @brief  Returns a read-only (constant) iterator pointing to one past
                               :       *         the last bucket elements.
                               :       *  @param  __n The bucket index.
                               :       *  @return  A read-only local iterator.
                               :       */
                               :      const_local_iterator
                               :      end(size_type __n) const
                               :      { return _M_h.end(__n); }
                               :
                               :      const_local_iterator
                               :      cend(size_type __n) const
                               :      { return _M_h.cend(__n); }
                               :      //@}
                               :
                               :      // hash policy.
                               :
                               :      /// Returns the average number of elements per bucket.
                               :      float
                               :      load_factor() const noexcept
                               :      { return _M_h.load_factor(); }
                               :
                               :      /// Returns a positive number that the %unordered_multimap tries to keep
                               :      /// the load factor less than or equal to.
                               :      float
                               :      max_load_factor() const noexcept
                               :      { return _M_h.max_load_factor(); }
                               :
                               :      /**
                               :       *  @brief  Change the %unordered_multimap maximum load factor.
                               :       *  @param  __z The new maximum load factor.
                               :       */
                               :      void
                               :      max_load_factor(float __z)
                               :      { _M_h.max_load_factor(__z); }
                               :
                               :      /**
                               :       *  @brief  May rehash the %unordered_multimap.
                               :       *  @param  __n The new number of buckets.
                               :       *
                               :       *  Rehash will occur only if the new number of buckets respect the
                               :       *  %unordered_multimap maximum load factor.
                               :       */
                               :      void
                               :      rehash(size_type __n)
                               :      { _M_h.rehash(__n); }
                               :
                               :      /**
                               :       *  @brief  Prepare the %unordered_multimap for a specified number of
                               :       *          elements.
                               :       *  @param  __n Number of elements required.
                               :       *
                               :       *  Same as rehash(ceil(n / max_load_factor())).
                               :       */
                               :      void
                               :      reserve(size_type __n)
                               :      { _M_h.reserve(__n); }
                               :
                               :      template<typename _Key1, typename _Tp1, typename _Hash1, typename _Pred1,
                               :	       typename _Alloc1>
                               :        friend bool
                               :	operator==(const unordered_multimap<_Key1, _Tp1,
                               :					    _Hash1, _Pred1, _Alloc1>&,
                               :		   const unordered_multimap<_Key1, _Tp1,
                               :					    _Hash1, _Pred1, _Alloc1>&);
                               :    };
                               :
                               :  template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
                               :    inline void
                               :    swap(unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
                               :	 unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)
                               :    { __x.swap(__y); }
                               :
                               :  template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
                               :    inline void
                               :    swap(unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
                               :	 unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)
                               :    { __x.swap(__y); }
                               :
                               :  template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
                               :    inline bool
                               :    operator==(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
                               :	       const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)
                               :    { return __x._M_h._M_equal(__y._M_h); }
                               :
                               :  template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
                               :    inline bool
                               :    operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
                               :	       const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)
                               :    { return !(__x == __y); }
                               :
                               :  template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
                               :    inline bool
                               :    operator==(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
                               :	       const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)
                               :    { return __x._M_h._M_equal(__y._M_h); }
                               :
                               :  template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
                               :    inline bool
                               :    operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
                               :	       const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)
                               :    { return !(__x == __y); }
                               :
                               :_GLIBCXX_END_NAMESPACE_CONTAINER
                               :} // namespace std
                               :
                               :#endif /* _UNORDERED_MAP_H */
/* 
 * Total samples for file : "/usr/include/c++/4.8/bits/stl_deque.h"
 * 
 *     87  0.0740     0       0
 */


                               :// Deque implementation -*- C++ -*-
                               :
                               :// Copyright (C) 2001-2013 Free Software Foundation, Inc.
                               ://
                               :// This file is part of the GNU ISO C++ Library.  This library is free
                               :// software; you can redistribute it and/or modify it under the
                               :// terms of the GNU General Public License as published by the
                               :// Free Software Foundation; either version 3, or (at your option)
                               :// any later version.
                               :
                               :// This library is distributed in the hope that it will be useful,
                               :// but WITHOUT ANY WARRANTY; without even the implied warranty of
                               :// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                               :// GNU General Public License for more details.
                               :
                               :// Under Section 7 of GPL version 3, you are granted additional
                               :// permissions described in the GCC Runtime Library Exception, version
                               :// 3.1, as published by the Free Software Foundation.
                               :
                               :// You should have received a copy of the GNU General Public License and
                               :// a copy of the GCC Runtime Library Exception along with this program;
                               :// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                               :// <http://www.gnu.org/licenses/>.
                               :
                               :/*
                               : *
                               : * Copyright (c) 1994
                               : * Hewlett-Packard Company
                               : *
                               : * Permission to use, copy, modify, distribute and sell this software
                               : * and its documentation for any purpose is hereby granted without fee,
                               : * provided that the above copyright notice appear in all copies and
                               : * that both that copyright notice and this permission notice appear
                               : * in supporting documentation.  Hewlett-Packard Company makes no
                               : * representations about the suitability of this software for any
                               : * purpose.  It is provided "as is" without express or implied warranty.
                               : *
                               : *
                               : * Copyright (c) 1997
                               : * Silicon Graphics Computer Systems, Inc.
                               : *
                               : * Permission to use, copy, modify, distribute and sell this software
                               : * and its documentation for any purpose is hereby granted without fee,
                               : * provided that the above copyright notice appear in all copies and
                               : * that both that copyright notice and this permission notice appear
                               : * in supporting documentation.  Silicon Graphics makes no
                               : * representations about the suitability of this software for any
                               : * purpose.  It is provided "as is" without express or implied warranty.
                               : */
                               :
                               :/** @file bits/stl_deque.h
                               : *  This is an internal header file, included by other library headers.
                               : *  Do not attempt to use it directly. @headername{deque}
                               : */
                               :
                               :#ifndef _STL_DEQUE_H
                               :#define _STL_DEQUE_H 1
                               :
                               :#include <bits/concept_check.h>
                               :#include <bits/stl_iterator_base_types.h>
                               :#include <bits/stl_iterator_base_funcs.h>
                               :#if __cplusplus >= 201103L
                               :#include <initializer_list>
                               :#endif
                               :
                               :namespace std _GLIBCXX_VISIBILITY(default)
                               :{
                               :_GLIBCXX_BEGIN_NAMESPACE_CONTAINER
                               :
                               :  /**
                               :   *  @brief This function controls the size of memory nodes.
                               :   *  @param  __size  The size of an element.
                               :   *  @return   The number (not byte size) of elements per node.
                               :   *
                               :   *  This function started off as a compiler kludge from SGI, but
                               :   *  seems to be a useful wrapper around a repeated constant
                               :   *  expression.  The @b 512 is tunable (and no other code needs to
                               :   *  change), but no investigation has been done since inheriting the
                               :   *  SGI code.  Touch _GLIBCXX_DEQUE_BUF_SIZE only if you know what
                               :   *  you are doing, however: changing it breaks the binary
                               :   *  compatibility!!
                               :  */
                               :
                               :#ifndef _GLIBCXX_DEQUE_BUF_SIZE
                               :#define _GLIBCXX_DEQUE_BUF_SIZE 512
                               :#endif
                               :
                               :  inline size_t
                               :  __deque_buf_size(size_t __size)
                               :  { return (__size < _GLIBCXX_DEQUE_BUF_SIZE
                               :	    ? size_t(_GLIBCXX_DEQUE_BUF_SIZE / __size) : size_t(1)); }
                               :
                               :
                               :  /**
                               :   *  @brief A deque::iterator.
                               :   *
                               :   *  Quite a bit of intelligence here.  Much of the functionality of
                               :   *  deque is actually passed off to this class.  A deque holds two
                               :   *  of these internally, marking its valid range.  Access to
                               :   *  elements is done as offsets of either of those two, relying on
                               :   *  operator overloading in this class.
                               :   *
                               :   *  All the functions are op overloads except for _M_set_node.
                               :  */
                               :  template<typename _Tp, typename _Ref, typename _Ptr>
                               :    struct _Deque_iterator
                               :    {
                               :      typedef _Deque_iterator<_Tp, _Tp&, _Tp*>             iterator;
                               :      typedef _Deque_iterator<_Tp, const _Tp&, const _Tp*> const_iterator;
                               :
                               :      static size_t _S_buffer_size()
                               :      { return __deque_buf_size(sizeof(_Tp)); }
                               :
                               :      typedef std::random_access_iterator_tag iterator_category;
                               :      typedef _Tp                             value_type;
                               :      typedef _Ptr                            pointer;
                               :      typedef _Ref                            reference;
                               :      typedef size_t                          size_type;
                               :      typedef ptrdiff_t                       difference_type;
                               :      typedef _Tp**                           _Map_pointer;
                               :      typedef _Deque_iterator                 _Self;
                               :
                               :      _Tp* _M_cur;
                               :      _Tp* _M_first;
                               :      _Tp* _M_last;
                               :      _Map_pointer _M_node;
                               :
                               :      _Deque_iterator(_Tp* __x, _Map_pointer __y)
                               :      : _M_cur(__x), _M_first(*__y),
                               :        _M_last(*__y + _S_buffer_size()), _M_node(__y) { }
                               :
                               :      _Deque_iterator()
                               :      : _M_cur(0), _M_first(0), _M_last(0), _M_node(0) { }
                               :
                               :      _Deque_iterator(const iterator& __x)
                               :      : _M_cur(__x._M_cur), _M_first(__x._M_first),
                               :        _M_last(__x._M_last), _M_node(__x._M_node) { }
                               :
                               :      reference
                               :      operator*() const
                               :      { return *_M_cur; }
                               :
                               :      pointer
                               :      operator->() const
                               :      { return _M_cur; }
                               :
                               :      _Self&
                               :      operator++()
                               :      {
                               :	++_M_cur;
                               :	if (_M_cur == _M_last)
                               :	  {
                               :	    _M_set_node(_M_node + 1);
                               :	    _M_cur = _M_first;
                               :	  }
                               :	return *this;
                               :      }
                               :
                               :      _Self
                               :      operator++(int)
                               :      {
                               :	_Self __tmp = *this;
                               :	++*this;
                               :	return __tmp;
                               :      }
                               :
                               :      _Self&
                               :      operator--()
                               :      {
                               :	if (_M_cur == _M_first)
                               :	  {
                               :	    _M_set_node(_M_node - 1);
                               :	    _M_cur = _M_last;
                               :	  }
                               :	--_M_cur;
                               :	return *this;
                               :      }
                               :
                               :      _Self
                               :      operator--(int)
                               :      {
                               :	_Self __tmp = *this;
                               :	--*this;
                               :	return __tmp;
                               :      }
                               :
                               :      _Self&
                               :      operator+=(difference_type __n)
                               :      {
                               :	const difference_type __offset = __n + (_M_cur - _M_first);
                               :	if (__offset >= 0 && __offset < difference_type(_S_buffer_size()))
                               :	  _M_cur += __n;
                               :	else
                               :	  {
                               :	    const difference_type __node_offset =
                               :	      __offset > 0 ? __offset / difference_type(_S_buffer_size())
                               :	                   : -difference_type((-__offset - 1)
                               :					      / _S_buffer_size()) - 1;
                               :	    _M_set_node(_M_node + __node_offset);
                               :	    _M_cur = _M_first + (__offset - __node_offset
                               :				 * difference_type(_S_buffer_size()));
                               :	  }
                               :	return *this;
                               :      }
                               :
                               :      _Self
                               :      operator+(difference_type __n) const
                               :      {
                               :	_Self __tmp = *this;
                               :	return __tmp += __n;
                               :      }
                               :
                               :      _Self&
                               :      operator-=(difference_type __n)
                               :      { return *this += -__n; }
                               :
                               :      _Self
                               :      operator-(difference_type __n) const
                               :      {
                               :	_Self __tmp = *this;
                               :	return __tmp -= __n;
                               :      }
                               :
                               :      reference
                               :      operator[](difference_type __n) const
                               :      { return *(*this + __n); }
                               :
                               :      /** 
                               :       *  Prepares to traverse new_node.  Sets everything except
                               :       *  _M_cur, which should therefore be set by the caller
                               :       *  immediately afterwards, based on _M_first and _M_last.
                               :       */
                               :      void
                               :      _M_set_node(_Map_pointer __new_node)
                               :      {
                               :	_M_node = __new_node;
     1 8.5e-04     0       0   :	_M_first = *__new_node;
     1 8.5e-04     0       0   :	_M_last = _M_first + difference_type(_S_buffer_size());
                               :      }
                               :    };
                               :
                               :  // Note: we also provide overloads whose operands are of the same type in
                               :  // order to avoid ambiguous overload resolution when std::rel_ops operators
                               :  // are in scope (for additional details, see libstdc++/3628)
                               :  template<typename _Tp, typename _Ref, typename _Ptr>
                               :    inline bool
                               :    operator==(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
                               :	       const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)
                               :    { return __x._M_cur == __y._M_cur; }
                               :
                               :  template<typename _Tp, typename _RefL, typename _PtrL,
                               :	   typename _RefR, typename _PtrR>
                               :    inline bool
                               :    operator==(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
                               :	       const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)
                               :    { return __x._M_cur == __y._M_cur; }
                               :
                               :  template<typename _Tp, typename _Ref, typename _Ptr>
                               :    inline bool
                               :    operator!=(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
                               :	       const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)
                               :    { return !(__x == __y); }
                               :
                               :  template<typename _Tp, typename _RefL, typename _PtrL,
                               :	   typename _RefR, typename _PtrR>
                               :    inline bool
                               :    operator!=(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
                               :	       const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)
                               :    { return !(__x == __y); }
                               :
                               :  template<typename _Tp, typename _Ref, typename _Ptr>
                               :    inline bool
                               :    operator<(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
                               :	      const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)
                               :    { return (__x._M_node == __y._M_node) ? (__x._M_cur < __y._M_cur)
                               :                                          : (__x._M_node < __y._M_node); }
                               :
                               :  template<typename _Tp, typename _RefL, typename _PtrL,
                               :	   typename _RefR, typename _PtrR>
                               :    inline bool
                               :    operator<(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
                               :	      const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)
                               :    { return (__x._M_node == __y._M_node) ? (__x._M_cur < __y._M_cur)
                               :	                                  : (__x._M_node < __y._M_node); }
                               :
                               :  template<typename _Tp, typename _Ref, typename _Ptr>
                               :    inline bool
                               :    operator>(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
                               :	      const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)
                               :    { return __y < __x; }
                               :
                               :  template<typename _Tp, typename _RefL, typename _PtrL,
                               :	   typename _RefR, typename _PtrR>
                               :    inline bool
                               :    operator>(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
                               :	      const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)
                               :    { return __y < __x; }
                               :
                               :  template<typename _Tp, typename _Ref, typename _Ptr>
                               :    inline bool
                               :    operator<=(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
                               :	       const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)
                               :    { return !(__y < __x); }
                               :
                               :  template<typename _Tp, typename _RefL, typename _PtrL,
                               :	   typename _RefR, typename _PtrR>
                               :    inline bool
                               :    operator<=(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
                               :	       const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)
                               :    { return !(__y < __x); }
                               :
                               :  template<typename _Tp, typename _Ref, typename _Ptr>
                               :    inline bool
                               :    operator>=(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
                               :	       const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)
                               :    { return !(__x < __y); }
                               :
                               :  template<typename _Tp, typename _RefL, typename _PtrL,
                               :	   typename _RefR, typename _PtrR>
                               :    inline bool
                               :    operator>=(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
                               :	       const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)
                               :    { return !(__x < __y); }
                               :
                               :  // _GLIBCXX_RESOLVE_LIB_DEFECTS
                               :  // According to the resolution of DR179 not only the various comparison
                               :  // operators but also operator- must accept mixed iterator/const_iterator
                               :  // parameters.
                               :  template<typename _Tp, typename _Ref, typename _Ptr>
                               :    inline typename _Deque_iterator<_Tp, _Ref, _Ptr>::difference_type
                               :    operator-(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
                               :	      const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)
                               :    {
                               :      return typename _Deque_iterator<_Tp, _Ref, _Ptr>::difference_type
                               :	(_Deque_iterator<_Tp, _Ref, _Ptr>::_S_buffer_size())
                               :	* (__x._M_node - __y._M_node - 1) + (__x._M_cur - __x._M_first)
                               :	+ (__y._M_last - __y._M_cur);
                               :    }
                               :
                               :  template<typename _Tp, typename _RefL, typename _PtrL,
                               :	   typename _RefR, typename _PtrR>
                               :    inline typename _Deque_iterator<_Tp, _RefL, _PtrL>::difference_type
                               :    operator-(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
                               :	      const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)
                               :    {
                               :      return typename _Deque_iterator<_Tp, _RefL, _PtrL>::difference_type
                               :	(_Deque_iterator<_Tp, _RefL, _PtrL>::_S_buffer_size())
                               :	* (__x._M_node - __y._M_node - 1) + (__x._M_cur - __x._M_first)
                               :	+ (__y._M_last - __y._M_cur);
                               :    }
                               :
                               :  template<typename _Tp, typename _Ref, typename _Ptr>
                               :    inline _Deque_iterator<_Tp, _Ref, _Ptr>
                               :    operator+(ptrdiff_t __n, const _Deque_iterator<_Tp, _Ref, _Ptr>& __x)
                               :    { return __x + __n; }
                               :
                               :  template<typename _Tp>
                               :    void
                               :    fill(const _Deque_iterator<_Tp, _Tp&, _Tp*>&,
                               :	 const _Deque_iterator<_Tp, _Tp&, _Tp*>&, const _Tp&);
                               :
                               :  template<typename _Tp>
                               :    _Deque_iterator<_Tp, _Tp&, _Tp*>
                               :    copy(_Deque_iterator<_Tp, const _Tp&, const _Tp*>,
                               :	 _Deque_iterator<_Tp, const _Tp&, const _Tp*>,
                               :	 _Deque_iterator<_Tp, _Tp&, _Tp*>);
                               :
                               :  template<typename _Tp>
                               :    inline _Deque_iterator<_Tp, _Tp&, _Tp*>
                               :    copy(_Deque_iterator<_Tp, _Tp&, _Tp*> __first,
                               :	 _Deque_iterator<_Tp, _Tp&, _Tp*> __last,
                               :	 _Deque_iterator<_Tp, _Tp&, _Tp*> __result)
                               :    { return std::copy(_Deque_iterator<_Tp, const _Tp&, const _Tp*>(__first),
                               :		       _Deque_iterator<_Tp, const _Tp&, const _Tp*>(__last),
                               :		       __result); }
                               :
                               :  template<typename _Tp>
                               :    _Deque_iterator<_Tp, _Tp&, _Tp*>
                               :    copy_backward(_Deque_iterator<_Tp, const _Tp&, const _Tp*>,
                               :		  _Deque_iterator<_Tp, const _Tp&, const _Tp*>,
                               :		  _Deque_iterator<_Tp, _Tp&, _Tp*>);
                               :
                               :  template<typename _Tp>
                               :    inline _Deque_iterator<_Tp, _Tp&, _Tp*>
                               :    copy_backward(_Deque_iterator<_Tp, _Tp&, _Tp*> __first,
                               :		  _Deque_iterator<_Tp, _Tp&, _Tp*> __last,
                               :		  _Deque_iterator<_Tp, _Tp&, _Tp*> __result)
                               :    { return std::copy_backward(_Deque_iterator<_Tp,
                               :				const _Tp&, const _Tp*>(__first),
                               :				_Deque_iterator<_Tp,
                               :				const _Tp&, const _Tp*>(__last),
                               :				__result); }
                               :
                               :#if __cplusplus >= 201103L
                               :  template<typename _Tp>
                               :    _Deque_iterator<_Tp, _Tp&, _Tp*>
                               :    move(_Deque_iterator<_Tp, const _Tp&, const _Tp*>,
                               :	 _Deque_iterator<_Tp, const _Tp&, const _Tp*>,
                               :	 _Deque_iterator<_Tp, _Tp&, _Tp*>);
                               :
                               :  template<typename _Tp>
                               :    inline _Deque_iterator<_Tp, _Tp&, _Tp*>
                               :    move(_Deque_iterator<_Tp, _Tp&, _Tp*> __first,
                               :	 _Deque_iterator<_Tp, _Tp&, _Tp*> __last,
                               :	 _Deque_iterator<_Tp, _Tp&, _Tp*> __result)
                               :    { return std::move(_Deque_iterator<_Tp, const _Tp&, const _Tp*>(__first),
                               :		       _Deque_iterator<_Tp, const _Tp&, const _Tp*>(__last),
                               :		       __result); }
                               :
                               :  template<typename _Tp>
                               :    _Deque_iterator<_Tp, _Tp&, _Tp*>
                               :    move_backward(_Deque_iterator<_Tp, const _Tp&, const _Tp*>,
                               :		  _Deque_iterator<_Tp, const _Tp&, const _Tp*>,
                               :		  _Deque_iterator<_Tp, _Tp&, _Tp*>);
                               :
                               :  template<typename _Tp>
                               :    inline _Deque_iterator<_Tp, _Tp&, _Tp*>
                               :    move_backward(_Deque_iterator<_Tp, _Tp&, _Tp*> __first,
                               :		  _Deque_iterator<_Tp, _Tp&, _Tp*> __last,
                               :		  _Deque_iterator<_Tp, _Tp&, _Tp*> __result)
                               :    { return std::move_backward(_Deque_iterator<_Tp,
                               :				const _Tp&, const _Tp*>(__first),
                               :				_Deque_iterator<_Tp,
                               :				const _Tp&, const _Tp*>(__last),
                               :				__result); }
                               :#endif
                               :
                               :  /**
                               :   *  Deque base class.  This class provides the unified face for %deque's
                               :   *  allocation.  This class's constructor and destructor allocate and
                               :   *  deallocate (but do not initialize) storage.  This makes %exception
                               :   *  safety easier.
                               :   *
                               :   *  Nothing in this class ever constructs or destroys an actual Tp element.
                               :   *  (Deque handles that itself.)  Only/All memory management is performed
                               :   *  here.
                               :  */
                               :  template<typename _Tp, typename _Alloc>
                               :    class _Deque_base
                               :    {
                               :    public:
                               :      typedef _Alloc                  allocator_type;
                               :
                               :      allocator_type
                               :      get_allocator() const _GLIBCXX_NOEXCEPT
                               :      { return allocator_type(_M_get_Tp_allocator()); }
                               :
                               :      typedef _Deque_iterator<_Tp, _Tp&, _Tp*>             iterator;
                               :      typedef _Deque_iterator<_Tp, const _Tp&, const _Tp*> const_iterator;
                               :
                               :      _Deque_base()
                               :      : _M_impl()
                               :      { _M_initialize_map(0); }
                               :
                               :      _Deque_base(size_t __num_elements)
                               :      : _M_impl()
                               :      { _M_initialize_map(__num_elements); }
                               :
                               :      _Deque_base(const allocator_type& __a, size_t __num_elements)
                               :      : _M_impl(__a)
                               :      { _M_initialize_map(__num_elements); }
                               :
                               :      _Deque_base(const allocator_type& __a)
                               :      : _M_impl(__a)
                               :      { }
                               :
                               :#if __cplusplus >= 201103L
                               :      _Deque_base(_Deque_base&& __x)
                               :      : _M_impl(std::move(__x._M_get_Tp_allocator()))
                               :      {
                               :	_M_initialize_map(0);
                               :	if (__x._M_impl._M_map)
                               :	  {
                               :	    std::swap(this->_M_impl._M_start, __x._M_impl._M_start);
                               :	    std::swap(this->_M_impl._M_finish, __x._M_impl._M_finish);
                               :	    std::swap(this->_M_impl._M_map, __x._M_impl._M_map);
                               :	    std::swap(this->_M_impl._M_map_size, __x._M_impl._M_map_size);
                               :	  }
                               :      }
                               :#endif
                               :
                               :      ~_Deque_base();
                               :
                               :    protected:
                               :      //This struct encapsulates the implementation of the std::deque
                               :      //standard container and at the same time makes use of the EBO
                               :      //for empty allocators.
                               :      typedef typename _Alloc::template rebind<_Tp*>::other _Map_alloc_type;
                               :
                               :      typedef typename _Alloc::template rebind<_Tp>::other  _Tp_alloc_type;
                               :
                               :      struct _Deque_impl
                               :      : public _Tp_alloc_type
                               :      {
                               :	_Tp** _M_map;
                               :	size_t _M_map_size;
                               :	iterator _M_start;
                               :	iterator _M_finish;
                               :
                               :	_Deque_impl()
                               :	: _Tp_alloc_type(), _M_map(0), _M_map_size(0),
                               :	  _M_start(), _M_finish()
                               :	{ }
                               :
                               :	_Deque_impl(const _Tp_alloc_type& __a)
                               :	: _Tp_alloc_type(__a), _M_map(0), _M_map_size(0),
                               :	  _M_start(), _M_finish()
                               :	{ }
                               :
                               :#if __cplusplus >= 201103L
                               :	_Deque_impl(_Tp_alloc_type&& __a)
                               :	: _Tp_alloc_type(std::move(__a)), _M_map(0), _M_map_size(0),
                               :	  _M_start(), _M_finish()
                               :	{ }
                               :#endif
                               :      };
                               :
                               :      _Tp_alloc_type&
                               :      _M_get_Tp_allocator() _GLIBCXX_NOEXCEPT
                               :      { return *static_cast<_Tp_alloc_type*>(&this->_M_impl); }
                               :
                               :      const _Tp_alloc_type&
                               :      _M_get_Tp_allocator() const _GLIBCXX_NOEXCEPT
                               :      { return *static_cast<const _Tp_alloc_type*>(&this->_M_impl); }
                               :
                               :      _Map_alloc_type
                               :      _M_get_map_allocator() const _GLIBCXX_NOEXCEPT
                               :      { return _Map_alloc_type(_M_get_Tp_allocator()); }
                               :
                               :      _Tp*
                               :      _M_allocate_node()
                               :      { 
                               :	return _M_impl._Tp_alloc_type::allocate(__deque_buf_size(sizeof(_Tp)));
                               :      }
                               :
                               :      void
                               :      _M_deallocate_node(_Tp* __p)
                               :      {
                               :	_M_impl._Tp_alloc_type::deallocate(__p, __deque_buf_size(sizeof(_Tp)));
                               :      }
                               :
                               :      _Tp**
                               :      _M_allocate_map(size_t __n)
                               :      { return _M_get_map_allocator().allocate(__n); }
                               :
                               :      void
                               :      _M_deallocate_map(_Tp** __p, size_t __n)
                               :      { _M_get_map_allocator().deallocate(__p, __n); }
                               :
                               :    protected:
                               :      void _M_initialize_map(size_t);
                               :      void _M_create_nodes(_Tp** __nstart, _Tp** __nfinish);
                               :      void _M_destroy_nodes(_Tp** __nstart, _Tp** __nfinish);
                               :      enum { _S_initial_map_size = 8 };
                               :
                               :      _Deque_impl _M_impl;
                               :    };
                               :
                               :  template<typename _Tp, typename _Alloc>
                               :    _Deque_base<_Tp, _Alloc>::
                               :    ~_Deque_base()
                               :    {
                               :      if (this->_M_impl._M_map)
                               :	{
                               :	  _M_destroy_nodes(this->_M_impl._M_start._M_node,
                               :			   this->_M_impl._M_finish._M_node + 1);
                               :	  _M_deallocate_map(this->_M_impl._M_map, this->_M_impl._M_map_size);
                               :	}
                               :    }
                               :
                               :  /**
                               :   *  @brief Layout storage.
                               :   *  @param  __num_elements  The count of T's for which to allocate space
                               :   *                        at first.
                               :   *  @return   Nothing.
                               :   *
                               :   *  The initial underlying memory layout is a bit complicated...
                               :  */
                               :  template<typename _Tp, typename _Alloc>
                               :    void
                               :    _Deque_base<_Tp, _Alloc>::
                               :    _M_initialize_map(size_t __num_elements)
                               :    {
                               :      const size_t __num_nodes = (__num_elements/ __deque_buf_size(sizeof(_Tp))
                               :				  + 1);
                               :
                               :      this->_M_impl._M_map_size = std::max((size_t) _S_initial_map_size,
                               :					   size_t(__num_nodes + 2));
                               :      this->_M_impl._M_map = _M_allocate_map(this->_M_impl._M_map_size);
                               :
                               :      // For "small" maps (needing less than _M_map_size nodes), allocation
                               :      // starts in the middle elements and grows outwards.  So nstart may be
                               :      // the beginning of _M_map, but for small maps it may be as far in as
                               :      // _M_map+3.
                               :
                               :      _Tp** __nstart = (this->_M_impl._M_map
                               :			+ (this->_M_impl._M_map_size - __num_nodes) / 2);
                               :      _Tp** __nfinish = __nstart + __num_nodes;
                               :
                               :      __try
                               :	{ _M_create_nodes(__nstart, __nfinish); }
                               :      __catch(...)
                               :	{
                               :	  _M_deallocate_map(this->_M_impl._M_map, this->_M_impl._M_map_size);
                               :	  this->_M_impl._M_map = 0;
                               :	  this->_M_impl._M_map_size = 0;
                               :	  __throw_exception_again;
                               :	}
                               :
                               :      this->_M_impl._M_start._M_set_node(__nstart);
                               :      this->_M_impl._M_finish._M_set_node(__nfinish - 1);
                               :      this->_M_impl._M_start._M_cur = _M_impl._M_start._M_first;
                               :      this->_M_impl._M_finish._M_cur = (this->_M_impl._M_finish._M_first
                               :					+ __num_elements
                               :					% __deque_buf_size(sizeof(_Tp)));
                               :    }
                               :
                               :  template<typename _Tp, typename _Alloc>
                               :    void
                               :    _Deque_base<_Tp, _Alloc>::
                               :    _M_create_nodes(_Tp** __nstart, _Tp** __nfinish)
                               :    {
                               :      _Tp** __cur;
                               :      __try
                               :	{
                               :	  for (__cur = __nstart; __cur < __nfinish; ++__cur)
                               :	    *__cur = this->_M_allocate_node();
                               :	}
                               :      __catch(...)
                               :	{
                               :	  _M_destroy_nodes(__nstart, __cur);
                               :	  __throw_exception_again;
                               :	}
                               :    }
                               :
                               :  template<typename _Tp, typename _Alloc>
                               :    void
                               :    _Deque_base<_Tp, _Alloc>::
                               :    _M_destroy_nodes(_Tp** __nstart, _Tp** __nfinish)
                               :    {
                               :      for (_Tp** __n = __nstart; __n < __nfinish; ++__n)
                               :	_M_deallocate_node(*__n);
                               :    }
                               :
                               :  /**
                               :   *  @brief  A standard container using fixed-size memory allocation and
                               :   *  constant-time manipulation of elements at either end.
                               :   *
                               :   *  @ingroup sequences
                               :   *
                               :   *  @tparam _Tp  Type of element.
                               :   *  @tparam _Alloc  Allocator type, defaults to allocator<_Tp>.
                               :   *
                               :   *  Meets the requirements of a <a href="tables.html#65">container</a>, a
                               :   *  <a href="tables.html#66">reversible container</a>, and a
                               :   *  <a href="tables.html#67">sequence</a>, including the
                               :   *  <a href="tables.html#68">optional sequence requirements</a>.
                               :   *
                               :   *  In previous HP/SGI versions of deque, there was an extra template
                               :   *  parameter so users could control the node size.  This extension turned
                               :   *  out to violate the C++ standard (it can be detected using template
                               :   *  template parameters), and it was removed.
                               :   *
                               :   *  Here's how a deque<Tp> manages memory.  Each deque has 4 members:
                               :   *
                               :   *  - Tp**        _M_map
                               :   *  - size_t      _M_map_size
                               :   *  - iterator    _M_start, _M_finish
                               :   *
                               :   *  map_size is at least 8.  %map is an array of map_size
                               :   *  pointers-to-@a nodes.  (The name %map has nothing to do with the
                               :   *  std::map class, and @b nodes should not be confused with
                               :   *  std::list's usage of @a node.)
                               :   *
                               :   *  A @a node has no specific type name as such, but it is referred
                               :   *  to as @a node in this file.  It is a simple array-of-Tp.  If Tp
                               :   *  is very large, there will be one Tp element per node (i.e., an
                               :   *  @a array of one).  For non-huge Tp's, node size is inversely
                               :   *  related to Tp size: the larger the Tp, the fewer Tp's will fit
                               :   *  in a node.  The goal here is to keep the total size of a node
                               :   *  relatively small and constant over different Tp's, to improve
                               :   *  allocator efficiency.
                               :   *
                               :   *  Not every pointer in the %map array will point to a node.  If
                               :   *  the initial number of elements in the deque is small, the
                               :   *  /middle/ %map pointers will be valid, and the ones at the edges
                               :   *  will be unused.  This same situation will arise as the %map
                               :   *  grows: available %map pointers, if any, will be on the ends.  As
                               :   *  new nodes are created, only a subset of the %map's pointers need
                               :   *  to be copied @a outward.
                               :   *
                               :   *  Class invariants:
                               :   * - For any nonsingular iterator i:
                               :   *    - i.node points to a member of the %map array.  (Yes, you read that
                               :   *      correctly:  i.node does not actually point to a node.)  The member of
                               :   *      the %map array is what actually points to the node.
                               :   *    - i.first == *(i.node)    (This points to the node (first Tp element).)
                               :   *    - i.last  == i.first + node_size
                               :   *    - i.cur is a pointer in the range [i.first, i.last).  NOTE:
                               :   *      the implication of this is that i.cur is always a dereferenceable
                               :   *      pointer, even if i is a past-the-end iterator.
                               :   * - Start and Finish are always nonsingular iterators.  NOTE: this
                               :   * means that an empty deque must have one node, a deque with <N
                               :   * elements (where N is the node buffer size) must have one node, a
                               :   * deque with N through (2N-1) elements must have two nodes, etc.
                               :   * - For every node other than start.node and finish.node, every
                               :   * element in the node is an initialized object.  If start.node ==
                               :   * finish.node, then [start.cur, finish.cur) are initialized
                               :   * objects, and the elements outside that range are uninitialized
                               :   * storage.  Otherwise, [start.cur, start.last) and [finish.first,
                               :   * finish.cur) are initialized objects, and [start.first, start.cur)
                               :   * and [finish.cur, finish.last) are uninitialized storage.
                               :   * - [%map, %map + map_size) is a valid, non-empty range.
                               :   * - [start.node, finish.node] is a valid range contained within
                               :   *   [%map, %map + map_size).
                               :   * - A pointer in the range [%map, %map + map_size) points to an allocated
                               :   *   node if and only if the pointer is in the range
                               :   *   [start.node, finish.node].
                               :   *
                               :   *  Here's the magic:  nothing in deque is @b aware of the discontiguous
                               :   *  storage!
                               :   *
                               :   *  The memory setup and layout occurs in the parent, _Base, and the iterator
                               :   *  class is entirely responsible for @a leaping from one node to the next.
                               :   *  All the implementation routines for deque itself work only through the
                               :   *  start and finish iterators.  This keeps the routines simple and sane,
                               :   *  and we can use other standard algorithms as well.
                               :  */
                               :  template<typename _Tp, typename _Alloc = std::allocator<_Tp> >
                               :    class deque : protected _Deque_base<_Tp, _Alloc>
                               :    {
                               :      // concept requirements
                               :      typedef typename _Alloc::value_type        _Alloc_value_type;
                               :      __glibcxx_class_requires(_Tp, _SGIAssignableConcept)
                               :      __glibcxx_class_requires2(_Tp, _Alloc_value_type, _SameTypeConcept)
                               :
                               :      typedef _Deque_base<_Tp, _Alloc>           _Base;
                               :      typedef typename _Base::_Tp_alloc_type	 _Tp_alloc_type;
                               :
                               :    public:
                               :      typedef _Tp                                        value_type;
                               :      typedef typename _Tp_alloc_type::pointer           pointer;
                               :      typedef typename _Tp_alloc_type::const_pointer     const_pointer;
                               :      typedef typename _Tp_alloc_type::reference         reference;
                               :      typedef typename _Tp_alloc_type::const_reference   const_reference;
                               :      typedef typename _Base::iterator                   iterator;
                               :      typedef typename _Base::const_iterator             const_iterator;
                               :      typedef std::reverse_iterator<const_iterator>      const_reverse_iterator;
                               :      typedef std::reverse_iterator<iterator>            reverse_iterator;
                               :      typedef size_t                             size_type;
                               :      typedef ptrdiff_t                          difference_type;
                               :      typedef _Alloc                             allocator_type;
                               :
                               :    protected:
                               :      typedef pointer*                           _Map_pointer;
                               :
                               :      static size_t _S_buffer_size()
                               :      { return __deque_buf_size(sizeof(_Tp)); }
                               :
                               :      // Functions controlling memory layout, and nothing else.
                               :      using _Base::_M_initialize_map;
                               :      using _Base::_M_create_nodes;
                               :      using _Base::_M_destroy_nodes;
                               :      using _Base::_M_allocate_node;
                               :      using _Base::_M_deallocate_node;
                               :      using _Base::_M_allocate_map;
                               :      using _Base::_M_deallocate_map;
                               :      using _Base::_M_get_Tp_allocator;
                               :
                               :      /** 
                               :       *  A total of four data members accumulated down the hierarchy.
                               :       *  May be accessed via _M_impl.*
                               :       */
                               :      using _Base::_M_impl;
                               :
                               :    public:
                               :      // [23.2.1.1] construct/copy/destroy
                               :      // (assign() and get_allocator() are also listed in this section)
                               :      /**
                               :       *  @brief  Default constructor creates no elements.
                               :       */
                               :      deque()
                               :      : _Base() { }
                               :
                               :      /**
                               :       *  @brief  Creates a %deque with no elements.
                               :       *  @param  __a  An allocator object.
                               :       */
                               :      explicit
                               :      deque(const allocator_type& __a)
                               :      : _Base(__a, 0) { }
                               :
                               :#if __cplusplus >= 201103L
                               :      /**
                               :       *  @brief  Creates a %deque with default constructed elements.
                               :       *  @param  __n  The number of elements to initially create.
                               :       *
                               :       *  This constructor fills the %deque with @a n default
                               :       *  constructed elements.
                               :       */
                               :      explicit
                               :      deque(size_type __n)
                               :      : _Base(__n)
                               :      { _M_default_initialize(); }
                               :
                               :      /**
                               :       *  @brief  Creates a %deque with copies of an exemplar element.
                               :       *  @param  __n  The number of elements to initially create.
                               :       *  @param  __value  An element to copy.
                               :       *  @param  __a  An allocator.
                               :       *
                               :       *  This constructor fills the %deque with @a __n copies of @a __value.
                               :       */
                               :      deque(size_type __n, const value_type& __value,
                               :	    const allocator_type& __a = allocator_type())
                               :      : _Base(__a, __n)
                               :      { _M_fill_initialize(__value); }
                               :#else
                               :      /**
                               :       *  @brief  Creates a %deque with copies of an exemplar element.
                               :       *  @param  __n  The number of elements to initially create.
                               :       *  @param  __value  An element to copy.
                               :       *  @param  __a  An allocator.
                               :       *
                               :       *  This constructor fills the %deque with @a __n copies of @a __value.
                               :       */
                               :      explicit
                               :      deque(size_type __n, const value_type& __value = value_type(),
                               :	    const allocator_type& __a = allocator_type())
                               :      : _Base(__a, __n)
                               :      { _M_fill_initialize(__value); }
                               :#endif
                               :
                               :      /**
                               :       *  @brief  %Deque copy constructor.
                               :       *  @param  __x  A %deque of identical element and allocator types.
                               :       *
                               :       *  The newly-created %deque uses a copy of the allocation object used
                               :       *  by @a __x.
                               :       */
                               :      deque(const deque& __x)
                               :      : _Base(__x._M_get_Tp_allocator(), __x.size())
                               :      { std::__uninitialized_copy_a(__x.begin(), __x.end(), 
                               :				    this->_M_impl._M_start,
                               :				    _M_get_Tp_allocator()); }
                               :
                               :#if __cplusplus >= 201103L
                               :      /**
                               :       *  @brief  %Deque move constructor.
                               :       *  @param  __x  A %deque of identical element and allocator types.
                               :       *
                               :       *  The newly-created %deque contains the exact contents of @a __x.
                               :       *  The contents of @a __x are a valid, but unspecified %deque.
                               :       */
                               :      deque(deque&& __x)
                               :      : _Base(std::move(__x)) { }
                               :
                               :      /**
                               :       *  @brief  Builds a %deque from an initializer list.
                               :       *  @param  __l  An initializer_list.
                               :       *  @param  __a  An allocator object.
                               :       *
                               :       *  Create a %deque consisting of copies of the elements in the
                               :       *  initializer_list @a __l.
                               :       *
                               :       *  This will call the element type's copy constructor N times
                               :       *  (where N is __l.size()) and do no memory reallocation.
                               :       */
                               :      deque(initializer_list<value_type> __l,
                               :	    const allocator_type& __a = allocator_type())
                               :      : _Base(__a)
                               :      {
                               :	_M_range_initialize(__l.begin(), __l.end(),
                               :			    random_access_iterator_tag());
                               :      }
                               :#endif
                               :
                               :      /**
                               :       *  @brief  Builds a %deque from a range.
                               :       *  @param  __first  An input iterator.
                               :       *  @param  __last  An input iterator.
                               :       *  @param  __a  An allocator object.
                               :       *
                               :       *  Create a %deque consisting of copies of the elements from [__first,
                               :       *  __last).
                               :       *
                               :       *  If the iterators are forward, bidirectional, or random-access, then
                               :       *  this will call the elements' copy constructor N times (where N is
                               :       *  distance(__first,__last)) and do no memory reallocation.  But if only
                               :       *  input iterators are used, then this will do at most 2N calls to the
                               :       *  copy constructor, and logN memory reallocations.
                               :       */
                               :#if __cplusplus >= 201103L
                               :      template<typename _InputIterator,
                               :	       typename = std::_RequireInputIter<_InputIterator>>
                               :        deque(_InputIterator __first, _InputIterator __last,
                               :	      const allocator_type& __a = allocator_type())
                               :	: _Base(__a)
                               :        { _M_initialize_dispatch(__first, __last, __false_type()); }
                               :#else
                               :      template<typename _InputIterator>
                               :        deque(_InputIterator __first, _InputIterator __last,
                               :	      const allocator_type& __a = allocator_type())
                               :	: _Base(__a)
                               :        {
                               :	  // Check whether it's an integral type.  If so, it's not an iterator.
                               :	  typedef typename std::__is_integer<_InputIterator>::__type _Integral;
                               :	  _M_initialize_dispatch(__first, __last, _Integral());
                               :	}
                               :#endif
                               :
                               :      /**
                               :       *  The dtor only erases the elements, and note that if the elements
                               :       *  themselves are pointers, the pointed-to memory is not touched in any
                               :       *  way.  Managing the pointer is the user's responsibility.
                               :       */
                               :      ~deque() _GLIBCXX_NOEXCEPT
                               :      { _M_destroy_data(begin(), end(), _M_get_Tp_allocator()); }
                               :
                               :      /**
                               :       *  @brief  %Deque assignment operator.
                               :       *  @param  __x  A %deque of identical element and allocator types.
                               :       *
                               :       *  All the elements of @a x are copied, but unlike the copy constructor,
                               :       *  the allocator object is not copied.
                               :       */
                               :      deque&
                               :      operator=(const deque& __x);
                               :
                               :#if __cplusplus >= 201103L
                               :      /**
                               :       *  @brief  %Deque move assignment operator.
                               :       *  @param  __x  A %deque of identical element and allocator types.
                               :       *
                               :       *  The contents of @a __x are moved into this deque (without copying).
                               :       *  @a __x is a valid, but unspecified %deque.
                               :       */
                               :      deque&
                               :      operator=(deque&& __x)
                               :      {
                               :	// NB: DR 1204.
                               :	// NB: DR 675.
                               :	this->clear();
                               :	this->swap(__x);
                               :	return *this;
                               :      }
                               :
                               :      /**
                               :       *  @brief  Assigns an initializer list to a %deque.
                               :       *  @param  __l  An initializer_list.
                               :       *
                               :       *  This function fills a %deque with copies of the elements in the
                               :       *  initializer_list @a __l.
                               :       *
                               :       *  Note that the assignment completely changes the %deque and that the
                               :       *  resulting %deque's size is the same as the number of elements
                               :       *  assigned.  Old data may be lost.
                               :       */
                               :      deque&
                               :      operator=(initializer_list<value_type> __l)
                               :      {
                               :	this->assign(__l.begin(), __l.end());
                               :	return *this;
                               :      }
                               :#endif
                               :
                               :      /**
                               :       *  @brief  Assigns a given value to a %deque.
                               :       *  @param  __n  Number of elements to be assigned.
                               :       *  @param  __val  Value to be assigned.
                               :       *
                               :       *  This function fills a %deque with @a n copies of the given
                               :       *  value.  Note that the assignment completely changes the
                               :       *  %deque and that the resulting %deque's size is the same as
                               :       *  the number of elements assigned.  Old data may be lost.
                               :       */
                               :      void
                               :      assign(size_type __n, const value_type& __val)
                               :      { _M_fill_assign(__n, __val); }
                               :
                               :      /**
                               :       *  @brief  Assigns a range to a %deque.
                               :       *  @param  __first  An input iterator.
                               :       *  @param  __last   An input iterator.
                               :       *
                               :       *  This function fills a %deque with copies of the elements in the
                               :       *  range [__first,__last).
                               :       *
                               :       *  Note that the assignment completely changes the %deque and that the
                               :       *  resulting %deque's size is the same as the number of elements
                               :       *  assigned.  Old data may be lost.
                               :       */
                               :#if __cplusplus >= 201103L
                               :      template<typename _InputIterator,
                               :	       typename = std::_RequireInputIter<_InputIterator>>
                               :        void
                               :        assign(_InputIterator __first, _InputIterator __last)
                               :        { _M_assign_dispatch(__first, __last, __false_type()); }
                               :#else
                               :      template<typename _InputIterator>
                               :        void
                               :        assign(_InputIterator __first, _InputIterator __last)
                               :        {
                               :	  typedef typename std::__is_integer<_InputIterator>::__type _Integral;
                               :	  _M_assign_dispatch(__first, __last, _Integral());
                               :	}
                               :#endif
                               :
                               :#if __cplusplus >= 201103L
                               :      /**
                               :       *  @brief  Assigns an initializer list to a %deque.
                               :       *  @param  __l  An initializer_list.
                               :       *
                               :       *  This function fills a %deque with copies of the elements in the
                               :       *  initializer_list @a __l.
                               :       *
                               :       *  Note that the assignment completely changes the %deque and that the
                               :       *  resulting %deque's size is the same as the number of elements
                               :       *  assigned.  Old data may be lost.
                               :       */
                               :      void
                               :      assign(initializer_list<value_type> __l)
                               :      { this->assign(__l.begin(), __l.end()); }
                               :#endif
                               :
                               :      /// Get a copy of the memory allocation object.
                               :      allocator_type
                               :      get_allocator() const _GLIBCXX_NOEXCEPT
                               :      { return _Base::get_allocator(); }
                               :
                               :      // iterators
                               :      /**
                               :       *  Returns a read/write iterator that points to the first element in the
                               :       *  %deque.  Iteration is done in ordinary element order.
                               :       */
                               :      iterator
                               :      begin() _GLIBCXX_NOEXCEPT
                               :      { return this->_M_impl._M_start; }
                               :
                               :      /**
                               :       *  Returns a read-only (constant) iterator that points to the first
                               :       *  element in the %deque.  Iteration is done in ordinary element order.
                               :       */
                               :      const_iterator
                               :      begin() const _GLIBCXX_NOEXCEPT
                               :      { return this->_M_impl._M_start; }
                               :
                               :      /**
                               :       *  Returns a read/write iterator that points one past the last
                               :       *  element in the %deque.  Iteration is done in ordinary
                               :       *  element order.
                               :       */
                               :      iterator
                               :      end() _GLIBCXX_NOEXCEPT
                               :      { return this->_M_impl._M_finish; }
                               :
                               :      /**
                               :       *  Returns a read-only (constant) iterator that points one past
                               :       *  the last element in the %deque.  Iteration is done in
                               :       *  ordinary element order.
                               :       */
                               :      const_iterator
                               :      end() const _GLIBCXX_NOEXCEPT
                               :      { return this->_M_impl._M_finish; }
                               :
                               :      /**
                               :       *  Returns a read/write reverse iterator that points to the
                               :       *  last element in the %deque.  Iteration is done in reverse
                               :       *  element order.
                               :       */
                               :      reverse_iterator
                               :      rbegin() _GLIBCXX_NOEXCEPT
                               :      { return reverse_iterator(this->_M_impl._M_finish); }
                               :
                               :      /**
                               :       *  Returns a read-only (constant) reverse iterator that points
                               :       *  to the last element in the %deque.  Iteration is done in
                               :       *  reverse element order.
                               :       */
                               :      const_reverse_iterator
                               :      rbegin() const _GLIBCXX_NOEXCEPT
                               :      { return const_reverse_iterator(this->_M_impl._M_finish); }
                               :
                               :      /**
                               :       *  Returns a read/write reverse iterator that points to one
                               :       *  before the first element in the %deque.  Iteration is done
                               :       *  in reverse element order.
                               :       */
                               :      reverse_iterator
                               :      rend() _GLIBCXX_NOEXCEPT
                               :      { return reverse_iterator(this->_M_impl._M_start); }
                               :
                               :      /**
                               :       *  Returns a read-only (constant) reverse iterator that points
                               :       *  to one before the first element in the %deque.  Iteration is
                               :       *  done in reverse element order.
                               :       */
                               :      const_reverse_iterator
                               :      rend() const _GLIBCXX_NOEXCEPT
                               :      { return const_reverse_iterator(this->_M_impl._M_start); }
                               :
                               :#if __cplusplus >= 201103L
                               :      /**
                               :       *  Returns a read-only (constant) iterator that points to the first
                               :       *  element in the %deque.  Iteration is done in ordinary element order.
                               :       */
                               :      const_iterator
                               :      cbegin() const noexcept
                               :      { return this->_M_impl._M_start; }
                               :
                               :      /**
                               :       *  Returns a read-only (constant) iterator that points one past
                               :       *  the last element in the %deque.  Iteration is done in
                               :       *  ordinary element order.
                               :       */
                               :      const_iterator
                               :      cend() const noexcept
                               :      { return this->_M_impl._M_finish; }
                               :
                               :      /**
                               :       *  Returns a read-only (constant) reverse iterator that points
                               :       *  to the last element in the %deque.  Iteration is done in
                               :       *  reverse element order.
                               :       */
                               :      const_reverse_iterator
                               :      crbegin() const noexcept
                               :      { return const_reverse_iterator(this->_M_impl._M_finish); }
                               :
                               :      /**
                               :       *  Returns a read-only (constant) reverse iterator that points
                               :       *  to one before the first element in the %deque.  Iteration is
                               :       *  done in reverse element order.
                               :       */
                               :      const_reverse_iterator
                               :      crend() const noexcept
                               :      { return const_reverse_iterator(this->_M_impl._M_start); }
                               :#endif
                               :
                               :      // [23.2.1.2] capacity
                               :      /**  Returns the number of elements in the %deque.  */
                               :      size_type
                               :      size() const _GLIBCXX_NOEXCEPT
                               :      { return this->_M_impl._M_finish - this->_M_impl._M_start; }
                               :
                               :      /**  Returns the size() of the largest possible %deque.  */
                               :      size_type
                               :      max_size() const _GLIBCXX_NOEXCEPT
                               :      { return _M_get_Tp_allocator().max_size(); }
                               :
                               :#if __cplusplus >= 201103L
                               :      /**
                               :       *  @brief  Resizes the %deque to the specified number of elements.
                               :       *  @param  __new_size  Number of elements the %deque should contain.
                               :       *
                               :       *  This function will %resize the %deque to the specified
                               :       *  number of elements.  If the number is smaller than the
                               :       *  %deque's current size the %deque is truncated, otherwise
                               :       *  default constructed elements are appended.
                               :       */
                               :      void
                               :      resize(size_type __new_size)
                               :      {
                               :	const size_type __len = size();
                               :	if (__new_size > __len)
                               :	  _M_default_append(__new_size - __len);
                               :	else if (__new_size < __len)
                               :	  _M_erase_at_end(this->_M_impl._M_start
                               :			  + difference_type(__new_size));
                               :      }
                               :
                               :      /**
                               :       *  @brief  Resizes the %deque to the specified number of elements.
                               :       *  @param  __new_size  Number of elements the %deque should contain.
                               :       *  @param  __x  Data with which new elements should be populated.
                               :       *
                               :       *  This function will %resize the %deque to the specified
                               :       *  number of elements.  If the number is smaller than the
                               :       *  %deque's current size the %deque is truncated, otherwise the
                               :       *  %deque is extended and new elements are populated with given
                               :       *  data.
                               :       */
                               :      void
                               :      resize(size_type __new_size, const value_type& __x)
                               :      {
                               :	const size_type __len = size();
                               :	if (__new_size > __len)
                               :	  insert(this->_M_impl._M_finish, __new_size - __len, __x);
                               :	else if (__new_size < __len)
                               :	  _M_erase_at_end(this->_M_impl._M_start
                               :			  + difference_type(__new_size));
                               :      }
                               :#else
                               :      /**
                               :       *  @brief  Resizes the %deque to the specified number of elements.
                               :       *  @param  __new_size  Number of elements the %deque should contain.
                               :       *  @param  __x  Data with which new elements should be populated.
                               :       *
                               :       *  This function will %resize the %deque to the specified
                               :       *  number of elements.  If the number is smaller than the
                               :       *  %deque's current size the %deque is truncated, otherwise the
                               :       *  %deque is extended and new elements are populated with given
                               :       *  data.
                               :       */
                               :      void
                               :      resize(size_type __new_size, value_type __x = value_type())
                               :      {
                               :	const size_type __len = size();
                               :	if (__new_size > __len)
                               :	  insert(this->_M_impl._M_finish, __new_size - __len, __x);
                               :	else if (__new_size < __len)
                               :	  _M_erase_at_end(this->_M_impl._M_start
                               :			  + difference_type(__new_size));
                               :      }
                               :#endif
                               :
                               :#if __cplusplus >= 201103L
                               :      /**  A non-binding request to reduce memory use.  */
                               :      void
                               :      shrink_to_fit()
                               :      { _M_shrink_to_fit(); }
                               :#endif
                               :
                               :      /**
                               :       *  Returns true if the %deque is empty.  (Thus begin() would
                               :       *  equal end().)
                               :       */
                               :      bool
                               :      empty() const _GLIBCXX_NOEXCEPT
                               :      { return this->_M_impl._M_finish == this->_M_impl._M_start; }
                               :
                               :      // element access
                               :      /**
                               :       *  @brief Subscript access to the data contained in the %deque.
                               :       *  @param __n The index of the element for which data should be
                               :       *  accessed.
                               :       *  @return  Read/write reference to data.
                               :       *
                               :       *  This operator allows for easy, array-style, data access.
                               :       *  Note that data access with this operator is unchecked and
                               :       *  out_of_range lookups are not defined. (For checked lookups
                               :       *  see at().)
                               :       */
                               :      reference
                               :      operator[](size_type __n)
                               :      { return this->_M_impl._M_start[difference_type(__n)]; }
                               :
                               :      /**
                               :       *  @brief Subscript access to the data contained in the %deque.
                               :       *  @param __n The index of the element for which data should be
                               :       *  accessed.
                               :       *  @return  Read-only (constant) reference to data.
                               :       *
                               :       *  This operator allows for easy, array-style, data access.
                               :       *  Note that data access with this operator is unchecked and
                               :       *  out_of_range lookups are not defined. (For checked lookups
                               :       *  see at().)
                               :       */
                               :      const_reference
                               :      operator[](size_type __n) const
                               :      { return this->_M_impl._M_start[difference_type(__n)]; }
                               :
                               :    protected:
                               :      /// Safety check used only from at().
                               :      void
                               :      _M_range_check(size_type __n) const
                               :      {
                               :	if (__n >= this->size())
                               :	  __throw_out_of_range(__N("deque::_M_range_check"));
                               :      }
                               :
                               :    public:
                               :      /**
                               :       *  @brief  Provides access to the data contained in the %deque.
                               :       *  @param __n The index of the element for which data should be
                               :       *  accessed.
                               :       *  @return  Read/write reference to data.
                               :       *  @throw  std::out_of_range  If @a __n is an invalid index.
                               :       *
                               :       *  This function provides for safer data access.  The parameter
                               :       *  is first checked that it is in the range of the deque.  The
                               :       *  function throws out_of_range if the check fails.
                               :       */
                               :      reference
                               :      at(size_type __n)
                               :      {
                               :	_M_range_check(__n);
                               :	return (*this)[__n];
                               :      }
                               :
                               :      /**
                               :       *  @brief  Provides access to the data contained in the %deque.
                               :       *  @param __n The index of the element for which data should be
                               :       *  accessed.
                               :       *  @return  Read-only (constant) reference to data.
                               :       *  @throw  std::out_of_range  If @a __n is an invalid index.
                               :       *
                               :       *  This function provides for safer data access.  The parameter is first
                               :       *  checked that it is in the range of the deque.  The function throws
                               :       *  out_of_range if the check fails.
                               :       */
                               :      const_reference
                               :      at(size_type __n) const
                               :      {
                               :	_M_range_check(__n);
                               :	return (*this)[__n];
                               :      }
                               :
                               :      /**
                               :       *  Returns a read/write reference to the data at the first
                               :       *  element of the %deque.
                               :       */
                               :      reference
                               :      front()
                               :      { return *begin(); }
                               :
                               :      /**
                               :       *  Returns a read-only (constant) reference to the data at the first
                               :       *  element of the %deque.
                               :       */
                               :      const_reference
                               :      front() const
                               :      { return *begin(); }
                               :
                               :      /**
                               :       *  Returns a read/write reference to the data at the last element of the
                               :       *  %deque.
                               :       */
                               :      reference
                               :      back()
                               :      {
                               :	iterator __tmp = end();
                               :	--__tmp;
                               :	return *__tmp;
                               :      }
                               :
                               :      /**
                               :       *  Returns a read-only (constant) reference to the data at the last
                               :       *  element of the %deque.
                               :       */
                               :      const_reference
                               :      back() const
                               :      {
                               :	const_iterator __tmp = end();
                               :	--__tmp;
                               :	return *__tmp;
                               :      }
                               :
                               :      // [23.2.1.2] modifiers
                               :      /**
                               :       *  @brief  Add data to the front of the %deque.
                               :       *  @param  __x  Data to be added.
                               :       *
                               :       *  This is a typical stack operation.  The function creates an
                               :       *  element at the front of the %deque and assigns the given
                               :       *  data to it.  Due to the nature of a %deque this operation
                               :       *  can be done in constant time.
                               :       */
                               :      void
                               :      push_front(const value_type& __x)
                               :      {
                               :	if (this->_M_impl._M_start._M_cur != this->_M_impl._M_start._M_first)
                               :	  {
                               :	    this->_M_impl.construct(this->_M_impl._M_start._M_cur - 1, __x);
                               :	    --this->_M_impl._M_start._M_cur;
                               :	  }
                               :	else
                               :	  _M_push_front_aux(__x);
                               :      }
                               :
                               :#if __cplusplus >= 201103L
                               :      void
                               :      push_front(value_type&& __x)
                               :      { emplace_front(std::move(__x)); }
                               :
                               :      template<typename... _Args>
                               :        void
                               :        emplace_front(_Args&&... __args);
                               :#endif
                               :
                               :      /**
                               :       *  @brief  Add data to the end of the %deque.
                               :       *  @param  __x  Data to be added.
                               :       *
                               :       *  This is a typical stack operation.  The function creates an
                               :       *  element at the end of the %deque and assigns the given data
                               :       *  to it.  Due to the nature of a %deque this operation can be
                               :       *  done in constant time.
                               :       */
                               :      void
                               :      push_back(const value_type& __x)
                               :      {
                               :	if (this->_M_impl._M_finish._M_cur
    21  0.0179     0       0   :	    != this->_M_impl._M_finish._M_last - 1)
                               :	  {
                               :	    this->_M_impl.construct(this->_M_impl._M_finish._M_cur, __x);
    32  0.0272     0       0   :	    ++this->_M_impl._M_finish._M_cur;
                               :	  }
                               :	else
                               :	  _M_push_back_aux(__x);
                               :      }
                               :
                               :#if __cplusplus >= 201103L
                               :      void
                               :      push_back(value_type&& __x)
                               :      { emplace_back(std::move(__x)); }
                               :
                               :      template<typename... _Args>
                               :        void
                               :        emplace_back(_Args&&... __args);
                               :#endif
                               :
                               :      /**
                               :       *  @brief  Removes first element.
                               :       *
                               :       *  This is a typical stack operation.  It shrinks the %deque by one.
                               :       *
                               :       *  Note that no data is returned, and if the first element's data is
                               :       *  needed, it should be retrieved before pop_front() is called.
                               :       */
                               :      void
                               :      pop_front()
                               :      {
     3  0.0026     0       0   :	if (this->_M_impl._M_start._M_cur
    21  0.0179     0       0   :	    != this->_M_impl._M_start._M_last - 1)
                               :	  {
                               :	    this->_M_impl.destroy(this->_M_impl._M_start._M_cur);
     8  0.0068     0       0   :	    ++this->_M_impl._M_start._M_cur;
                               :	  }
                               :	else
                               :	  _M_pop_front_aux();
                               :      }
                               :
                               :      /**
                               :       *  @brief  Removes last element.
                               :       *
                               :       *  This is a typical stack operation.  It shrinks the %deque by one.
                               :       *
                               :       *  Note that no data is returned, and if the last element's data is
                               :       *  needed, it should be retrieved before pop_back() is called.
                               :       */
                               :      void
                               :      pop_back()
                               :      {
                               :	if (this->_M_impl._M_finish._M_cur
                               :	    != this->_M_impl._M_finish._M_first)
                               :	  {
                               :	    --this->_M_impl._M_finish._M_cur;
                               :	    this->_M_impl.destroy(this->_M_impl._M_finish._M_cur);
                               :	  }
                               :	else
                               :	  _M_pop_back_aux();
                               :      }
                               :
                               :#if __cplusplus >= 201103L
                               :      /**
                               :       *  @brief  Inserts an object in %deque before specified iterator.
                               :       *  @param  __position  An iterator into the %deque.
                               :       *  @param  __args  Arguments.
                               :       *  @return  An iterator that points to the inserted data.
                               :       *
                               :       *  This function will insert an object of type T constructed
                               :       *  with T(std::forward<Args>(args)...) before the specified location.
                               :       */
                               :      template<typename... _Args>
                               :        iterator
                               :        emplace(iterator __position, _Args&&... __args);
                               :#endif
                               :
                               :      /**
                               :       *  @brief  Inserts given value into %deque before specified iterator.
                               :       *  @param  __position  An iterator into the %deque.
                               :       *  @param  __x  Data to be inserted.
                               :       *  @return  An iterator that points to the inserted data.
                               :       *
                               :       *  This function will insert a copy of the given value before the
                               :       *  specified location.
                               :       */
                               :      iterator
                               :      insert(iterator __position, const value_type& __x);
                               :
                               :#if __cplusplus >= 201103L
                               :      /**
                               :       *  @brief  Inserts given rvalue into %deque before specified iterator.
                               :       *  @param  __position  An iterator into the %deque.
                               :       *  @param  __x  Data to be inserted.
                               :       *  @return  An iterator that points to the inserted data.
                               :       *
                               :       *  This function will insert a copy of the given rvalue before the
                               :       *  specified location.
                               :       */
                               :      iterator
                               :      insert(iterator __position, value_type&& __x)
                               :      { return emplace(__position, std::move(__x)); }
                               :
                               :      /**
                               :       *  @brief  Inserts an initializer list into the %deque.
                               :       *  @param  __p  An iterator into the %deque.
                               :       *  @param  __l  An initializer_list.
                               :       *
                               :       *  This function will insert copies of the data in the
                               :       *  initializer_list @a __l into the %deque before the location
                               :       *  specified by @a __p.  This is known as <em>list insert</em>.
                               :       */
                               :      void
                               :      insert(iterator __p, initializer_list<value_type> __l)
                               :      { this->insert(__p, __l.begin(), __l.end()); }
                               :#endif
                               :
                               :      /**
                               :       *  @brief  Inserts a number of copies of given data into the %deque.
                               :       *  @param  __position  An iterator into the %deque.
                               :       *  @param  __n  Number of elements to be inserted.
                               :       *  @param  __x  Data to be inserted.
                               :       *
                               :       *  This function will insert a specified number of copies of the given
                               :       *  data before the location specified by @a __position.
                               :       */
                               :      void
                               :      insert(iterator __position, size_type __n, const value_type& __x)
                               :      { _M_fill_insert(__position, __n, __x); }
                               :
                               :      /**
                               :       *  @brief  Inserts a range into the %deque.
                               :       *  @param  __position  An iterator into the %deque.
                               :       *  @param  __first  An input iterator.
                               :       *  @param  __last   An input iterator.
                               :       *
                               :       *  This function will insert copies of the data in the range
                               :       *  [__first,__last) into the %deque before the location specified
                               :       *  by @a __position.  This is known as <em>range insert</em>.
                               :       */
                               :#if __cplusplus >= 201103L
                               :      template<typename _InputIterator,
                               :	       typename = std::_RequireInputIter<_InputIterator>>
                               :        void
                               :        insert(iterator __position, _InputIterator __first,
                               :	       _InputIterator __last)
                               :        { _M_insert_dispatch(__position, __first, __last, __false_type()); }
                               :#else
                               :      template<typename _InputIterator>
                               :        void
                               :        insert(iterator __position, _InputIterator __first,
                               :	       _InputIterator __last)
                               :        {
                               :	  // Check whether it's an integral type.  If so, it's not an iterator.
                               :	  typedef typename std::__is_integer<_InputIterator>::__type _Integral;
                               :	  _M_insert_dispatch(__position, __first, __last, _Integral());
                               :	}
                               :#endif
                               :
                               :      /**
                               :       *  @brief  Remove element at given position.
                               :       *  @param  __position  Iterator pointing to element to be erased.
                               :       *  @return  An iterator pointing to the next element (or end()).
                               :       *
                               :       *  This function will erase the element at the given position and thus
                               :       *  shorten the %deque by one.
                               :       *
                               :       *  The user is cautioned that
                               :       *  this function only erases the element, and that if the element is
                               :       *  itself a pointer, the pointed-to memory is not touched in any way.
                               :       *  Managing the pointer is the user's responsibility.
                               :       */
                               :      iterator
                               :      erase(iterator __position);
                               :
                               :      /**
                               :       *  @brief  Remove a range of elements.
                               :       *  @param  __first  Iterator pointing to the first element to be erased.
                               :       *  @param  __last  Iterator pointing to one past the last element to be
                               :       *                erased.
                               :       *  @return  An iterator pointing to the element pointed to by @a last
                               :       *           prior to erasing (or end()).
                               :       *
                               :       *  This function will erase the elements in the range
                               :       *  [__first,__last) and shorten the %deque accordingly.
                               :       *
                               :       *  The user is cautioned that
                               :       *  this function only erases the elements, and that if the elements
                               :       *  themselves are pointers, the pointed-to memory is not touched in any
                               :       *  way.  Managing the pointer is the user's responsibility.
                               :       */
                               :      iterator
                               :      erase(iterator __first, iterator __last);
                               :
                               :      /**
                               :       *  @brief  Swaps data with another %deque.
                               :       *  @param  __x  A %deque of the same element and allocator types.
                               :       *
                               :       *  This exchanges the elements between two deques in constant time.
                               :       *  (Four pointers, so it should be quite fast.)
                               :       *  Note that the global std::swap() function is specialized such that
                               :       *  std::swap(d1,d2) will feed to this function.
                               :       */
                               :      void
                               :      swap(deque& __x)
                               :      {
                               :	std::swap(this->_M_impl._M_start, __x._M_impl._M_start);
                               :	std::swap(this->_M_impl._M_finish, __x._M_impl._M_finish);
                               :	std::swap(this->_M_impl._M_map, __x._M_impl._M_map);
                               :	std::swap(this->_M_impl._M_map_size, __x._M_impl._M_map_size);
                               :
                               :	// _GLIBCXX_RESOLVE_LIB_DEFECTS
                               :	// 431. Swapping containers with unequal allocators.
                               :	std::__alloc_swap<_Tp_alloc_type>::_S_do_it(_M_get_Tp_allocator(),
                               :						    __x._M_get_Tp_allocator());
                               :      }
                               :
                               :      /**
                               :       *  Erases all the elements.  Note that this function only erases the
                               :       *  elements, and that if the elements themselves are pointers, the
                               :       *  pointed-to memory is not touched in any way.  Managing the pointer is
                               :       *  the user's responsibility.
                               :       */
                               :      void
                               :      clear() _GLIBCXX_NOEXCEPT
                               :      { _M_erase_at_end(begin()); }
                               :
                               :    protected:
                               :      // Internal constructor functions follow.
                               :
                               :      // called by the range constructor to implement [23.1.1]/9
                               :
                               :      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                               :      // 438. Ambiguity in the "do the right thing" clause
                               :      template<typename _Integer>
                               :        void
                               :        _M_initialize_dispatch(_Integer __n, _Integer __x, __true_type)
                               :        {
                               :	  _M_initialize_map(static_cast<size_type>(__n));
                               :	  _M_fill_initialize(__x);
                               :	}
                               :
                               :      // called by the range constructor to implement [23.1.1]/9
                               :      template<typename _InputIterator>
                               :        void
                               :        _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
                               :			       __false_type)
                               :        {
                               :	  typedef typename std::iterator_traits<_InputIterator>::
                               :	    iterator_category _IterCategory;
                               :	  _M_range_initialize(__first, __last, _IterCategory());
                               :	}
                               :
                               :      // called by the second initialize_dispatch above
                               :      //@{
                               :      /**
                               :       *  @brief Fills the deque with whatever is in [first,last).
                               :       *  @param  __first  An input iterator.
                               :       *  @param  __last  An input iterator.
                               :       *  @return   Nothing.
                               :       *
                               :       *  If the iterators are actually forward iterators (or better), then the
                               :       *  memory layout can be done all at once.  Else we move forward using
                               :       *  push_back on each value from the iterator.
                               :       */
                               :      template<typename _InputIterator>
                               :        void
                               :        _M_range_initialize(_InputIterator __first, _InputIterator __last,
                               :			    std::input_iterator_tag);
                               :
                               :      // called by the second initialize_dispatch above
                               :      template<typename _ForwardIterator>
                               :        void
                               :        _M_range_initialize(_ForwardIterator __first, _ForwardIterator __last,
                               :			    std::forward_iterator_tag);
                               :      //@}
                               :
                               :      /**
                               :       *  @brief Fills the %deque with copies of value.
                               :       *  @param  __value  Initial value.
                               :       *  @return   Nothing.
                               :       *  @pre _M_start and _M_finish have already been initialized,
                               :       *  but none of the %deque's elements have yet been constructed.
                               :       *
                               :       *  This function is called only when the user provides an explicit size
                               :       *  (with or without an explicit exemplar value).
                               :       */
                               :      void
                               :      _M_fill_initialize(const value_type& __value);
                               :
                               :#if __cplusplus >= 201103L
                               :      // called by deque(n).
                               :      void
                               :      _M_default_initialize();
                               :#endif
                               :
                               :      // Internal assign functions follow.  The *_aux functions do the actual
                               :      // assignment work for the range versions.
                               :
                               :      // called by the range assign to implement [23.1.1]/9
                               :
                               :      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                               :      // 438. Ambiguity in the "do the right thing" clause
                               :      template<typename _Integer>
                               :        void
                               :        _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
                               :        { _M_fill_assign(__n, __val); }
                               :
                               :      // called by the range assign to implement [23.1.1]/9
                               :      template<typename _InputIterator>
                               :        void
                               :        _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
                               :			   __false_type)
                               :        {
                               :	  typedef typename std::iterator_traits<_InputIterator>::
                               :	    iterator_category _IterCategory;
                               :	  _M_assign_aux(__first, __last, _IterCategory());
                               :	}
                               :
                               :      // called by the second assign_dispatch above
                               :      template<typename _InputIterator>
                               :        void
                               :        _M_assign_aux(_InputIterator __first, _InputIterator __last,
                               :		      std::input_iterator_tag);
                               :
                               :      // called by the second assign_dispatch above
                               :      template<typename _ForwardIterator>
                               :        void
                               :        _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
                               :		      std::forward_iterator_tag)
                               :        {
                               :	  const size_type __len = std::distance(__first, __last);
                               :	  if (__len > size())
                               :	    {
                               :	      _ForwardIterator __mid = __first;
                               :	      std::advance(__mid, size());
                               :	      std::copy(__first, __mid, begin());
                               :	      insert(end(), __mid, __last);
                               :	    }
                               :	  else
                               :	    _M_erase_at_end(std::copy(__first, __last, begin()));
                               :	}
                               :
                               :      // Called by assign(n,t), and the range assign when it turns out
                               :      // to be the same thing.
                               :      void
                               :      _M_fill_assign(size_type __n, const value_type& __val)
                               :      {
                               :	if (__n > size())
                               :	  {
                               :	    std::fill(begin(), end(), __val);
                               :	    insert(end(), __n - size(), __val);
                               :	  }
                               :	else
                               :	  {
                               :	    _M_erase_at_end(begin() + difference_type(__n));
                               :	    std::fill(begin(), end(), __val);
                               :	  }
                               :      }
                               :
                               :      //@{
                               :      /// Helper functions for push_* and pop_*.
                               :#if __cplusplus < 201103L
                               :      void _M_push_back_aux(const value_type&);
                               :
                               :      void _M_push_front_aux(const value_type&);
                               :#else
                               :      template<typename... _Args>
                               :        void _M_push_back_aux(_Args&&... __args);
                               :
                               :      template<typename... _Args>
                               :        void _M_push_front_aux(_Args&&... __args);
                               :#endif
                               :
                               :      void _M_pop_back_aux();
                               :
                               :      void _M_pop_front_aux();
                               :      //@}
                               :
                               :      // Internal insert functions follow.  The *_aux functions do the actual
                               :      // insertion work when all shortcuts fail.
                               :
                               :      // called by the range insert to implement [23.1.1]/9
                               :
                               :      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                               :      // 438. Ambiguity in the "do the right thing" clause
                               :      template<typename _Integer>
                               :        void
                               :        _M_insert_dispatch(iterator __pos,
                               :			   _Integer __n, _Integer __x, __true_type)
                               :        { _M_fill_insert(__pos, __n, __x); }
                               :
                               :      // called by the range insert to implement [23.1.1]/9
                               :      template<typename _InputIterator>
                               :        void
                               :        _M_insert_dispatch(iterator __pos,
                               :			   _InputIterator __first, _InputIterator __last,
                               :			   __false_type)
                               :        {
                               :	  typedef typename std::iterator_traits<_InputIterator>::
                               :	    iterator_category _IterCategory;
                               :          _M_range_insert_aux(__pos, __first, __last, _IterCategory());
                               :	}
                               :
                               :      // called by the second insert_dispatch above
                               :      template<typename _InputIterator>
                               :        void
                               :        _M_range_insert_aux(iterator __pos, _InputIterator __first,
                               :			    _InputIterator __last, std::input_iterator_tag);
                               :
                               :      // called by the second insert_dispatch above
                               :      template<typename _ForwardIterator>
                               :        void
                               :        _M_range_insert_aux(iterator __pos, _ForwardIterator __first,
                               :			    _ForwardIterator __last, std::forward_iterator_tag);
                               :
                               :      // Called by insert(p,n,x), and the range insert when it turns out to be
                               :      // the same thing.  Can use fill functions in optimal situations,
                               :      // otherwise passes off to insert_aux(p,n,x).
                               :      void
                               :      _M_fill_insert(iterator __pos, size_type __n, const value_type& __x);
                               :
                               :      // called by insert(p,x)
                               :#if __cplusplus < 201103L
                               :      iterator
                               :      _M_insert_aux(iterator __pos, const value_type& __x);
                               :#else
                               :      template<typename... _Args>
                               :        iterator
                               :        _M_insert_aux(iterator __pos, _Args&&... __args);
                               :#endif
                               :
                               :      // called by insert(p,n,x) via fill_insert
                               :      void
                               :      _M_insert_aux(iterator __pos, size_type __n, const value_type& __x);
                               :
                               :      // called by range_insert_aux for forward iterators
                               :      template<typename _ForwardIterator>
                               :        void
                               :        _M_insert_aux(iterator __pos,
                               :		      _ForwardIterator __first, _ForwardIterator __last,
                               :		      size_type __n);
                               :
                               :
                               :      // Internal erase functions follow.
                               :
                               :      void
                               :      _M_destroy_data_aux(iterator __first, iterator __last);
                               :
                               :      // Called by ~deque().
                               :      // NB: Doesn't deallocate the nodes.
                               :      template<typename _Alloc1>
                               :        void
                               :        _M_destroy_data(iterator __first, iterator __last, const _Alloc1&)
                               :        { _M_destroy_data_aux(__first, __last); }
                               :
                               :      void
                               :      _M_destroy_data(iterator __first, iterator __last,
                               :		      const std::allocator<_Tp>&)
                               :      {
                               :	if (!__has_trivial_destructor(value_type))
                               :	  _M_destroy_data_aux(__first, __last);
                               :      }
                               :
                               :      // Called by erase(q1, q2).
                               :      void
                               :      _M_erase_at_begin(iterator __pos)
                               :      {
                               :	_M_destroy_data(begin(), __pos, _M_get_Tp_allocator());
                               :	_M_destroy_nodes(this->_M_impl._M_start._M_node, __pos._M_node);
                               :	this->_M_impl._M_start = __pos;
                               :      }
                               :
                               :      // Called by erase(q1, q2), resize(), clear(), _M_assign_aux,
                               :      // _M_fill_assign, operator=.
                               :      void
                               :      _M_erase_at_end(iterator __pos)
                               :      {
                               :	_M_destroy_data(__pos, end(), _M_get_Tp_allocator());
                               :	_M_destroy_nodes(__pos._M_node + 1,
                               :			 this->_M_impl._M_finish._M_node + 1);
                               :	this->_M_impl._M_finish = __pos;
                               :      }
                               :
                               :#if __cplusplus >= 201103L
                               :      // Called by resize(sz).
                               :      void
                               :      _M_default_append(size_type __n);
                               :
                               :      bool
                               :      _M_shrink_to_fit();
                               :#endif
                               :
                               :      //@{
                               :      /// Memory-handling helpers for the previous internal insert functions.
                               :      iterator
                               :      _M_reserve_elements_at_front(size_type __n)
                               :      {
                               :	const size_type __vacancies = this->_M_impl._M_start._M_cur
                               :	                              - this->_M_impl._M_start._M_first;
                               :	if (__n > __vacancies)
                               :	  _M_new_elements_at_front(__n - __vacancies);
                               :	return this->_M_impl._M_start - difference_type(__n);
                               :      }
                               :
                               :      iterator
                               :      _M_reserve_elements_at_back(size_type __n)
                               :      {
                               :	const size_type __vacancies = (this->_M_impl._M_finish._M_last
                               :				       - this->_M_impl._M_finish._M_cur) - 1;
                               :	if (__n > __vacancies)
                               :	  _M_new_elements_at_back(__n - __vacancies);
                               :	return this->_M_impl._M_finish + difference_type(__n);
                               :      }
                               :
                               :      void
                               :      _M_new_elements_at_front(size_type __new_elements);
                               :
                               :      void
                               :      _M_new_elements_at_back(size_type __new_elements);
                               :      //@}
                               :
                               :
                               :      //@{
                               :      /**
                               :       *  @brief Memory-handling helpers for the major %map.
                               :       *
                               :       *  Makes sure the _M_map has space for new nodes.  Does not
                               :       *  actually add the nodes.  Can invalidate _M_map pointers.
                               :       *  (And consequently, %deque iterators.)
                               :       */
                               :      void
                               :      _M_reserve_map_at_back(size_type __nodes_to_add = 1)
                               :      {
                               :	if (__nodes_to_add + 1 > this->_M_impl._M_map_size
                               :	    - (this->_M_impl._M_finish._M_node - this->_M_impl._M_map))
                               :	  _M_reallocate_map(__nodes_to_add, false);
                               :      }
                               :
                               :      void
                               :      _M_reserve_map_at_front(size_type __nodes_to_add = 1)
                               :      {
                               :	if (__nodes_to_add > size_type(this->_M_impl._M_start._M_node
                               :				       - this->_M_impl._M_map))
                               :	  _M_reallocate_map(__nodes_to_add, true);
                               :      }
                               :
                               :      void
                               :      _M_reallocate_map(size_type __nodes_to_add, bool __add_at_front);
                               :      //@}
                               :    };
                               :
                               :
                               :  /**
                               :   *  @brief  Deque equality comparison.
                               :   *  @param  __x  A %deque.
                               :   *  @param  __y  A %deque of the same type as @a __x.
                               :   *  @return  True iff the size and elements of the deques are equal.
                               :   *
                               :   *  This is an equivalence relation.  It is linear in the size of the
                               :   *  deques.  Deques are considered equivalent if their sizes are equal,
                               :   *  and if corresponding elements compare equal.
                               :  */
                               :  template<typename _Tp, typename _Alloc>
                               :    inline bool
                               :    operator==(const deque<_Tp, _Alloc>& __x,
                               :                         const deque<_Tp, _Alloc>& __y)
                               :    { return __x.size() == __y.size()
                               :             && std::equal(__x.begin(), __x.end(), __y.begin()); }
                               :
                               :  /**
                               :   *  @brief  Deque ordering relation.
                               :   *  @param  __x  A %deque.
                               :   *  @param  __y  A %deque of the same type as @a __x.
                               :   *  @return  True iff @a x is lexicographically less than @a __y.
                               :   *
                               :   *  This is a total ordering relation.  It is linear in the size of the
                               :   *  deques.  The elements must be comparable with @c <.
                               :   *
                               :   *  See std::lexicographical_compare() for how the determination is made.
                               :  */
                               :  template<typename _Tp, typename _Alloc>
                               :    inline bool
                               :    operator<(const deque<_Tp, _Alloc>& __x,
                               :	      const deque<_Tp, _Alloc>& __y)
                               :    { return std::lexicographical_compare(__x.begin(), __x.end(),
                               :					  __y.begin(), __y.end()); }
                               :
                               :  /// Based on operator==
                               :  template<typename _Tp, typename _Alloc>
                               :    inline bool
                               :    operator!=(const deque<_Tp, _Alloc>& __x,
                               :	       const deque<_Tp, _Alloc>& __y)
                               :    { return !(__x == __y); }
                               :
                               :  /// Based on operator<
                               :  template<typename _Tp, typename _Alloc>
                               :    inline bool
                               :    operator>(const deque<_Tp, _Alloc>& __x,
                               :	      const deque<_Tp, _Alloc>& __y)
                               :    { return __y < __x; }
                               :
                               :  /// Based on operator<
                               :  template<typename _Tp, typename _Alloc>
                               :    inline bool
                               :    operator<=(const deque<_Tp, _Alloc>& __x,
                               :	       const deque<_Tp, _Alloc>& __y)
                               :    { return !(__y < __x); }
                               :
                               :  /// Based on operator<
                               :  template<typename _Tp, typename _Alloc>
                               :    inline bool
                               :    operator>=(const deque<_Tp, _Alloc>& __x,
                               :	       const deque<_Tp, _Alloc>& __y)
                               :    { return !(__x < __y); }
                               :
                               :  /// See std::deque::swap().
                               :  template<typename _Tp, typename _Alloc>
                               :    inline void
                               :    swap(deque<_Tp,_Alloc>& __x, deque<_Tp,_Alloc>& __y)
                               :    { __x.swap(__y); }
                               :
                               :#undef _GLIBCXX_DEQUE_BUF_SIZE
                               :
                               :_GLIBCXX_END_NAMESPACE_CONTAINER
                               :} // namespace std
                               :
                               :#endif /* _STL_DEQUE_H */
/* 
 * Total samples for file : "/usr/include/c++/4.8/bits/stl_uninitialized.h"
 * 
 *     78  0.0664     0       0
 */


                               :// Raw memory manipulators -*- C++ -*-
                               :
                               :// Copyright (C) 2001-2013 Free Software Foundation, Inc.
                               ://
                               :// This file is part of the GNU ISO C++ Library.  This library is free
                               :// software; you can redistribute it and/or modify it under the
                               :// terms of the GNU General Public License as published by the
                               :// Free Software Foundation; either version 3, or (at your option)
                               :// any later version.
                               :
                               :// This library is distributed in the hope that it will be useful,
                               :// but WITHOUT ANY WARRANTY; without even the implied warranty of
                               :// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                               :// GNU General Public License for more details.
                               :
                               :// Under Section 7 of GPL version 3, you are granted additional
                               :// permissions described in the GCC Runtime Library Exception, version
                               :// 3.1, as published by the Free Software Foundation.
                               :
                               :// You should have received a copy of the GNU General Public License and
                               :// a copy of the GCC Runtime Library Exception along with this program;
                               :// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                               :// <http://www.gnu.org/licenses/>.
                               :
                               :/*
                               : *
                               : * Copyright (c) 1994
                               : * Hewlett-Packard Company
                               : *
                               : * Permission to use, copy, modify, distribute and sell this software
                               : * and its documentation for any purpose is hereby granted without fee,
                               : * provided that the above copyright notice appear in all copies and
                               : * that both that copyright notice and this permission notice appear
                               : * in supporting documentation.  Hewlett-Packard Company makes no
                               : * representations about the suitability of this software for any
                               : * purpose.  It is provided "as is" without express or implied warranty.
                               : *
                               : *
                               : * Copyright (c) 1996,1997
                               : * Silicon Graphics Computer Systems, Inc.
                               : *
                               : * Permission to use, copy, modify, distribute and sell this software
                               : * and its documentation for any purpose is hereby granted without fee,
                               : * provided that the above copyright notice appear in all copies and
                               : * that both that copyright notice and this permission notice appear
                               : * in supporting documentation.  Silicon Graphics makes no
                               : * representations about the suitability of this software for any
                               : * purpose.  It is provided "as is" without express or implied warranty.
                               : */
                               :
                               :/** @file bits/stl_uninitialized.h
                               : *  This is an internal header file, included by other library headers.
                               : *  Do not attempt to use it directly. @headername{memory}
                               : */
                               :
                               :#ifndef _STL_UNINITIALIZED_H
                               :#define _STL_UNINITIALIZED_H 1
                               :
                               :namespace std _GLIBCXX_VISIBILITY(default)
                               :{
                               :_GLIBCXX_BEGIN_NAMESPACE_VERSION
                               :
                               :  template<bool _TrivialValueTypes>
                               :    struct __uninitialized_copy
                               :    {
                               :      template<typename _InputIterator, typename _ForwardIterator>
                               :        static _ForwardIterator
                               :        __uninit_copy(_InputIterator __first, _InputIterator __last,
                               :		      _ForwardIterator __result)
                               :        {
     4  0.0034     0       0   :	  _ForwardIterator __cur = __result;
                               :	  __try
                               :	    {
    53  0.0451     0       0   :	      for (; __first != __last; ++__first, ++__cur)
                               :		std::_Construct(std::__addressof(*__cur), *__first);
                               :	      return __cur;
                               :	    }
                               :	  __catch(...)
                               :	    {
                               :	      std::_Destroy(__result, __cur);
                               :	      __throw_exception_again;
                               :	    }
                               :	}
                               :    };
                               :
                               :  template<>
                               :    struct __uninitialized_copy<true>
                               :    {
                               :      template<typename _InputIterator, typename _ForwardIterator>
                               :        static _ForwardIterator
                               :        __uninit_copy(_InputIterator __first, _InputIterator __last,
                               :		      _ForwardIterator __result)
                               :        { return std::copy(__first, __last, __result); }
                               :    };
                               :
                               :  /**
                               :   *  @brief Copies the range [first,last) into result.
                               :   *  @param  __first  An input iterator.
                               :   *  @param  __last   An input iterator.
                               :   *  @param  __result An output iterator.
                               :   *  @return   __result + (__first - __last)
                               :   *
                               :   *  Like copy(), but does not require an initialized output range.
                               :  */
                               :  template<typename _InputIterator, typename _ForwardIterator>
                               :    inline _ForwardIterator
                               :    uninitialized_copy(_InputIterator __first, _InputIterator __last,
                               :		       _ForwardIterator __result)
                               :    {
                               :      typedef typename iterator_traits<_InputIterator>::value_type
                               :	_ValueType1;
                               :      typedef typename iterator_traits<_ForwardIterator>::value_type
                               :	_ValueType2;
                               :
                               :      return std::__uninitialized_copy<(__is_trivial(_ValueType1)
                               :					&& __is_trivial(_ValueType2))>::
                               :	__uninit_copy(__first, __last, __result);
                               :    }
                               :
                               :
                               :  template<bool _TrivialValueType>
                               :    struct __uninitialized_fill
                               :    {
                               :      template<typename _ForwardIterator, typename _Tp>
                               :        static void
                               :        __uninit_fill(_ForwardIterator __first, _ForwardIterator __last,
                               :		      const _Tp& __x)
                               :        {
                               :	  _ForwardIterator __cur = __first;
                               :	  __try
                               :	    {
                               :	      for (; __cur != __last; ++__cur)
                               :		std::_Construct(std::__addressof(*__cur), __x);
                               :	    }
                               :	  __catch(...)
                               :	    {
                               :	      std::_Destroy(__first, __cur);
                               :	      __throw_exception_again;
                               :	    }
                               :	}
                               :    };
                               :
                               :  template<>
                               :    struct __uninitialized_fill<true>
                               :    {
                               :      template<typename _ForwardIterator, typename _Tp>
                               :        static void
                               :        __uninit_fill(_ForwardIterator __first, _ForwardIterator __last,
                               :		      const _Tp& __x)
                               :        { std::fill(__first, __last, __x); }
                               :    };
                               :
                               :  /**
                               :   *  @brief Copies the value x into the range [first,last).
                               :   *  @param  __first  An input iterator.
                               :   *  @param  __last   An input iterator.
                               :   *  @param  __x      The source value.
                               :   *  @return   Nothing.
                               :   *
                               :   *  Like fill(), but does not require an initialized output range.
                               :  */
                               :  template<typename _ForwardIterator, typename _Tp>
                               :    inline void
                               :    uninitialized_fill(_ForwardIterator __first, _ForwardIterator __last,
                               :		       const _Tp& __x)
                               :    {
                               :      typedef typename iterator_traits<_ForwardIterator>::value_type
                               :	_ValueType;
                               :
                               :      std::__uninitialized_fill<__is_trivial(_ValueType)>::
                               :	__uninit_fill(__first, __last, __x);
                               :    }
                               :
                               :
                               :  template<bool _TrivialValueType>
                               :    struct __uninitialized_fill_n
                               :    {
                               :      template<typename _ForwardIterator, typename _Size, typename _Tp>
                               :        static void
                               :        __uninit_fill_n(_ForwardIterator __first, _Size __n,
                               :			const _Tp& __x)
                               :        {
                               :	  _ForwardIterator __cur = __first;
                               :	  __try
                               :	    {
    20  0.0170     0       0   :	      for (; __n > 0; --__n, ++__cur)
                               :		std::_Construct(std::__addressof(*__cur), __x);
                               :	    }
                               :	  __catch(...)
                               :	    {
                               :	      std::_Destroy(__first, __cur);
                               :	      __throw_exception_again;
                               :	    }
                               :	}
                               :    };
                               :
                               :  template<>
                               :    struct __uninitialized_fill_n<true>
                               :    {
                               :      template<typename _ForwardIterator, typename _Size, typename _Tp>
                               :        static void
                               :        __uninit_fill_n(_ForwardIterator __first, _Size __n,
                               :			const _Tp& __x)
                               :        { std::fill_n(__first, __n, __x); }
                               :    };
                               :
                               :  /**
                               :   *  @brief Copies the value x into the range [first,first+n).
                               :   *  @param  __first  An input iterator.
                               :   *  @param  __n      The number of copies to make.
                               :   *  @param  __x      The source value.
                               :   *  @return   Nothing.
                               :   *
                               :   *  Like fill_n(), but does not require an initialized output range.
                               :  */
                               :  template<typename _ForwardIterator, typename _Size, typename _Tp>
                               :    inline void
                               :    uninitialized_fill_n(_ForwardIterator __first, _Size __n, const _Tp& __x)
                               :    {
                               :      typedef typename iterator_traits<_ForwardIterator>::value_type
                               :	_ValueType;
                               :
                               :      std::__uninitialized_fill_n<__is_trivial(_ValueType)>::
                               :	__uninit_fill_n(__first, __n, __x);
                               :    }
                               :
                               :  // Extensions: versions of uninitialized_copy, uninitialized_fill,
                               :  //  and uninitialized_fill_n that take an allocator parameter.
                               :  //  We dispatch back to the standard versions when we're given the
                               :  //  default allocator.  For nondefault allocators we do not use 
                               :  //  any of the POD optimizations.
                               :
                               :  template<typename _InputIterator, typename _ForwardIterator,
                               :	   typename _Allocator>
                               :    _ForwardIterator
                               :    __uninitialized_copy_a(_InputIterator __first, _InputIterator __last,
                               :			   _ForwardIterator __result, _Allocator& __alloc)
                               :    {
                               :      _ForwardIterator __cur = __result;
                               :      __try
                               :	{
                               :	  typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
                               :	  for (; __first != __last; ++__first, ++__cur)
                               :	    __traits::construct(__alloc, std::__addressof(*__cur), *__first);
                               :	  return __cur;
                               :	}
                               :      __catch(...)
                               :	{
                               :	  std::_Destroy(__result, __cur, __alloc);
                               :	  __throw_exception_again;
                               :	}
                               :    }
                               :
                               :  template<typename _InputIterator, typename _ForwardIterator, typename _Tp>
                               :    inline _ForwardIterator
                               :    __uninitialized_copy_a(_InputIterator __first, _InputIterator __last,
                               :			   _ForwardIterator __result, allocator<_Tp>&)
                               :    { return std::uninitialized_copy(__first, __last, __result); }
                               :
                               :  template<typename _InputIterator, typename _ForwardIterator,
                               :	   typename _Allocator>
                               :    inline _ForwardIterator
                               :    __uninitialized_move_a(_InputIterator __first, _InputIterator __last,
                               :			   _ForwardIterator __result, _Allocator& __alloc)
                               :    {
                               :      return std::__uninitialized_copy_a(_GLIBCXX_MAKE_MOVE_ITERATOR(__first),
                               :					 _GLIBCXX_MAKE_MOVE_ITERATOR(__last),
                               :					 __result, __alloc);
                               :    }
                               :
                               :  template<typename _InputIterator, typename _ForwardIterator,
                               :	   typename _Allocator>
                               :    inline _ForwardIterator
                               :    __uninitialized_move_if_noexcept_a(_InputIterator __first,
                               :				       _InputIterator __last,
                               :				       _ForwardIterator __result,
                               :				       _Allocator& __alloc)
                               :    {
                               :      return std::__uninitialized_copy_a
                               :	(_GLIBCXX_MAKE_MOVE_IF_NOEXCEPT_ITERATOR(__first),
                               :	 _GLIBCXX_MAKE_MOVE_IF_NOEXCEPT_ITERATOR(__last), __result, __alloc);
                               :    }
                               :
                               :  template<typename _ForwardIterator, typename _Tp, typename _Allocator>
                               :    void
                               :    __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last,
                               :			   const _Tp& __x, _Allocator& __alloc)
                               :    {
                               :      _ForwardIterator __cur = __first;
                               :      __try
                               :	{
                               :	  typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
                               :	  for (; __cur != __last; ++__cur)
                               :	    __traits::construct(__alloc, std::__addressof(*__cur), __x);
                               :	}
                               :      __catch(...)
                               :	{
                               :	  std::_Destroy(__first, __cur, __alloc);
                               :	  __throw_exception_again;
                               :	}
                               :    }
                               :
                               :  template<typename _ForwardIterator, typename _Tp, typename _Tp2>
                               :    inline void
                               :    __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last,
                               :			   const _Tp& __x, allocator<_Tp2>&)
                               :    { std::uninitialized_fill(__first, __last, __x); }
                               :
                               :  template<typename _ForwardIterator, typename _Size, typename _Tp,
                               :	   typename _Allocator>
                               :    void
                               :    __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n, 
                               :			     const _Tp& __x, _Allocator& __alloc)
                               :    {
                               :      _ForwardIterator __cur = __first;
                               :      __try
                               :	{
                               :	  typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
                               :	  for (; __n > 0; --__n, ++__cur)
                               :	    __traits::construct(__alloc, std::__addressof(*__cur), __x);
                               :	}
                               :      __catch(...)
                               :	{
                               :	  std::_Destroy(__first, __cur, __alloc);
                               :	  __throw_exception_again;
                               :	}
                               :    }
                               :
                               :  template<typename _ForwardIterator, typename _Size, typename _Tp,
                               :	   typename _Tp2>
                               :    inline void
                               :    __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n, 
                               :			     const _Tp& __x, allocator<_Tp2>&)
                               :    { std::uninitialized_fill_n(__first, __n, __x); }
                               :
                               :
                               :  // Extensions: __uninitialized_copy_move, __uninitialized_move_copy,
                               :  // __uninitialized_fill_move, __uninitialized_move_fill.
                               :  // All of these algorithms take a user-supplied allocator, which is used
                               :  // for construction and destruction.
                               :
                               :  // __uninitialized_copy_move
                               :  // Copies [first1, last1) into [result, result + (last1 - first1)), and
                               :  //  move [first2, last2) into
                               :  //  [result, result + (last1 - first1) + (last2 - first2)).
                               :  template<typename _InputIterator1, typename _InputIterator2,
                               :	   typename _ForwardIterator, typename _Allocator>
                               :    inline _ForwardIterator
                               :    __uninitialized_copy_move(_InputIterator1 __first1,
                               :			      _InputIterator1 __last1,
                               :			      _InputIterator2 __first2,
                               :			      _InputIterator2 __last2,
                               :			      _ForwardIterator __result,
                               :			      _Allocator& __alloc)
                               :    {
                               :      _ForwardIterator __mid = std::__uninitialized_copy_a(__first1, __last1,
                               :							   __result,
                               :							   __alloc);
                               :      __try
                               :	{
                               :	  return std::__uninitialized_move_a(__first2, __last2, __mid, __alloc);
                               :	}
                               :      __catch(...)
                               :	{
                               :	  std::_Destroy(__result, __mid, __alloc);
                               :	  __throw_exception_again;
                               :	}
                               :    }
                               :
                               :  // __uninitialized_move_copy
                               :  // Moves [first1, last1) into [result, result + (last1 - first1)), and
                               :  //  copies [first2, last2) into
                               :  //  [result, result + (last1 - first1) + (last2 - first2)).
                               :  template<typename _InputIterator1, typename _InputIterator2,
                               :	   typename _ForwardIterator, typename _Allocator>
                               :    inline _ForwardIterator
                               :    __uninitialized_move_copy(_InputIterator1 __first1,
                               :			      _InputIterator1 __last1,
                               :			      _InputIterator2 __first2,
                               :			      _InputIterator2 __last2,
                               :			      _ForwardIterator __result,
                               :			      _Allocator& __alloc)
                               :    {
                               :      _ForwardIterator __mid = std::__uninitialized_move_a(__first1, __last1,
                               :							   __result,
                               :							   __alloc);
                               :      __try
                               :	{
                               :	  return std::__uninitialized_copy_a(__first2, __last2, __mid, __alloc);
                               :	}
                               :      __catch(...)
                               :	{
                               :	  std::_Destroy(__result, __mid, __alloc);
                               :	  __throw_exception_again;
                               :	}
                               :    }
                               :  
                               :  // __uninitialized_fill_move
                               :  // Fills [result, mid) with x, and moves [first, last) into
                               :  //  [mid, mid + (last - first)).
                               :  template<typename _ForwardIterator, typename _Tp, typename _InputIterator,
                               :	   typename _Allocator>
                               :    inline _ForwardIterator
                               :    __uninitialized_fill_move(_ForwardIterator __result, _ForwardIterator __mid,
                               :			      const _Tp& __x, _InputIterator __first,
                               :			      _InputIterator __last, _Allocator& __alloc)
                               :    {
                               :      std::__uninitialized_fill_a(__result, __mid, __x, __alloc);
                               :      __try
                               :	{
                               :	  return std::__uninitialized_move_a(__first, __last, __mid, __alloc);
                               :	}
                               :      __catch(...)
                               :	{
                               :	  std::_Destroy(__result, __mid, __alloc);
                               :	  __throw_exception_again;
                               :	}
                               :    }
                               :
                               :  // __uninitialized_move_fill
                               :  // Moves [first1, last1) into [first2, first2 + (last1 - first1)), and
                               :  //  fills [first2 + (last1 - first1), last2) with x.
                               :  template<typename _InputIterator, typename _ForwardIterator, typename _Tp,
                               :	   typename _Allocator>
                               :    inline void
                               :    __uninitialized_move_fill(_InputIterator __first1, _InputIterator __last1,
                               :			      _ForwardIterator __first2,
                               :			      _ForwardIterator __last2, const _Tp& __x,
                               :			      _Allocator& __alloc)
                               :    {
                               :      _ForwardIterator __mid2 = std::__uninitialized_move_a(__first1, __last1,
                               :							    __first2,
                               :							    __alloc);
                               :      __try
                               :	{
                               :	  std::__uninitialized_fill_a(__mid2, __last2, __x, __alloc);
                               :	}
                               :      __catch(...)
                               :	{
                               :	  std::_Destroy(__first2, __mid2, __alloc);
                               :	  __throw_exception_again;
                               :	}
                               :    }
                               :
                               :#if __cplusplus >= 201103L
                               :  // Extensions: __uninitialized_default, __uninitialized_default_n,
                               :  // __uninitialized_default_a, __uninitialized_default_n_a.
                               :
                               :  template<bool _TrivialValueType>
                               :    struct __uninitialized_default_1
                               :    {
                               :      template<typename _ForwardIterator>
                               :        static void
                               :        __uninit_default(_ForwardIterator __first, _ForwardIterator __last)
                               :        {
                               :	  _ForwardIterator __cur = __first;
                               :	  __try
                               :	    {
                               :	      for (; __cur != __last; ++__cur)
                               :		std::_Construct(std::__addressof(*__cur));
                               :	    }
                               :	  __catch(...)
                               :	    {
                               :	      std::_Destroy(__first, __cur);
                               :	      __throw_exception_again;
                               :	    }
                               :	}
                               :    };
                               :
                               :  template<>
                               :    struct __uninitialized_default_1<true>
                               :    {
                               :      template<typename _ForwardIterator>
                               :        static void
                               :        __uninit_default(_ForwardIterator __first, _ForwardIterator __last)
                               :        {
                               :	  typedef typename iterator_traits<_ForwardIterator>::value_type
                               :	    _ValueType;
                               :
                               :	  std::fill(__first, __last, _ValueType());
                               :	}
                               :    };
                               :
                               :  template<bool _TrivialValueType>
                               :    struct __uninitialized_default_n_1
                               :    {
                               :      template<typename _ForwardIterator, typename _Size>
                               :        static void
                               :        __uninit_default_n(_ForwardIterator __first, _Size __n)
                               :        {
                               :	  _ForwardIterator __cur = __first;
                               :	  __try
                               :	    {
     1 8.5e-04     0       0   :	      for (; __n > 0; --__n, ++__cur)
                               :		std::_Construct(std::__addressof(*__cur));
                               :	    }
                               :	  __catch(...)
                               :	    {
                               :	      std::_Destroy(__first, __cur);
                               :	      __throw_exception_again;
                               :	    }
                               :	}
                               :    };
                               :
                               :  template<>
                               :    struct __uninitialized_default_n_1<true>
                               :    {
                               :      template<typename _ForwardIterator, typename _Size>
                               :        static void
                               :        __uninit_default_n(_ForwardIterator __first, _Size __n)
                               :        {
                               :	  typedef typename iterator_traits<_ForwardIterator>::value_type
                               :	    _ValueType;
                               :
                               :	  std::fill_n(__first, __n, _ValueType());
                               :	}
                               :    };
                               :
                               :  // __uninitialized_default
                               :  // Fills [first, last) with std::distance(first, last) default
                               :  // constructed value_types(s).
                               :  template<typename _ForwardIterator>
                               :    inline void
                               :    __uninitialized_default(_ForwardIterator __first,
                               :			    _ForwardIterator __last)
                               :    {
                               :      typedef typename iterator_traits<_ForwardIterator>::value_type
                               :	_ValueType;
                               :
                               :      std::__uninitialized_default_1<__is_trivial(_ValueType)>::
                               :	__uninit_default(__first, __last);
                               :    }
                               :
                               :  // __uninitialized_default_n
                               :  // Fills [first, first + n) with n default constructed value_type(s).
                               :  template<typename _ForwardIterator, typename _Size>
                               :    inline void
                               :    __uninitialized_default_n(_ForwardIterator __first, _Size __n)
                               :    {
                               :      typedef typename iterator_traits<_ForwardIterator>::value_type
                               :	_ValueType;
                               :
                               :      std::__uninitialized_default_n_1<__is_trivial(_ValueType)>::
                               :	__uninit_default_n(__first, __n);
                               :    }
                               :
                               :
                               :  // __uninitialized_default_a
                               :  // Fills [first, last) with std::distance(first, last) default
                               :  // constructed value_types(s), constructed with the allocator alloc.
                               :  template<typename _ForwardIterator, typename _Allocator>
                               :    void
                               :    __uninitialized_default_a(_ForwardIterator __first,
                               :			      _ForwardIterator __last,
                               :			      _Allocator& __alloc)
                               :    {
                               :      _ForwardIterator __cur = __first;
                               :      __try
                               :	{
                               :	  typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
                               :	  for (; __cur != __last; ++__cur)
                               :	    __traits::construct(__alloc, std::__addressof(*__cur));
                               :	}
                               :      __catch(...)
                               :	{
                               :	  std::_Destroy(__first, __cur, __alloc);
                               :	  __throw_exception_again;
                               :	}
                               :    }
                               :
                               :  template<typename _ForwardIterator, typename _Tp>
                               :    inline void
                               :    __uninitialized_default_a(_ForwardIterator __first,
                               :			      _ForwardIterator __last,
                               :			      allocator<_Tp>&)
                               :    { std::__uninitialized_default(__first, __last); }
                               :
                               :
                               :  // __uninitialized_default_n_a
                               :  // Fills [first, first + n) with n default constructed value_types(s),
                               :  // constructed with the allocator alloc.
                               :  template<typename _ForwardIterator, typename _Size, typename _Allocator>
                               :    void
                               :    __uninitialized_default_n_a(_ForwardIterator __first, _Size __n, 
                               :				_Allocator& __alloc)
                               :    {
                               :      _ForwardIterator __cur = __first;
                               :      __try
                               :	{
                               :	  typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
                               :	  for (; __n > 0; --__n, ++__cur)
                               :	    __traits::construct(__alloc, std::__addressof(*__cur));
                               :	}
                               :      __catch(...)
                               :	{
                               :	  std::_Destroy(__first, __cur, __alloc);
                               :	  __throw_exception_again;
                               :	}
                               :    }
                               :
                               :  template<typename _ForwardIterator, typename _Size, typename _Tp>
                               :    inline void
                               :    __uninitialized_default_n_a(_ForwardIterator __first, _Size __n, 
                               :				allocator<_Tp>&)
                               :    { std::__uninitialized_default_n(__first, __n); }
                               :
                               :
                               :  template<typename _InputIterator, typename _Size,
                               :	   typename _ForwardIterator>
                               :    _ForwardIterator
                               :    __uninitialized_copy_n(_InputIterator __first, _Size __n,
                               :			   _ForwardIterator __result, input_iterator_tag)
                               :    {
                               :      _ForwardIterator __cur = __result;
                               :      __try
                               :	{
                               :	  for (; __n > 0; --__n, ++__first, ++__cur)
                               :	    std::_Construct(std::__addressof(*__cur), *__first);
                               :	  return __cur;
                               :	}
                               :      __catch(...)
                               :	{
                               :	  std::_Destroy(__result, __cur);
                               :	  __throw_exception_again;
                               :	}
                               :    }
                               :
                               :  template<typename _RandomAccessIterator, typename _Size,
                               :	   typename _ForwardIterator>
                               :    inline _ForwardIterator
                               :    __uninitialized_copy_n(_RandomAccessIterator __first, _Size __n,
                               :			   _ForwardIterator __result,
                               :			   random_access_iterator_tag)
                               :    { return std::uninitialized_copy(__first, __first + __n, __result); }
                               :
                               :  /**
                               :   *  @brief Copies the range [first,first+n) into result.
                               :   *  @param  __first  An input iterator.
                               :   *  @param  __n      The number of elements to copy.
                               :   *  @param  __result An output iterator.
                               :   *  @return  __result + __n
                               :   *
                               :   *  Like copy_n(), but does not require an initialized output range.
                               :  */
                               :  template<typename _InputIterator, typename _Size, typename _ForwardIterator>
                               :    inline _ForwardIterator
                               :    uninitialized_copy_n(_InputIterator __first, _Size __n,
                               :			 _ForwardIterator __result)
                               :    { return std::__uninitialized_copy_n(__first, __n, __result,
                               :					 std::__iterator_category(__first)); }
                               :#endif
                               :
                               :_GLIBCXX_END_NAMESPACE_VERSION
                               :} // namespace
                               :
                               :#endif /* _STL_UNINITIALIZED_H */
/* 
 * Total samples for file : "/usr/include/c++/4.8/bits/stl_bvector.h"
 * 
 *     73  0.0621     1  0.0591
 */


                               :// vector<bool> specialization -*- C++ -*-
                               :
                               :// Copyright (C) 2001-2013 Free Software Foundation, Inc.
                               ://
                               :// This file is part of the GNU ISO C++ Library.  This library is free
                               :// software; you can redistribute it and/or modify it under the
                               :// terms of the GNU General Public License as published by the
                               :// Free Software Foundation; either version 3, or (at your option)
                               :// any later version.
                               :
                               :// This library is distributed in the hope that it will be useful,
                               :// but WITHOUT ANY WARRANTY; without even the implied warranty of
                               :// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                               :// GNU General Public License for more details.
                               :
                               :// Under Section 7 of GPL version 3, you are granted additional
                               :// permissions described in the GCC Runtime Library Exception, version
                               :// 3.1, as published by the Free Software Foundation.
                               :
                               :// You should have received a copy of the GNU General Public License and
                               :// a copy of the GCC Runtime Library Exception along with this program;
                               :// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                               :// <http://www.gnu.org/licenses/>.
                               :
                               :/*
                               : *
                               : * Copyright (c) 1994
                               : * Hewlett-Packard Company
                               : *
                               : * Permission to use, copy, modify, distribute and sell this software
                               : * and its documentation for any purpose is hereby granted without fee,
                               : * provided that the above copyright notice appear in all copies and
                               : * that both that copyright notice and this permission notice appear
                               : * in supporting documentation.  Hewlett-Packard Company makes no
                               : * representations about the suitability of this software for any
                               : * purpose.  It is provided "as is" without express or implied warranty.
                               : *
                               : *
                               : * Copyright (c) 1996-1999
                               : * Silicon Graphics Computer Systems, Inc.
                               : *
                               : * Permission to use, copy, modify, distribute and sell this software
                               : * and its documentation for any purpose is hereby granted without fee,
                               : * provided that the above copyright notice appear in all copies and
                               : * that both that copyright notice and this permission notice appear
                               : * in supporting documentation.  Silicon Graphics makes no
                               : * representations about the suitability of this software for any
                               : * purpose.  It is provided "as is" without express or implied warranty.
                               : */
                               :
                               :/** @file bits/stl_bvector.h
                               : *  This is an internal header file, included by other library headers.
                               : *  Do not attempt to use it directly. @headername{vector}
                               : */
                               :
                               :#ifndef _STL_BVECTOR_H
                               :#define _STL_BVECTOR_H 1
                               :
                               :#if __cplusplus >= 201103L
                               :#include <initializer_list>
                               :#endif
                               :
                               :namespace std _GLIBCXX_VISIBILITY(default)
                               :{
                               :_GLIBCXX_BEGIN_NAMESPACE_CONTAINER
                               :
                               :  typedef unsigned long _Bit_type;
                               :  enum { _S_word_bit = int(__CHAR_BIT__ * sizeof(_Bit_type)) };
                               :
                               :  struct _Bit_reference
                               :  {
                               :    _Bit_type * _M_p;
                               :    _Bit_type _M_mask;
                               :
                               :    _Bit_reference(_Bit_type * __x, _Bit_type __y)
                               :    : _M_p(__x), _M_mask(__y) { }
                               :
                               :    _Bit_reference() _GLIBCXX_NOEXCEPT : _M_p(0), _M_mask(0) { }
                               :
                               :    operator bool() const _GLIBCXX_NOEXCEPT
    30  0.0255     0       0   :    { return !!(*_M_p & _M_mask); }
                               :
                               :    _Bit_reference&
                               :    operator=(bool __x) _GLIBCXX_NOEXCEPT
                               :    {
     2  0.0017     0       0   :      if (__x)
     3  0.0026     0       0   :	*_M_p |= _M_mask;
                               :      else
     1 8.5e-04     0       0   :	*_M_p &= ~_M_mask;
                               :      return *this;
                               :    }
                               :
                               :    _Bit_reference&
                               :    operator=(const _Bit_reference& __x) _GLIBCXX_NOEXCEPT
                               :    { return *this = bool(__x); }
                               :
                               :    bool
                               :    operator==(const _Bit_reference& __x) const
                               :    { return bool(*this) == bool(__x); }
                               :
                               :    bool
                               :    operator<(const _Bit_reference& __x) const
                               :    { return !bool(*this) && bool(__x); }
                               :
                               :    void
                               :    flip() _GLIBCXX_NOEXCEPT
                               :    { *_M_p ^= _M_mask; }
                               :  };
                               :
                               :#if __cplusplus >= 201103L
                               :  inline void
                               :  swap(_Bit_reference __x, _Bit_reference __y) noexcept
                               :  {
                               :    bool __tmp = __x;
                               :    __x = __y;
                               :    __y = __tmp;
                               :  }
                               :
                               :  inline void
                               :  swap(_Bit_reference __x, bool& __y) noexcept
                               :  {
                               :    bool __tmp = __x;
                               :    __x = __y;
                               :    __y = __tmp;
                               :  }
                               :
                               :  inline void
                               :  swap(bool& __x, _Bit_reference __y) noexcept
                               :  {
                               :    bool __tmp = __x;
                               :    __x = __y;
                               :    __y = __tmp;
                               :  }
                               :#endif
                               :
                               :  struct _Bit_iterator_base
                               :  : public std::iterator<std::random_access_iterator_tag, bool>
                               :  {
                               :    _Bit_type * _M_p;
                               :    unsigned int _M_offset;
                               :
                               :    _Bit_iterator_base(_Bit_type * __x, unsigned int __y)
                               :    : _M_p(__x), _M_offset(__y) { }
                               :
                               :    void
                               :    _M_bump_up()
                               :    {
     5  0.0043     0       0   :      if (_M_offset++ == int(_S_word_bit) - 1)
                               :	{
                               :	  _M_offset = 0;
                               :	  ++_M_p;
                               :	}
                               :    }
                               :
                               :    void
                               :    _M_bump_down()
                               :    {
                               :      if (_M_offset-- == 0)
                               :	{
                               :	  _M_offset = int(_S_word_bit) - 1;
                               :	  --_M_p;
                               :	}
                               :    }
                               :
                               :    void
                               :    _M_incr(ptrdiff_t __i)
                               :    {
                               :      difference_type __n = __i + _M_offset;
                               :      _M_p += __n / int(_S_word_bit);
                               :      __n = __n % int(_S_word_bit);
                               :      if (__n < 0)
                               :	{
                               :	  __n += int(_S_word_bit);
                               :	  --_M_p;
                               :	}
                               :      _M_offset = static_cast<unsigned int>(__n);
                               :    }
                               :
                               :    bool
                               :    operator==(const _Bit_iterator_base& __i) const
                               :    { return _M_p == __i._M_p && _M_offset == __i._M_offset; }
                               :
                               :    bool
                               :    operator<(const _Bit_iterator_base& __i) const
                               :    {
                               :      return _M_p < __i._M_p
                               :	     || (_M_p == __i._M_p && _M_offset < __i._M_offset);
                               :    }
                               :
                               :    bool
                               :    operator!=(const _Bit_iterator_base& __i) const
                               :    { return !(*this == __i); }
                               :
                               :    bool
                               :    operator>(const _Bit_iterator_base& __i) const
                               :    { return __i < *this; }
                               :
                               :    bool
                               :    operator<=(const _Bit_iterator_base& __i) const
                               :    { return !(__i < *this); }
                               :
                               :    bool
                               :    operator>=(const _Bit_iterator_base& __i) const
                               :    { return !(*this < __i); }
                               :  };
                               :
                               :  inline ptrdiff_t
                               :  operator-(const _Bit_iterator_base& __x, const _Bit_iterator_base& __y)
                               :  {
                               :    return (int(_S_word_bit) * (__x._M_p - __y._M_p)
                               :	    + __x._M_offset - __y._M_offset);
                               :  }
                               :
                               :  struct _Bit_iterator : public _Bit_iterator_base
                               :  {
                               :    typedef _Bit_reference  reference;
                               :    typedef _Bit_reference* pointer;
                               :    typedef _Bit_iterator   iterator;
                               :
                               :    _Bit_iterator() : _Bit_iterator_base(0, 0) { }
                               :
                               :    _Bit_iterator(_Bit_type * __x, unsigned int __y)
                               :    : _Bit_iterator_base(__x, __y) { }
                               :
                               :    reference
                               :    operator*() const
    13  0.0111     1  0.0591   :    { return reference(_M_p, 1UL << _M_offset); }
                               :
                               :    iterator&
                               :    operator++()
                               :    {
                               :      _M_bump_up();
                               :      return *this;
                               :    }
                               :
                               :    iterator
                               :    operator++(int)
                               :    {
                               :      iterator __tmp = *this;
                               :      _M_bump_up();
                               :      return __tmp;
                               :    }
                               :
                               :    iterator&
                               :    operator--()
                               :    {
                               :      _M_bump_down();
                               :      return *this;
                               :    }
                               :
                               :    iterator
                               :    operator--(int)
                               :    {
                               :      iterator __tmp = *this;
                               :      _M_bump_down();
                               :      return __tmp;
                               :    }
                               :
                               :    iterator&
                               :    operator+=(difference_type __i)
                               :    {
                               :      _M_incr(__i);
                               :      return *this;
                               :    }
                               :
                               :    iterator&
                               :    operator-=(difference_type __i)
                               :    {
                               :      *this += -__i;
                               :      return *this;
                               :    }
                               :
                               :    iterator
                               :    operator+(difference_type __i) const
                               :    {
                               :      iterator __tmp = *this;
                               :      return __tmp += __i;
                               :    }
                               :
                               :    iterator
                               :    operator-(difference_type __i) const
                               :    {
                               :      iterator __tmp = *this;
                               :      return __tmp -= __i;
                               :    }
                               :
                               :    reference
                               :    operator[](difference_type __i) const
                               :    { return *(*this + __i); }
                               :  };
                               :
                               :  inline _Bit_iterator
                               :  operator+(ptrdiff_t __n, const _Bit_iterator& __x)
                               :  { return __x + __n; }
                               :
                               :  struct _Bit_const_iterator : public _Bit_iterator_base
                               :  {
                               :    typedef bool                 reference;
                               :    typedef bool                 const_reference;
                               :    typedef const bool*          pointer;
                               :    typedef _Bit_const_iterator  const_iterator;
                               :
                               :    _Bit_const_iterator() : _Bit_iterator_base(0, 0) { }
                               :
                               :    _Bit_const_iterator(_Bit_type * __x, unsigned int __y)
                               :    : _Bit_iterator_base(__x, __y) { }
                               :
                               :    _Bit_const_iterator(const _Bit_iterator& __x)
                               :    : _Bit_iterator_base(__x._M_p, __x._M_offset) { }
                               :
                               :    const_reference
                               :    operator*() const
     1 8.5e-04     0       0   :    { return _Bit_reference(_M_p, 1UL << _M_offset); }
                               :
                               :    const_iterator&
                               :    operator++()
                               :    {
                               :      _M_bump_up();
                               :      return *this;
                               :    }
                               :
                               :    const_iterator
                               :    operator++(int)
                               :    {
                               :      const_iterator __tmp = *this;
                               :      _M_bump_up();
                               :      return __tmp;
                               :    }
                               :
                               :    const_iterator&
                               :    operator--()
                               :    {
                               :      _M_bump_down();
                               :      return *this;
                               :    }
                               :
                               :    const_iterator
                               :    operator--(int)
                               :    {
                               :      const_iterator __tmp = *this;
                               :      _M_bump_down();
                               :      return __tmp;
                               :    }
                               :
                               :    const_iterator&
                               :    operator+=(difference_type __i)
                               :    {
                               :      _M_incr(__i);
                               :      return *this;
                               :    }
                               :
                               :    const_iterator&
                               :    operator-=(difference_type __i)
                               :    {
                               :      *this += -__i;
                               :      return *this;
                               :    }
                               :
                               :    const_iterator 
                               :    operator+(difference_type __i) const
                               :    {
                               :      const_iterator __tmp = *this;
                               :      return __tmp += __i;
                               :    }
                               :
                               :    const_iterator
                               :    operator-(difference_type __i) const
                               :    {
                               :      const_iterator __tmp = *this;
                               :      return __tmp -= __i;
                               :    }
                               :
                               :    const_reference
                               :    operator[](difference_type __i) const
                               :    { return *(*this + __i); }
                               :  };
                               :
                               :  inline _Bit_const_iterator
                               :  operator+(ptrdiff_t __n, const _Bit_const_iterator& __x)
                               :  { return __x + __n; }
                               :
                               :  inline void
                               :  __fill_bvector(_Bit_iterator __first, _Bit_iterator __last, bool __x)
                               :  {
                               :    for (; __first != __last; ++__first)
                               :      *__first = __x;
                               :  }
                               :
                               :  inline void
                               :  fill(_Bit_iterator __first, _Bit_iterator __last, const bool& __x)
                               :  {
                               :    if (__first._M_p != __last._M_p)
                               :      {
                               :	std::fill(__first._M_p + 1, __last._M_p, __x ? ~0 : 0);
                               :	__fill_bvector(__first, _Bit_iterator(__first._M_p + 1, 0), __x);
                               :	__fill_bvector(_Bit_iterator(__last._M_p, 0), __last, __x);
                               :      }
                               :    else
                               :      __fill_bvector(__first, __last, __x);
                               :  }
                               :
                               :  template<typename _Alloc>
                               :    struct _Bvector_base
                               :    {
                               :      typedef typename _Alloc::template rebind<_Bit_type>::other
                               :        _Bit_alloc_type;
                               :      
                               :      struct _Bvector_impl
                               :      : public _Bit_alloc_type
                               :      {
                               :	_Bit_iterator 	_M_start;
                               :	_Bit_iterator 	_M_finish;
                               :	_Bit_type* 	_M_end_of_storage;
                               :
                               :	_Bvector_impl()
                               :	: _Bit_alloc_type(), _M_start(), _M_finish(), _M_end_of_storage(0)
                               :	{ }
                               : 
                               :	_Bvector_impl(const _Bit_alloc_type& __a)
                               :	: _Bit_alloc_type(__a), _M_start(), _M_finish(), _M_end_of_storage(0)
                               :	{ }
                               :
                               :#if __cplusplus >= 201103L
                               :	_Bvector_impl(_Bit_alloc_type&& __a)
                               :	: _Bit_alloc_type(std::move(__a)), _M_start(), _M_finish(),
                               :	  _M_end_of_storage(0)
                               :	{ }
                               :#endif
                               :      };
                               :
                               :    public:
                               :      typedef _Alloc allocator_type;
                               :
                               :      _Bit_alloc_type&
                               :      _M_get_Bit_allocator() _GLIBCXX_NOEXCEPT
                               :      { return *static_cast<_Bit_alloc_type*>(&this->_M_impl); }
                               :
                               :      const _Bit_alloc_type&
                               :      _M_get_Bit_allocator() const _GLIBCXX_NOEXCEPT
                               :      { return *static_cast<const _Bit_alloc_type*>(&this->_M_impl); }
                               :
                               :      allocator_type
                               :      get_allocator() const _GLIBCXX_NOEXCEPT
                               :      { return allocator_type(_M_get_Bit_allocator()); }
                               :
                               :      _Bvector_base()
                               :      : _M_impl() { }
                               :      
                               :      _Bvector_base(const allocator_type& __a)
                               :      : _M_impl(__a) { }
                               :
                               :#if __cplusplus >= 201103L
                               :      _Bvector_base(_Bvector_base&& __x) noexcept
                               :      : _M_impl(std::move(__x._M_get_Bit_allocator()))
                               :      {
                               :	this->_M_impl._M_start = __x._M_impl._M_start;
                               :	this->_M_impl._M_finish = __x._M_impl._M_finish;
                               :	this->_M_impl._M_end_of_storage = __x._M_impl._M_end_of_storage;
                               :	__x._M_impl._M_start = _Bit_iterator();
                               :	__x._M_impl._M_finish = _Bit_iterator();
                               :	__x._M_impl._M_end_of_storage = 0;
                               :      }
                               :#endif
                               :
                               :      ~_Bvector_base()
                               :      { this->_M_deallocate(); }
                               :
                               :    protected:
                               :      _Bvector_impl _M_impl;
                               :
                               :      _Bit_type*
                               :      _M_allocate(size_t __n)
                               :      { return _M_impl.allocate(_S_nword(__n)); }
                               :
                               :      void
                               :      _M_deallocate()
                               :      {
                               :	if (_M_impl._M_start._M_p)
                               :	  _M_impl.deallocate(_M_impl._M_start._M_p,
                               :			     _M_impl._M_end_of_storage - _M_impl._M_start._M_p);
                               :      }
                               :
                               :      static size_t
                               :      _S_nword(size_t __n)
                               :      { return (__n + int(_S_word_bit) - 1) / int(_S_word_bit); }
                               :    };
                               :
                               :_GLIBCXX_END_NAMESPACE_CONTAINER
                               :} // namespace std
                               :
                               :// Declare a partial specialization of vector<T, Alloc>.
                               :#include <bits/stl_vector.h>
                               :
                               :namespace std _GLIBCXX_VISIBILITY(default)
                               :{
                               :_GLIBCXX_BEGIN_NAMESPACE_CONTAINER
                               :
                               :  /**
                               :   *  @brief  A specialization of vector for booleans which offers fixed time
                               :   *  access to individual elements in any order.
                               :   *
                               :   *  @ingroup sequences
                               :   *
                               :   *  @tparam _Alloc  Allocator type.
                               :   *
                               :   *  Note that vector<bool> does not actually meet the requirements for being
                               :   *  a container.  This is because the reference and pointer types are not
                               :   *  really references and pointers to bool.  See DR96 for details.  @see
                               :   *  vector for function documentation.
                               :   *
                               :   *  In some terminology a %vector can be described as a dynamic
                               :   *  C-style array, it offers fast and efficient access to individual
                               :   *  elements in any order and saves the user from worrying about
                               :   *  memory and size allocation.  Subscripting ( @c [] ) access is
                               :   *  also provided as with C-style arrays.
                               :  */
                               :template<typename _Alloc>
                               :  class vector<bool, _Alloc> : protected _Bvector_base<_Alloc>
                               :  {
                               :    typedef _Bvector_base<_Alloc>			 _Base;
                               :
                               :#if __cplusplus >= 201103L
                               :    template<typename> friend struct hash;
                               :#endif
                               :
                               :  public:
                               :    typedef bool                                         value_type;
                               :    typedef size_t                                       size_type;
                               :    typedef ptrdiff_t                                    difference_type;
                               :    typedef _Bit_reference                               reference;
                               :    typedef bool                                         const_reference;
                               :    typedef _Bit_reference*                              pointer;
                               :    typedef const bool*                                  const_pointer;
                               :    typedef _Bit_iterator                                iterator;
                               :    typedef _Bit_const_iterator                          const_iterator;
                               :    typedef std::reverse_iterator<const_iterator>        const_reverse_iterator;
                               :    typedef std::reverse_iterator<iterator>              reverse_iterator;
                               :    typedef _Alloc                        		 allocator_type;
                               :
                               :    allocator_type get_allocator() const
                               :    { return _Base::get_allocator(); }
                               :
                               :  protected:
                               :    using _Base::_M_allocate;
                               :    using _Base::_M_deallocate;
                               :    using _Base::_S_nword;
                               :    using _Base::_M_get_Bit_allocator;
                               :
                               :  public:
                               :    vector()
                               :    : _Base() { }
                               :
                               :    explicit
                               :    vector(const allocator_type& __a)
                               :    : _Base(__a) { }
                               :
                               :#if __cplusplus >= 201103L
                               :    explicit
                               :    vector(size_type __n, const allocator_type& __a = allocator_type())
                               :    : vector(__n, false, __a)
                               :    { }
                               :
                               :    vector(size_type __n, const bool& __value, 
                               :	   const allocator_type& __a = allocator_type())
                               :    : _Base(__a)
                               :    {
                               :      _M_initialize(__n);
                               :      std::fill(this->_M_impl._M_start._M_p, this->_M_impl._M_end_of_storage, 
                               :		__value ? ~0 : 0);
                               :    }
                               :#else
                               :    explicit
                               :    vector(size_type __n, const bool& __value = bool(), 
                               :	   const allocator_type& __a = allocator_type())
                               :    : _Base(__a)
                               :    {
                               :      _M_initialize(__n);
                               :      std::fill(this->_M_impl._M_start._M_p, this->_M_impl._M_end_of_storage, 
                               :		__value ? ~0 : 0);
                               :    }
                               :#endif
                               :
                               :    vector(const vector& __x)
                               :    : _Base(__x._M_get_Bit_allocator())
                               :    {
                               :      _M_initialize(__x.size());
                               :      _M_copy_aligned(__x.begin(), __x.end(), this->_M_impl._M_start);
                               :    }
                               :
                               :#if __cplusplus >= 201103L
                               :    vector(vector&& __x) noexcept
                               :    : _Base(std::move(__x)) { }
                               :
                               :    vector(initializer_list<bool> __l,
                               :	   const allocator_type& __a = allocator_type())
                               :    : _Base(__a)
                               :    {
                               :      _M_initialize_range(__l.begin(), __l.end(),
                               :			  random_access_iterator_tag());
                               :    }
                               :#endif
                               :
                               :#if __cplusplus >= 201103L
                               :    template<typename _InputIterator,
                               :	     typename = std::_RequireInputIter<_InputIterator>>
                               :      vector(_InputIterator __first, _InputIterator __last,
                               :	     const allocator_type& __a = allocator_type())
                               :      : _Base(__a)
                               :      { _M_initialize_dispatch(__first, __last, __false_type()); }
                               :#else
                               :    template<typename _InputIterator>
                               :      vector(_InputIterator __first, _InputIterator __last,
                               :	     const allocator_type& __a = allocator_type())
                               :      : _Base(__a)
                               :      {
                               :	typedef typename std::__is_integer<_InputIterator>::__type _Integral;
                               :	_M_initialize_dispatch(__first, __last, _Integral());
                               :      }
                               :#endif
                               :
                               :    ~vector() _GLIBCXX_NOEXCEPT { }
                               :
                               :    vector&
                               :    operator=(const vector& __x)
                               :    {
                               :      if (&__x == this)
                               :	return *this;
                               :      if (__x.size() > capacity())
                               :	{
                               :	  this->_M_deallocate();
                               :	  _M_initialize(__x.size());
                               :	}
                               :      this->_M_impl._M_finish = _M_copy_aligned(__x.begin(), __x.end(),
                               :						begin());
                               :      return *this;
                               :    }
                               :
                               :#if __cplusplus >= 201103L
                               :    vector&
                               :    operator=(vector&& __x)
                               :    {
                               :      // NB: DR 1204.
                               :      // NB: DR 675.
                               :      this->clear();
                               :      this->swap(__x); 
                               :      return *this;
                               :    }
                               :
                               :    vector&
                               :    operator=(initializer_list<bool> __l)
                               :    {
                               :      this->assign (__l.begin(), __l.end());
                               :      return *this;
                               :    }
                               :#endif
                               :
                               :    // assign(), a generalized assignment member function.  Two
                               :    // versions: one that takes a count, and one that takes a range.
                               :    // The range version is a member template, so we dispatch on whether
                               :    // or not the type is an integer.
                               :    void
                               :    assign(size_type __n, const bool& __x)
                               :    { _M_fill_assign(__n, __x); }
                               :
                               :#if __cplusplus >= 201103L
                               :    template<typename _InputIterator,
                               :	     typename = std::_RequireInputIter<_InputIterator>>
                               :      void
                               :      assign(_InputIterator __first, _InputIterator __last)
                               :      { _M_assign_dispatch(__first, __last, __false_type()); }
                               :#else
                               :    template<typename _InputIterator>
                               :      void
                               :      assign(_InputIterator __first, _InputIterator __last)
                               :      {
                               :	typedef typename std::__is_integer<_InputIterator>::__type _Integral;
                               :	_M_assign_dispatch(__first, __last, _Integral());
                               :      }
                               :#endif
                               :
                               :#if __cplusplus >= 201103L
                               :    void
                               :    assign(initializer_list<bool> __l)
                               :    { this->assign(__l.begin(), __l.end()); }
                               :#endif
                               :
                               :    iterator
                               :    begin() _GLIBCXX_NOEXCEPT
                               :    { return this->_M_impl._M_start; }
                               :
                               :    const_iterator
                               :    begin() const _GLIBCXX_NOEXCEPT
                               :    { return this->_M_impl._M_start; }
                               :
                               :    iterator
                               :    end() _GLIBCXX_NOEXCEPT
                               :    { return this->_M_impl._M_finish; }
                               :
                               :    const_iterator
                               :    end() const _GLIBCXX_NOEXCEPT
                               :    { return this->_M_impl._M_finish; }
                               :
                               :    reverse_iterator
                               :    rbegin() _GLIBCXX_NOEXCEPT
                               :    { return reverse_iterator(end()); }
                               :
                               :    const_reverse_iterator
                               :    rbegin() const _GLIBCXX_NOEXCEPT
                               :    { return const_reverse_iterator(end()); }
                               :
                               :    reverse_iterator
                               :    rend() _GLIBCXX_NOEXCEPT
                               :    { return reverse_iterator(begin()); }
                               :
                               :    const_reverse_iterator
                               :    rend() const _GLIBCXX_NOEXCEPT
                               :    { return const_reverse_iterator(begin()); }
                               :
                               :#if __cplusplus >= 201103L
                               :    const_iterator
                               :    cbegin() const noexcept
                               :    { return this->_M_impl._M_start; }
                               :
                               :    const_iterator
                               :    cend() const noexcept
                               :    { return this->_M_impl._M_finish; }
                               :
                               :    const_reverse_iterator
                               :    crbegin() const noexcept
                               :    { return const_reverse_iterator(end()); }
                               :
                               :    const_reverse_iterator
                               :    crend() const noexcept
                               :    { return const_reverse_iterator(begin()); }
                               :#endif
                               :
                               :    size_type
                               :    size() const _GLIBCXX_NOEXCEPT
                               :    { return size_type(end() - begin()); }
                               :
                               :    size_type
                               :    max_size() const _GLIBCXX_NOEXCEPT
                               :    {
                               :      const size_type __isize =
                               :	__gnu_cxx::__numeric_traits<difference_type>::__max
                               :	- int(_S_word_bit) + 1;
                               :      const size_type __asize = _M_get_Bit_allocator().max_size();
                               :      return (__asize <= __isize / int(_S_word_bit)
                               :	      ? __asize * int(_S_word_bit) : __isize);
                               :    }
                               :
                               :    size_type
                               :    capacity() const _GLIBCXX_NOEXCEPT
                               :    { return size_type(const_iterator(this->_M_impl._M_end_of_storage, 0)
                               :		       - begin()); }
                               :
                               :    bool
                               :    empty() const _GLIBCXX_NOEXCEPT
                               :    { return begin() == end(); }
                               :
                               :    reference
                               :    operator[](size_type __n)
                               :    {
                               :      return *iterator(this->_M_impl._M_start._M_p
    18  0.0153     0       0   :		       + __n / int(_S_word_bit), __n % int(_S_word_bit));
                               :    }
                               :
                               :    const_reference
                               :    operator[](size_type __n) const
                               :    {
                               :      return *const_iterator(this->_M_impl._M_start._M_p
                               :			     + __n / int(_S_word_bit), __n % int(_S_word_bit));
                               :    }
                               :
                               :  protected:
                               :    void
                               :    _M_range_check(size_type __n) const
                               :    {
                               :      if (__n >= this->size())
                               :        __throw_out_of_range(__N("vector<bool>::_M_range_check"));
                               :    }
                               :
                               :  public:
                               :    reference
                               :    at(size_type __n)
                               :    { _M_range_check(__n); return (*this)[__n]; }
                               :
                               :    const_reference
                               :    at(size_type __n) const
                               :    { _M_range_check(__n); return (*this)[__n]; }
                               :
                               :    void
                               :    reserve(size_type __n)
                               :    {
                               :      if (__n > max_size())
                               :	__throw_length_error(__N("vector::reserve"));
                               :      if (capacity() < __n)
                               :	_M_reallocate(__n);
                               :    }
                               :
                               :    reference
                               :    front()
                               :    { return *begin(); }
                               :
                               :    const_reference
                               :    front() const
                               :    { return *begin(); }
                               :
                               :    reference
                               :    back()
                               :    { return *(end() - 1); }
                               :
                               :    const_reference
                               :    back() const
                               :    { return *(end() - 1); }
                               :
                               :    // _GLIBCXX_RESOLVE_LIB_DEFECTS
                               :    // DR 464. Suggestion for new member functions in standard containers.
                               :    // N.B. DR 464 says nothing about vector<bool> but we need something
                               :    // here due to the way we are implementing DR 464 in the debug-mode
                               :    // vector class.
                               :    void
                               :    data() _GLIBCXX_NOEXCEPT { }
                               :
                               :    void
                               :    push_back(bool __x)
                               :    {
                               :      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_of_storage)
                               :        *this->_M_impl._M_finish++ = __x;
                               :      else
                               :        _M_insert_aux(end(), __x);
                               :    }
                               :
                               :    void
                               :    swap(vector& __x)
                               :    {
                               :      std::swap(this->_M_impl._M_start, __x._M_impl._M_start);
                               :      std::swap(this->_M_impl._M_finish, __x._M_impl._M_finish);
                               :      std::swap(this->_M_impl._M_end_of_storage, 
                               :		__x._M_impl._M_end_of_storage);
                               :
                               :      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                               :      // 431. Swapping containers with unequal allocators.
                               :      std::__alloc_swap<typename _Base::_Bit_alloc_type>::
                               :	_S_do_it(_M_get_Bit_allocator(), __x._M_get_Bit_allocator());
                               :    }
                               :
                               :    // [23.2.5]/1, third-to-last entry in synopsis listing
                               :    static void
                               :    swap(reference __x, reference __y) _GLIBCXX_NOEXCEPT
                               :    {
                               :      bool __tmp = __x;
                               :      __x = __y;
                               :      __y = __tmp;
                               :    }
                               :
                               :    iterator
                               :    insert(iterator __position, const bool& __x = bool())
                               :    {
                               :      const difference_type __n = __position - begin();
                               :      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_of_storage
                               :	  && __position == end())
                               :        *this->_M_impl._M_finish++ = __x;
                               :      else
                               :        _M_insert_aux(__position, __x);
                               :      return begin() + __n;
                               :    }
                               :
                               :#if __cplusplus >= 201103L
                               :    template<typename _InputIterator,
                               :	     typename = std::_RequireInputIter<_InputIterator>>
                               :      void
                               :      insert(iterator __position,
                               :	     _InputIterator __first, _InputIterator __last)
                               :      { _M_insert_dispatch(__position, __first, __last, __false_type()); }
                               :#else
                               :    template<typename _InputIterator>
                               :      void
                               :      insert(iterator __position,
                               :	     _InputIterator __first, _InputIterator __last)
                               :      {
                               :	typedef typename std::__is_integer<_InputIterator>::__type _Integral;
                               :	_M_insert_dispatch(__position, __first, __last, _Integral());
                               :      }
                               :#endif
                               :
                               :    void
                               :    insert(iterator __position, size_type __n, const bool& __x)
                               :    { _M_fill_insert(__position, __n, __x); }
                               :
                               :#if __cplusplus >= 201103L
                               :    void insert(iterator __p, initializer_list<bool> __l)
                               :    { this->insert(__p, __l.begin(), __l.end()); }
                               :#endif
                               :
                               :    void
                               :    pop_back()
                               :    { --this->_M_impl._M_finish; }
                               :
                               :    iterator
                               :    erase(iterator __position)
                               :    {
                               :      if (__position + 1 != end())
                               :        std::copy(__position + 1, end(), __position);
                               :      --this->_M_impl._M_finish;
                               :      return __position;
                               :    }
                               :
                               :    iterator
                               :    erase(iterator __first, iterator __last)
                               :    {
                               :      if (__first != __last)
                               :	_M_erase_at_end(std::copy(__last, end(), __first));
                               :      return __first;
                               :    }
                               :
                               :    void
                               :    resize(size_type __new_size, bool __x = bool())
                               :    {
                               :      if (__new_size < size())
                               :        _M_erase_at_end(begin() + difference_type(__new_size));
                               :      else
                               :        insert(end(), __new_size - size(), __x);
                               :    }
                               :
                               :#if __cplusplus >= 201103L
                               :    void
                               :    shrink_to_fit()
                               :    { _M_shrink_to_fit(); }
                               :#endif
                               :
                               :    void
                               :    flip() _GLIBCXX_NOEXCEPT
                               :    {
                               :      for (_Bit_type * __p = this->_M_impl._M_start._M_p;
                               :	   __p != this->_M_impl._M_end_of_storage; ++__p)
                               :        *__p = ~*__p;
                               :    }
                               :
                               :    void
                               :    clear() _GLIBCXX_NOEXCEPT
                               :    { _M_erase_at_end(begin()); }
                               :
                               :   
                               :  protected:
                               :    // Precondition: __first._M_offset == 0 && __result._M_offset == 0.
                               :    iterator
                               :    _M_copy_aligned(const_iterator __first, const_iterator __last,
                               :		    iterator __result)
                               :    {
                               :      _Bit_type* __q = std::copy(__first._M_p, __last._M_p, __result._M_p);
                               :      return std::copy(const_iterator(__last._M_p, 0), __last,
                               :		       iterator(__q, 0));
                               :    }
                               :
                               :    void
                               :    _M_initialize(size_type __n)
                               :    {
                               :      _Bit_type* __q = this->_M_allocate(__n);
                               :      this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
                               :      this->_M_impl._M_start = iterator(__q, 0);
                               :      this->_M_impl._M_finish = this->_M_impl._M_start + difference_type(__n);
                               :    }
                               :
                               :    void
                               :    _M_reallocate(size_type __n);
                               :
                               :#if __cplusplus >= 201103L
                               :    bool
                               :    _M_shrink_to_fit();
                               :#endif
                               :
                               :    // Check whether it's an integral type.  If so, it's not an iterator.
                               :
                               :    // _GLIBCXX_RESOLVE_LIB_DEFECTS
                               :    // 438. Ambiguity in the "do the right thing" clause
                               :    template<typename _Integer>
                               :      void
                               :      _M_initialize_dispatch(_Integer __n, _Integer __x, __true_type)
                               :      {
                               :	_M_initialize(static_cast<size_type>(__n));
                               :	std::fill(this->_M_impl._M_start._M_p, 
                               :		  this->_M_impl._M_end_of_storage, __x ? ~0 : 0);
                               :      }
                               :
                               :    template<typename _InputIterator>
                               :      void 
                               :      _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
                               :			     __false_type)
                               :      { _M_initialize_range(__first, __last, 
                               :			    std::__iterator_category(__first)); }
                               :
                               :    template<typename _InputIterator>
                               :      void
                               :      _M_initialize_range(_InputIterator __first, _InputIterator __last,
                               :			  std::input_iterator_tag)
                               :      {
                               :	for (; __first != __last; ++__first)
                               :	  push_back(*__first);
                               :      }
                               :
                               :    template<typename _ForwardIterator>
                               :      void
                               :      _M_initialize_range(_ForwardIterator __first, _ForwardIterator __last,
                               :			  std::forward_iterator_tag)
                               :      {
                               :	const size_type __n = std::distance(__first, __last);
                               :	_M_initialize(__n);
                               :	std::copy(__first, __last, this->_M_impl._M_start);
                               :      }
                               :
                               :    // _GLIBCXX_RESOLVE_LIB_DEFECTS
                               :    // 438. Ambiguity in the "do the right thing" clause
                               :    template<typename _Integer>
                               :      void
                               :      _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
                               :      { _M_fill_assign(__n, __val); }
                               :
                               :    template<class _InputIterator>
                               :      void
                               :      _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
                               :			 __false_type)
                               :      { _M_assign_aux(__first, __last, std::__iterator_category(__first)); }
                               :
                               :    void
                               :    _M_fill_assign(size_t __n, bool __x)
                               :    {
                               :      if (__n > size())
                               :	{
                               :	  std::fill(this->_M_impl._M_start._M_p, 
                               :		    this->_M_impl._M_end_of_storage, __x ? ~0 : 0);
                               :	  insert(end(), __n - size(), __x);
                               :	}
                               :      else
                               :	{
                               :	  _M_erase_at_end(begin() + __n);
                               :	  std::fill(this->_M_impl._M_start._M_p, 
                               :		    this->_M_impl._M_end_of_storage, __x ? ~0 : 0);
                               :	}
                               :    }
                               :
                               :    template<typename _InputIterator>
                               :      void
                               :      _M_assign_aux(_InputIterator __first, _InputIterator __last,
                               :		    std::input_iterator_tag)
                               :      {
                               :	iterator __cur = begin();
                               :	for (; __first != __last && __cur != end(); ++__cur, ++__first)
                               :	  *__cur = *__first;
                               :	if (__first == __last)
                               :	  _M_erase_at_end(__cur);
                               :	else
                               :	  insert(end(), __first, __last);
                               :      }
                               :    
                               :    template<typename _ForwardIterator>
                               :      void
                               :      _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
                               :		    std::forward_iterator_tag)
                               :      {
                               :	const size_type __len = std::distance(__first, __last);
                               :	if (__len < size())
                               :	  _M_erase_at_end(std::copy(__first, __last, begin()));
                               :	else
                               :	  {
                               :	    _ForwardIterator __mid = __first;
                               :	    std::advance(__mid, size());
                               :	    std::copy(__first, __mid, begin());
                               :	    insert(end(), __mid, __last);
                               :	  }
                               :      }
                               :
                               :    // Check whether it's an integral type.  If so, it's not an iterator.
                               :
                               :    // _GLIBCXX_RESOLVE_LIB_DEFECTS
                               :    // 438. Ambiguity in the "do the right thing" clause
                               :    template<typename _Integer>
                               :      void
                               :      _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __x,
                               :			 __true_type)
                               :      { _M_fill_insert(__pos, __n, __x); }
                               :
                               :    template<typename _InputIterator>
                               :      void
                               :      _M_insert_dispatch(iterator __pos,
                               :			 _InputIterator __first, _InputIterator __last,
                               :			 __false_type)
                               :      { _M_insert_range(__pos, __first, __last,
                               :			std::__iterator_category(__first)); }
                               :
                               :    void
                               :    _M_fill_insert(iterator __position, size_type __n, bool __x);
                               :
                               :    template<typename _InputIterator>
                               :      void
                               :      _M_insert_range(iterator __pos, _InputIterator __first, 
                               :		      _InputIterator __last, std::input_iterator_tag)
                               :      {
                               :	for (; __first != __last; ++__first)
                               :	  {
                               :	    __pos = insert(__pos, *__first);
                               :	    ++__pos;
                               :	  }
                               :      }
                               :
                               :    template<typename _ForwardIterator>
                               :      void
                               :      _M_insert_range(iterator __position, _ForwardIterator __first, 
                               :		      _ForwardIterator __last, std::forward_iterator_tag);
                               :
                               :    void
                               :    _M_insert_aux(iterator __position, bool __x);
                               :
                               :    size_type
                               :    _M_check_len(size_type __n, const char* __s) const
                               :    {
                               :      if (max_size() - size() < __n)
                               :	__throw_length_error(__N(__s));
                               :
                               :      const size_type __len = size() + std::max(size(), __n);
                               :      return (__len < size() || __len > max_size()) ? max_size() : __len;
                               :    }
                               :
                               :    void
                               :    _M_erase_at_end(iterator __pos)
                               :    { this->_M_impl._M_finish = __pos; }
                               :  };
                               :
                               :_GLIBCXX_END_NAMESPACE_CONTAINER
                               :} // namespace std
                               :
                               :#if __cplusplus >= 201103L
                               :
                               :#include <bits/functional_hash.h>
                               :
                               :namespace std _GLIBCXX_VISIBILITY(default)
                               :{
                               :_GLIBCXX_BEGIN_NAMESPACE_VERSION
                               :
                               :  // DR 1182.
                               :  /// std::hash specialization for vector<bool>.
                               :  template<typename _Alloc>
                               :    struct hash<_GLIBCXX_STD_C::vector<bool, _Alloc>>
                               :    : public __hash_base<size_t, _GLIBCXX_STD_C::vector<bool, _Alloc>>
                               :    {
                               :      size_t
                               :      operator()(const _GLIBCXX_STD_C::vector<bool, _Alloc>&) const noexcept;
                               :    };
                               :
                               :_GLIBCXX_END_NAMESPACE_VERSION
                               :}// namespace std
                               :
                               :#endif // C++11
                               :
                               :#endif
/* 
 * Total samples for file : "/usr/include/c++/4.8/bits/move.h"
 * 
 *     21  0.0179     0       0
 */


                               :// Move, forward and identity for C++0x + swap -*- C++ -*-
                               :
                               :// Copyright (C) 2007-2013 Free Software Foundation, Inc.
                               ://
                               :// This file is part of the GNU ISO C++ Library.  This library is free
                               :// software; you can redistribute it and/or modify it under the
                               :// terms of the GNU General Public License as published by the
                               :// Free Software Foundation; either version 3, or (at your option)
                               :// any later version.
                               :
                               :// This library is distributed in the hope that it will be useful,
                               :// but WITHOUT ANY WARRANTY; without even the implied warranty of
                               :// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                               :// GNU General Public License for more details.
                               :
                               :// Under Section 7 of GPL version 3, you are granted additional
                               :// permissions described in the GCC Runtime Library Exception, version
                               :// 3.1, as published by the Free Software Foundation.
                               :
                               :// You should have received a copy of the GNU General Public License and
                               :// a copy of the GCC Runtime Library Exception along with this program;
                               :// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                               :// <http://www.gnu.org/licenses/>.
                               :
                               :/** @file bits/move.h
                               : *  This is an internal header file, included by other library headers.
                               : *  Do not attempt to use it directly. @headername{utility}
                               : */
                               :
                               :#ifndef _MOVE_H
                               :#define _MOVE_H 1
                               :
                               :#include <bits/c++config.h>
                               :#include <bits/concept_check.h>
                               :
                               :namespace std _GLIBCXX_VISIBILITY(default)
                               :{
                               :_GLIBCXX_BEGIN_NAMESPACE_VERSION
                               :
                               :  // Used, in C++03 mode too, by allocators, etc.
                               :  /**
                               :   *  @brief Same as C++11 std::addressof
                               :   *  @ingroup utilities
                               :   */
                               :  template<typename _Tp>
                               :    inline _Tp*
                               :    __addressof(_Tp& __r) _GLIBCXX_NOEXCEPT
                               :    {
                               :      return reinterpret_cast<_Tp*>
                               :	(&const_cast<char&>(reinterpret_cast<const volatile char&>(__r)));
                               :    }
                               :
                               :_GLIBCXX_END_NAMESPACE_VERSION
                               :} // namespace
                               :
                               :#if __cplusplus >= 201103L
                               :#include <type_traits> // Brings in std::declval too.
                               :
                               :namespace std _GLIBCXX_VISIBILITY(default)
                               :{
                               :_GLIBCXX_BEGIN_NAMESPACE_VERSION
                               :
                               :  /**
                               :   *  @addtogroup utilities
                               :   *  @{
                               :   */
                               :
                               :  /**
                               :   *  @brief  Forward an lvalue.
                               :   *  @return The parameter cast to the specified type.
                               :   *
                               :   *  This function is used to implement "perfect forwarding".
                               :   */
                               :  template<typename _Tp>
                               :    constexpr _Tp&&
                               :    forward(typename std::remove_reference<_Tp>::type& __t) noexcept
                               :    { return static_cast<_Tp&&>(__t); }
                               :
                               :  /**
                               :   *  @brief  Forward an rvalue.
                               :   *  @return The parameter cast to the specified type.
                               :   *
                               :   *  This function is used to implement "perfect forwarding".
                               :   */
                               :  template<typename _Tp>
                               :    constexpr _Tp&&
                               :    forward(typename std::remove_reference<_Tp>::type&& __t) noexcept
                               :    {
                               :      static_assert(!std::is_lvalue_reference<_Tp>::value, "template argument"
                               :		    " substituting _Tp is an lvalue reference type");
                               :      return static_cast<_Tp&&>(__t);
                               :    }
                               :
                               :  /**
                               :   *  @brief  Convert a value to an rvalue.
                               :   *  @param  __t  A thing of arbitrary type.
                               :   *  @return The parameter cast to an rvalue-reference to allow moving it.
                               :  */
                               :  template<typename _Tp>
                               :    constexpr typename std::remove_reference<_Tp>::type&&
                               :    move(_Tp&& __t) noexcept
                               :    { return static_cast<typename std::remove_reference<_Tp>::type&&>(__t); }
                               :
                               :
                               :  template<typename _Tp>
                               :    struct __move_if_noexcept_cond
                               :    : public __and_<__not_<is_nothrow_move_constructible<_Tp>>,
                               :                    is_copy_constructible<_Tp>>::type { };
                               :
                               :  /**
                               :   *  @brief  Conditionally convert a value to an rvalue.
                               :   *  @param  __x  A thing of arbitrary type.
                               :   *  @return The parameter, possibly cast to an rvalue-reference.
                               :   *
                               :   *  Same as std::move unless the type's move constructor could throw and the
                               :   *  type is copyable, in which case an lvalue-reference is returned instead.
                               :   */
                               :  template<typename _Tp>
                               :    inline constexpr typename
                               :    conditional<__move_if_noexcept_cond<_Tp>::value, const _Tp&, _Tp&&>::type
                               :    move_if_noexcept(_Tp& __x) noexcept
                               :    { return std::move(__x); }
                               :
                               :  // declval, from type_traits.
                               :
                               :  /**
                               :   *  @brief Returns the actual address of the object or function
                               :   *         referenced by r, even in the presence of an overloaded
                               :   *         operator&.
                               :   *  @param  __r  Reference to an object or function.
                               :   *  @return   The actual address.
                               :  */
                               :  template<typename _Tp>
                               :    inline _Tp*
                               :    addressof(_Tp& __r) noexcept
                               :    { return std::__addressof(__r); }
                               :
                               :  /// @} group utilities
                               :_GLIBCXX_END_NAMESPACE_VERSION
                               :} // namespace
                               :
                               :#define _GLIBCXX_MOVE(__val) std::move(__val)
                               :#define _GLIBCXX_FORWARD(_Tp, __val) std::forward<_Tp>(__val)
                               :#else
                               :#define _GLIBCXX_MOVE(__val) (__val)
                               :#define _GLIBCXX_FORWARD(_Tp, __val) (__val)
                               :#endif
                               :
                               :namespace std _GLIBCXX_VISIBILITY(default)
                               :{
                               :_GLIBCXX_BEGIN_NAMESPACE_VERSION
                               :
                               :  /**
                               :   *  @addtogroup utilities
                               :   *  @{
                               :   */
                               :
                               :  /**
                               :   *  @brief Swaps two values.
                               :   *  @param  __a  A thing of arbitrary type.
                               :   *  @param  __b  Another thing of arbitrary type.
                               :   *  @return   Nothing.
                               :  */
                               :  template<typename _Tp>
                               :    inline void
                               :    swap(_Tp& __a, _Tp& __b)
                               :#if __cplusplus >= 201103L
                               :    noexcept(__and_<is_nothrow_move_constructible<_Tp>,
                               :	            is_nothrow_move_assignable<_Tp>>::value)
                               :#endif
                               :    {
                               :      // concept requirements
                               :      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)
                               :
     6  0.0051     0       0   :      _Tp __tmp = _GLIBCXX_MOVE(__a);
    11  0.0094     0       0   :      __a = _GLIBCXX_MOVE(__b);
     4  0.0034     0       0   :      __b = _GLIBCXX_MOVE(__tmp);
                               :    }
                               :
                               :  // _GLIBCXX_RESOLVE_LIB_DEFECTS
                               :  // DR 809. std::swap should be overloaded for array types.
                               :  /// Swap the contents of two arrays.
                               :  template<typename _Tp, size_t _Nm>
                               :    inline void
                               :    swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm])
                               :#if __cplusplus >= 201103L
                               :    noexcept(noexcept(swap(*__a, *__b)))
                               :#endif
                               :    {
                               :      for (size_t __n = 0; __n < _Nm; ++__n)
                               :	swap(__a[__n], __b[__n]);
                               :    }
                               :
                               :  /// @} group utilities
                               :_GLIBCXX_END_NAMESPACE_VERSION
                               :} // namespace
                               :
                               :#endif /* _MOVE_H */
/* 
 * Total samples for file : "/home/lh/Desktop/codecraft/profile/./future_net/Path.h"
 * 
 *     17  0.0145     0       0
 */


                               :#ifndef __PATH_H__
                               :#define __PATH_H__
                               :#include "bitset.h"
                               :#include "vector_int.h"
                               :#include <vector>
                               :#include <map>
                               :
                               :typedef struct Path {                                   // 路径信息
                               :    int pathCost;                                       // 路径开销
                               :    int passed;                                         // 路径经过的必经点个数, 不包括起点和终点
                               :    int endPoint;                                       // 路径的终点
                               :    bitset bitPath;                                     // 用顶点编号表示的路径，不包括终点
                               :    std::vector<int> nodePath;                          // 用顶点编号表示的路径，不包括终点
                               :    std::vector<int> edgePath;                          // 用边编号表示的路径
     8  0.0068     0       0   :    Path(void):pathCost(0), passed(0), endPoint(-1){}   // 路径的无参构造函数
                               :    bool operator< (const Path & other) const {         // 重载<操作符，路径权值越大优先级越低
                               :        return this->pathCost > other.pathCost;
                               :    }
                               :    bool operator== (const Path & other) const {        //重载==操作符，当两条路径边的编号完全相同时，判定为相等
                               :        if(this->edgePath == other.edgePath) {
                               :            return true;
                               :        } else {
                               :            return false;
                               :        }
                               :    }
                               :    void reverse(int src, int dest) {
                               :        this->endPoint = src;
                               :        this->bitPath.reset(src);
                               :        this->bitPath.set(dest);
     1 8.5e-04     0       0   :        for(unsigned int i = 0, j = edgePath.size() - 1; i < j; i++, j--) {
                               :            int temp = edgePath[i];
                               :            edgePath[i] = edgePath[j];
                               :            edgePath[j] = temp;
                               :        }
                               :        this->nodePath[0] = dest;
     1 8.5e-04     0       0   :        for(unsigned int i = 1, j = nodePath.size() - 1; i < j; i++, j--) {
                               :            int temp = nodePath[i];
                               :            nodePath[i] = nodePath[j];
                               :            nodePath[j] = temp;
                               :        }
                               :    }
                               :} Path;
                               :
                               :/*struct path_cmp{//Path* 的比较函数，用于指定priority_queue的比较顺序
                               :	bool operator()(Path *a, Path *b){
                               ://		return *a < *b;
                               :		return a->pathCost > b->pathCost;
                               :	}
                               :};*/
                               :
                               :bool path_cmp(Path *a, Path *b) {
     7  0.0060     0       0   :    return a->pathCost < b->pathCost;
                               :}
                               :
                               :
                               :#endif
/* 
 * Total samples for file : "/usr/include/c++/4.8/bits/stl_tempbuf.h"
 * 
 *      8  0.0068     0       0
 */


                               :// Temporary buffer implementation -*- C++ -*-
                               :
                               :// Copyright (C) 2001-2013 Free Software Foundation, Inc.
                               ://
                               :// This file is part of the GNU ISO C++ Library.  This library is free
                               :// software; you can redistribute it and/or modify it under the
                               :// terms of the GNU General Public License as published by the
                               :// Free Software Foundation; either version 3, or (at your option)
                               :// any later version.
                               :
                               :// This library is distributed in the hope that it will be useful,
                               :// but WITHOUT ANY WARRANTY; without even the implied warranty of
                               :// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                               :// GNU General Public License for more details.
                               :
                               :// Under Section 7 of GPL version 3, you are granted additional
                               :// permissions described in the GCC Runtime Library Exception, version
                               :// 3.1, as published by the Free Software Foundation.
                               :
                               :// You should have received a copy of the GNU General Public License and
                               :// a copy of the GCC Runtime Library Exception along with this program;
                               :// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                               :// <http://www.gnu.org/licenses/>.
                               :
                               :/*
                               : *
                               : * Copyright (c) 1994
                               : * Hewlett-Packard Company
                               : *
                               : * Permission to use, copy, modify, distribute and sell this software
                               : * and its documentation for any purpose is hereby granted without fee,
                               : * provided that the above copyright notice appear in all copies and
                               : * that both that copyright notice and this permission notice appear
                               : * in supporting documentation.  Hewlett-Packard Company makes no
                               : * representations about the suitability of this software for any
                               : * purpose.  It is provided "as is" without express or implied warranty.
                               : *
                               : *
                               : * Copyright (c) 1996,1997
                               : * Silicon Graphics Computer Systems, Inc.
                               : *
                               : * Permission to use, copy, modify, distribute and sell this software
                               : * and its documentation for any purpose is hereby granted without fee,
                               : * provided that the above copyright notice appear in all copies and
                               : * that both that copyright notice and this permission notice appear
                               : * in supporting documentation.  Silicon Graphics makes no
                               : * representations about the suitability of this software for any
                               : * purpose.  It is provided "as is" without express or implied warranty.
                               : */
                               :
                               :/** @file bits/stl_tempbuf.h
                               : *  This is an internal header file, included by other library headers.
                               : *  Do not attempt to use it directly. @headername{memory}
                               : */
                               :
                               :#ifndef _STL_TEMPBUF_H
                               :#define _STL_TEMPBUF_H 1
                               :
                               :#include <bits/stl_algobase.h>
                               :#include <bits/stl_construct.h>
                               :
                               :namespace std _GLIBCXX_VISIBILITY(default)
                               :{
                               :_GLIBCXX_BEGIN_NAMESPACE_VERSION
                               :
                               :  /**
                               :   *  @brief Allocates a temporary buffer.
                               :   *  @param  __len  The number of objects of type Tp.
                               :   *  @return See full description.
                               :   *
                               :   *  Reinventing the wheel, but this time with prettier spokes!
                               :   *
                               :   *  This function tries to obtain storage for @c __len adjacent Tp
                               :   *  objects.  The objects themselves are not constructed, of course.
                               :   *  A pair<> is returned containing <em>the buffer s address and
                               :   *  capacity (in the units of sizeof(_Tp)), or a pair of 0 values if
                               :   *  no storage can be obtained.</em>  Note that the capacity obtained
                               :   *  may be less than that requested if the memory is unavailable;
                               :   *  you should compare len with the .second return value.
                               :   *
                               :   * Provides the nothrow exception guarantee.
                               :   */
                               :  template<typename _Tp>
                               :    pair<_Tp*, ptrdiff_t>
                               :    get_temporary_buffer(ptrdiff_t __len) _GLIBCXX_NOEXCEPT
                               :    {
                               :      const ptrdiff_t __max =
                               :	__gnu_cxx::__numeric_traits<ptrdiff_t>::__max / sizeof(_Tp);
                               :      if (__len > __max)
                               :	__len = __max;
                               :      
                               :      while (__len > 0) 
                               :	{
                               :	  _Tp* __tmp = static_cast<_Tp*>(::operator new(__len * sizeof(_Tp), 
                               :							std::nothrow));
                               :	  if (__tmp != 0)
                               :	    return std::pair<_Tp*, ptrdiff_t>(__tmp, __len);
                               :	  __len /= 2;
                               :	}
                               :      return std::pair<_Tp*, ptrdiff_t>(static_cast<_Tp*>(0), 0);
                               :    }
                               :
                               :  /**
                               :   *  @brief The companion to get_temporary_buffer().
                               :   *  @param  __p  A buffer previously allocated by get_temporary_buffer.
                               :   *  @return   None.
                               :   *
                               :   *  Frees the memory pointed to by __p.
                               :   */
                               :  template<typename _Tp>
                               :    inline void
                               :    return_temporary_buffer(_Tp* __p)
     8  0.0068     0       0   :    { ::operator delete(__p, std::nothrow); }
                               :
                               :
                               :  /**
                               :   *  This class is used in two places: stl_algo.h and ext/memory,
                               :   *  where it is wrapped as the temporary_buffer class.  See
                               :   *  temporary_buffer docs for more notes.
                               :   */
                               :  template<typename _ForwardIterator, typename _Tp>
                               :    class _Temporary_buffer
                               :    {
                               :      // concept requirements
                               :      __glibcxx_class_requires(_ForwardIterator, _ForwardIteratorConcept)
                               :
                               :    public:
                               :      typedef _Tp         value_type;
                               :      typedef value_type* pointer;
                               :      typedef pointer     iterator;
                               :      typedef ptrdiff_t   size_type;
                               :
                               :    protected:
                               :      size_type  _M_original_len;
                               :      size_type  _M_len;
                               :      pointer    _M_buffer;
                               :
                               :    public:
                               :      /// As per Table mumble.
                               :      size_type
                               :      size() const
                               :      { return _M_len; }
                               :
                               :      /// Returns the size requested by the constructor; may be >size().
                               :      size_type
                               :      requested_size() const
                               :      { return _M_original_len; }
                               :
                               :      /// As per Table mumble.
                               :      iterator
                               :      begin()
                               :      { return _M_buffer; }
                               :
                               :      /// As per Table mumble.
                               :      iterator
                               :      end()
                               :      { return _M_buffer + _M_len; }
                               :
                               :      /**
                               :       * Constructs a temporary buffer of a size somewhere between
                               :       * zero and the size of the given range.
                               :       */
                               :      _Temporary_buffer(_ForwardIterator __first, _ForwardIterator __last);
                               :
                               :      ~_Temporary_buffer()
                               :      {
                               :	std::_Destroy(_M_buffer, _M_buffer + _M_len);
                               :	std::return_temporary_buffer(_M_buffer);
                               :      }
                               :
                               :    private:
                               :      // Disable copy constructor and assignment operator.
                               :      _Temporary_buffer(const _Temporary_buffer&);
                               :
                               :      void
                               :      operator=(const _Temporary_buffer&);
                               :    };
                               :
                               :
                               :  template<bool>
                               :    struct __uninitialized_construct_buf_dispatch
                               :    {
                               :      template<typename _Pointer, typename _ForwardIterator>
                               :        static void
                               :        __ucr(_Pointer __first, _Pointer __last,
                               :	      _ForwardIterator __seed)
                               :        {
                               :	  if(__first == __last)
                               :	    return;
                               :
                               :	  _Pointer __cur = __first;
                               :	  __try
                               :	    {
                               :	      std::_Construct(std::__addressof(*__first),
                               :			      _GLIBCXX_MOVE(*__seed));
                               :	      _Pointer __prev = __cur;
                               :	      ++__cur;
                               :	      for(; __cur != __last; ++__cur, ++__prev)
                               :		std::_Construct(std::__addressof(*__cur),
                               :				_GLIBCXX_MOVE(*__prev));
                               :	      *__seed = _GLIBCXX_MOVE(*__prev);
                               :	    }
                               :	  __catch(...)
                               :	    {
                               :	      std::_Destroy(__first, __cur);
                               :	      __throw_exception_again;
                               :	    }
                               :	}
                               :    };
                               :
                               :  template<>
                               :    struct __uninitialized_construct_buf_dispatch<true>
                               :    {
                               :      template<typename _Pointer, typename _ForwardIterator>
                               :        static void
                               :        __ucr(_Pointer, _Pointer, _ForwardIterator) { }
                               :    };
                               :
                               :  // Constructs objects in the range [first, last).
                               :  // Note that while these new objects will take valid values,
                               :  // their exact value is not defined. In particular they may
                               :  // be 'moved from'.
                               :  //
                               :  // While *__seed may be altered during this algorithm, it will have
                               :  // the same value when the algorithm finishes, unless one of the
                               :  // constructions throws.
                               :  //
                               :  // Requirements: _Pointer::value_type(_Tp&&) is valid.
                               :  template<typename _Pointer, typename _ForwardIterator>
                               :    inline void
                               :    __uninitialized_construct_buf(_Pointer __first, _Pointer __last,
                               :				  _ForwardIterator __seed)
                               :    {
                               :      typedef typename std::iterator_traits<_Pointer>::value_type
                               :	_ValueType;
                               :
                               :      std::__uninitialized_construct_buf_dispatch<
                               :        __has_trivial_constructor(_ValueType)>::
                               :	  __ucr(__first, __last, __seed);
                               :    }
                               :
                               :  template<typename _ForwardIterator, typename _Tp>
                               :    _Temporary_buffer<_ForwardIterator, _Tp>::
                               :    _Temporary_buffer(_ForwardIterator __first, _ForwardIterator __last)
                               :    : _M_original_len(std::distance(__first, __last)),
                               :      _M_len(0), _M_buffer(0)
                               :    {
                               :      __try
                               :	{
                               :	  std::pair<pointer, size_type> __p(std::get_temporary_buffer<
                               :					    value_type>(_M_original_len));
                               :	  _M_buffer = __p.first;
                               :	  _M_len = __p.second;
                               :	  if (_M_buffer)
                               :	    std::__uninitialized_construct_buf(_M_buffer, _M_buffer + _M_len,
                               :					       __first);
                               :	}
                               :      __catch(...)
                               :	{
                               :	  std::return_temporary_buffer(_M_buffer);
                               :	  _M_buffer = 0;
                               :	  _M_len = 0;
                               :	  __throw_exception_again;
                               :	}
                               :    }
                               :
                               :_GLIBCXX_END_NAMESPACE_VERSION
                               :} // namespace
                               :
                               :#endif /* _STL_TEMPBUF_H */
                               :
/* 
 * Total samples for file : "/home/lh/Desktop/codecraft/profile/./future_net/io.cpp"
 * 
 *      8  0.0068     0       0
 */


                               :#include "lib_record.h"
                               :#include <stdio.h>
                               :#include <stdlib.h>
                               :#include <string.h>
                               :#include <assert.h>
                               :#include <time.h>
                               :#include <sys/timeb.h>
                               :#include <errno.h>
                               :#include <unistd.h>
                               :#include <signal.h>
                               :
                               :#define MAX_LINE_LEN 4000
                               :
                               :#define INLINE  static __inline
                               :#ifdef _DEBUG
                               :#define PRINT   printf
                               :#else
                               :#define PRINT(...)
                               :#endif
                               :
                               :static char g_result[2][MAX_LINE_LEN] = {"NA", ""};
                               :static int relult_len[2] = {0, 0};
                               :
                               :INLINE void write_file(const bool cover, const char * const buff, const char * const filename);
                               :
                               :void record_result(const PATH_ID path_id, unsigned short edge)
                               :{ /* record_result(PATH_ID, unsigned short) total:      1 8.5e-04     0       0 */
                               :    if (relult_len[path_id - 1] > (MAX_LINE_LEN - 10))
                               :        return;
                               :    if (relult_len[path_id - 1] > 0)
                               :        relult_len[path_id - 1] += sprintf(g_result[path_id - 1] + relult_len[path_id - 1], "|");
     1 8.5e-04     0       0   :    relult_len[path_id - 1] += sprintf(g_result[path_id - 1] + relult_len[path_id - 1], "%d", edge);
                               :}
                               :
                               :void clear_result()
                               :{
                               :    relult_len[0] = 0;
                               :    relult_len[1] = 0;
                               :    sprintf(g_result[0], "NA");
                               :}
                               :
                               :void print_time(const char *head)
                               :{
                               :#ifdef _DEBUG
                               :    struct timeb rawtime;
                               :    struct tm * timeinfo;
                               :    ftime(&rawtime);
                               :    timeinfo = localtime(&rawtime.time);
                               :
                               :    static int ms = rawtime.millitm;
                               :    static unsigned long s = rawtime.time;
                               :    int out_ms = rawtime.millitm - ms;
                               :    unsigned long out_s = rawtime.time - s;
                               :    ms = rawtime.millitm;
                               :    s = rawtime.time;
                               :
                               :    if (out_ms < 0)
                               :    {
                               :        out_ms += 1000;
                               :        out_s -= 1;
                               :    }
                               :    printf("%s date/time is: %s \tused time is %lu s %d ms.\n", head, asctime(timeinfo), out_s, out_ms);
                               :#endif
                               :}
                               :
                               :int read_file(char ** const buff, const unsigned int spec, const char * const filename)
                               :{
                               :    FILE *fp = fopen(filename, "r"); /* read_file(char**, unsigned int, char const*) total:      9  0.0077     0       0 */
                               :    if (fp == NULL)
                               :    {
                               :        PRINT("Fail to open file %s, %s.\n", filename, strerror(errno));
                               :        return 0;
                               :    }
                               :    PRINT("Open file %s OK.\n", filename);
                               :
                               :    char line[MAX_LINE_LEN + 2];
                               :    unsigned int cnt = 0;
                               :    while ((cnt < spec) && !feof(fp))
     1 8.5e-04     0       0   :    {
                               :        line[0] = 0;
                               :        if (fgets(line, MAX_LINE_LEN + 2, fp) == NULL)  continue;
                               :        if (line[0] == 0)   continue;
                               :        buff[cnt] = (char *)malloc(MAX_LINE_LEN + 2);
     1 8.5e-04     0       0   :        strncpy(buff[cnt], line, MAX_LINE_LEN + 2 - 1);
                               :        buff[cnt][MAX_LINE_LEN + 1] = 0;
     3  0.0026     0       0   :        cnt++;
                               :    }
                               :    fclose(fp);
                               :    PRINT("There are %d lines in file %s.\n", cnt, filename);
                               :
                               :    return cnt;
                               :}
                               :
                               :void write_result(const char * const filename)
                               :{
                               :    write_file(1, g_result[0], filename);
                               :    if (g_result[0][0] == 'N')
                               :        return;
                               :    write_file(0, g_result[1], filename);
                               :}
                               :
                               :void release_buff(char ** const buff, const int valid_item_num)
                               :{
                               :    for (int i = 0; i < valid_item_num; i++) /* release_buff(char**, int) total:      2  0.0017     0       0 */
     1 8.5e-04     0       0   :        free(buff[i]);
     1 8.5e-04     0       0   :}
                               :
                               :INLINE void write_file(const bool cover, const char * const buff, const char * const filename)
                               :{
                               :    if (buff == NULL)
                               :        return;
                               :
                               :    const char *write_type = cover ? "w" : "a";//1:覆盖写文件，0:追加写文件
                               :    FILE *fp = fopen(filename, write_type);
                               :    if (fp == NULL)
                               :    {
                               :        PRINT("Fail to open file %s, %s.\n", filename, strerror(errno));
                               :        return;
                               :    }
                               :    PRINT("Open file %s OK.\n", filename);
                               :    fputs(buff, fp);
                               :    fputs("\n", fp);
                               :    fclose(fp);
                               :}
                               :
/* 
 * Total samples for file : "/usr/include/c++/4.8/bits/stl_set.h"
 * 
 *      7  0.0060     0       0
 */


                               :// Set implementation -*- C++ -*-
                               :
                               :// Copyright (C) 2001-2013 Free Software Foundation, Inc.
                               ://
                               :// This file is part of the GNU ISO C++ Library.  This library is free
                               :// software; you can redistribute it and/or modify it under the
                               :// terms of the GNU General Public License as published by the
                               :// Free Software Foundation; either version 3, or (at your option)
                               :// any later version.
                               :
                               :// This library is distributed in the hope that it will be useful,
                               :// but WITHOUT ANY WARRANTY; without even the implied warranty of
                               :// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                               :// GNU General Public License for more details.
                               :
                               :// Under Section 7 of GPL version 3, you are granted additional
                               :// permissions described in the GCC Runtime Library Exception, version
                               :// 3.1, as published by the Free Software Foundation.
                               :
                               :// You should have received a copy of the GNU General Public License and
                               :// a copy of the GCC Runtime Library Exception along with this program;
                               :// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                               :// <http://www.gnu.org/licenses/>.
                               :
                               :/*
                               : *
                               : * Copyright (c) 1994
                               : * Hewlett-Packard Company
                               : *
                               : * Permission to use, copy, modify, distribute and sell this software
                               : * and its documentation for any purpose is hereby granted without fee,
                               : * provided that the above copyright notice appear in all copies and
                               : * that both that copyright notice and this permission notice appear
                               : * in supporting documentation.  Hewlett-Packard Company makes no
                               : * representations about the suitability of this software for any
                               : * purpose.  It is provided "as is" without express or implied warranty.
                               : *
                               : *
                               : * Copyright (c) 1996,1997
                               : * Silicon Graphics Computer Systems, Inc.
                               : *
                               : * Permission to use, copy, modify, distribute and sell this software
                               : * and its documentation for any purpose is hereby granted without fee,
                               : * provided that the above copyright notice appear in all copies and
                               : * that both that copyright notice and this permission notice appear
                               : * in supporting documentation.  Silicon Graphics makes no
                               : * representations about the suitability of this software for any
                               : * purpose.  It is provided "as is" without express or implied warranty.
                               : */
                               :
                               :/** @file bits/stl_set.h
                               : *  This is an internal header file, included by other library headers.
                               : *  Do not attempt to use it directly. @headername{set}
                               : */
                               :
                               :#ifndef _STL_SET_H
                               :#define _STL_SET_H 1
                               :
                               :#include <bits/concept_check.h>
                               :#if __cplusplus >= 201103L
                               :#include <initializer_list>
                               :#endif
                               :
                               :namespace std _GLIBCXX_VISIBILITY(default)
                               :{
                               :_GLIBCXX_BEGIN_NAMESPACE_CONTAINER
                               :
                               :  /**
                               :   *  @brief A standard container made up of unique keys, which can be
                               :   *  retrieved in logarithmic time.
                               :   *
                               :   *  @ingroup associative_containers
                               :   *
                               :   *  @tparam _Key  Type of key objects.
                               :   *  @tparam _Compare  Comparison function object type, defaults to less<_Key>.
                               :   *  @tparam _Alloc  Allocator type, defaults to allocator<_Key>.
                               :   *
                               :   *  Meets the requirements of a <a href="tables.html#65">container</a>, a
                               :   *  <a href="tables.html#66">reversible container</a>, and an
                               :   *  <a href="tables.html#69">associative container</a> (using unique keys).
                               :   *
                               :   *  Sets support bidirectional iterators.
                               :   *
                               :   *  The private tree data is declared exactly the same way for set and
                               :   *  multiset; the distinction is made entirely in how the tree functions are
                               :   *  called (*_unique versus *_equal, same as the standard).
                               :  */
                               :  template<typename _Key, typename _Compare = std::less<_Key>,
                               :	   typename _Alloc = std::allocator<_Key> >
                               :    class set
                               :    {
                               :      // concept requirements
                               :      typedef typename _Alloc::value_type                   _Alloc_value_type;
                               :      __glibcxx_class_requires(_Key, _SGIAssignableConcept)
                               :      __glibcxx_class_requires4(_Compare, bool, _Key, _Key,
                               :				_BinaryFunctionConcept)
                               :      __glibcxx_class_requires2(_Key, _Alloc_value_type, _SameTypeConcept)
                               :
                               :    public:
                               :      // typedefs:
                               :      //@{
                               :      /// Public typedefs.
                               :      typedef _Key     key_type;
                               :      typedef _Key     value_type;
                               :      typedef _Compare key_compare;
                               :      typedef _Compare value_compare;
                               :      typedef _Alloc   allocator_type;
                               :      //@}
                               :
                               :    private:
                               :      typedef typename _Alloc::template rebind<_Key>::other _Key_alloc_type;
                               :
                               :      typedef _Rb_tree<key_type, value_type, _Identity<value_type>,
                               :		       key_compare, _Key_alloc_type> _Rep_type;
                               :      _Rep_type _M_t;  // Red-black tree representing set.
                               :
                               :    public:
                               :      //@{
                               :      ///  Iterator-related typedefs.
                               :      typedef typename _Key_alloc_type::pointer             pointer;
                               :      typedef typename _Key_alloc_type::const_pointer       const_pointer;
                               :      typedef typename _Key_alloc_type::reference           reference;
                               :      typedef typename _Key_alloc_type::const_reference     const_reference;
                               :      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                               :      // DR 103. set::iterator is required to be modifiable,
                               :      // but this allows modification of keys.
                               :      typedef typename _Rep_type::const_iterator            iterator;
                               :      typedef typename _Rep_type::const_iterator            const_iterator;
                               :      typedef typename _Rep_type::const_reverse_iterator    reverse_iterator;
                               :      typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;
                               :      typedef typename _Rep_type::size_type                 size_type;
                               :      typedef typename _Rep_type::difference_type           difference_type;
                               :      //@}
                               :
                               :      // allocation/deallocation
                               :      /**
                               :       *  @brief  Default constructor creates no elements.
                               :       */
                               :      set()
                               :      : _M_t() { }
                               :
                               :      /**
                               :       *  @brief  Creates a %set with no elements.
                               :       *  @param  __comp  Comparator to use.
                               :       *  @param  __a  An allocator object.
                               :       */
                               :      explicit
                               :      set(const _Compare& __comp,
                               :	  const allocator_type& __a = allocator_type())
                               :      : _M_t(__comp, _Key_alloc_type(__a)) { }
                               :
                               :      /**
                               :       *  @brief  Builds a %set from a range.
                               :       *  @param  __first  An input iterator.
                               :       *  @param  __last  An input iterator.
                               :       *
                               :       *  Create a %set consisting of copies of the elements from
                               :       *  [__first,__last).  This is linear in N if the range is
                               :       *  already sorted, and NlogN otherwise (where N is
                               :       *  distance(__first,__last)).
                               :       */
                               :      template<typename _InputIterator>
                               :	set(_InputIterator __first, _InputIterator __last)
                               :	: _M_t()
                               :	{ _M_t._M_insert_unique(__first, __last); }
                               :
                               :      /**
                               :       *  @brief  Builds a %set from a range.
                               :       *  @param  __first  An input iterator.
                               :       *  @param  __last  An input iterator.
                               :       *  @param  __comp  A comparison functor.
                               :       *  @param  __a  An allocator object.
                               :       *
                               :       *  Create a %set consisting of copies of the elements from
                               :       *  [__first,__last).  This is linear in N if the range is
                               :       *  already sorted, and NlogN otherwise (where N is
                               :       *  distance(__first,__last)).
                               :       */
                               :      template<typename _InputIterator>
                               :	set(_InputIterator __first, _InputIterator __last,
                               :	    const _Compare& __comp,
                               :	    const allocator_type& __a = allocator_type())
                               :	: _M_t(__comp, _Key_alloc_type(__a))
                               :        { _M_t._M_insert_unique(__first, __last); }
                               :
                               :      /**
                               :       *  @brief  %Set copy constructor.
                               :       *  @param  __x  A %set of identical element and allocator types.
                               :       *
                               :       *  The newly-created %set uses a copy of the allocation object used
                               :       *  by @a __x.
                               :       */
                               :      set(const set& __x)
                               :      : _M_t(__x._M_t) { }
                               :
                               :#if __cplusplus >= 201103L
                               :     /**
                               :       *  @brief %Set move constructor
                               :       *  @param __x  A %set of identical element and allocator types.
                               :       *
                               :       *  The newly-created %set contains the exact contents of @a x.
                               :       *  The contents of @a x are a valid, but unspecified %set.
                               :       */
                               :      set(set&& __x)
                               :      noexcept(is_nothrow_copy_constructible<_Compare>::value)
                               :      : _M_t(std::move(__x._M_t)) { }
                               :
                               :      /**
                               :       *  @brief  Builds a %set from an initializer_list.
                               :       *  @param  __l  An initializer_list.
                               :       *  @param  __comp  A comparison functor.
                               :       *  @param  __a  An allocator object.
                               :       *
                               :       *  Create a %set consisting of copies of the elements in the list.
                               :       *  This is linear in N if the list is already sorted, and NlogN
                               :       *  otherwise (where N is @a __l.size()).
                               :       */
                               :      set(initializer_list<value_type> __l,
                               :	  const _Compare& __comp = _Compare(),
                               :	  const allocator_type& __a = allocator_type())
                               :      : _M_t(__comp, _Key_alloc_type(__a))
                               :      { _M_t._M_insert_unique(__l.begin(), __l.end()); }
                               :#endif
                               :
                               :      /**
                               :       *  @brief  %Set assignment operator.
                               :       *  @param  __x  A %set of identical element and allocator types.
                               :       *
                               :       *  All the elements of @a __x are copied, but unlike the copy
                               :       *  constructor, the allocator object is not copied.
                               :       */
                               :      set&
                               :      operator=(const set& __x)
                               :      {
                               :	_M_t = __x._M_t;
                               :	return *this;
                               :      }
                               :
                               :#if __cplusplus >= 201103L
                               :      /**
                               :       *  @brief %Set move assignment operator.
                               :       *  @param __x  A %set of identical element and allocator types.
                               :       *
                               :       *  The contents of @a __x are moved into this %set (without copying).
                               :       *  @a __x is a valid, but unspecified %set.
                               :       */
                               :      set&
                               :      operator=(set&& __x)
                               :      {
                               :	// NB: DR 1204.
                               :	// NB: DR 675.
                               :	this->clear();
                               :	this->swap(__x);
                               :      	return *this;
                               :      }
                               :
                               :      /**
                               :       *  @brief  %Set list assignment operator.
                               :       *  @param  __l  An initializer_list.
                               :       *
                               :       *  This function fills a %set with copies of the elements in the
                               :       *  initializer list @a __l.
                               :       *
                               :       *  Note that the assignment completely changes the %set and
                               :       *  that the resulting %set's size is the same as the number
                               :       *  of elements assigned.  Old data may be lost.
                               :       */
                               :      set&
                               :      operator=(initializer_list<value_type> __l)
                               :      {
                               :	this->clear();
                               :	this->insert(__l.begin(), __l.end());
                               :	return *this;
                               :      }
                               :#endif
                               :
                               :      // accessors:
                               :
                               :      ///  Returns the comparison object with which the %set was constructed.
                               :      key_compare
                               :      key_comp() const
                               :      { return _M_t.key_comp(); }
                               :      ///  Returns the comparison object with which the %set was constructed.
                               :      value_compare
                               :      value_comp() const
                               :      { return _M_t.key_comp(); }
                               :      ///  Returns the allocator object with which the %set was constructed.
                               :      allocator_type
                               :      get_allocator() const _GLIBCXX_NOEXCEPT
                               :      { return allocator_type(_M_t.get_allocator()); }
                               :
                               :      /**
                               :       *  Returns a read-only (constant) iterator that points to the first
                               :       *  element in the %set.  Iteration is done in ascending order according
                               :       *  to the keys.
                               :       */
                               :      iterator
                               :      begin() const _GLIBCXX_NOEXCEPT
                               :      { return _M_t.begin(); }
                               :
                               :      /**
                               :       *  Returns a read-only (constant) iterator that points one past the last
                               :       *  element in the %set.  Iteration is done in ascending order according
                               :       *  to the keys.
                               :       */
                               :      iterator
                               :      end() const _GLIBCXX_NOEXCEPT
                               :      { return _M_t.end(); }
                               :
                               :      /**
                               :       *  Returns a read-only (constant) iterator that points to the last
                               :       *  element in the %set.  Iteration is done in descending order according
                               :       *  to the keys.
                               :       */
                               :      reverse_iterator
                               :      rbegin() const _GLIBCXX_NOEXCEPT
                               :      { return _M_t.rbegin(); }
                               :
                               :      /**
                               :       *  Returns a read-only (constant) reverse iterator that points to the
                               :       *  last pair in the %set.  Iteration is done in descending order
                               :       *  according to the keys.
                               :       */
                               :      reverse_iterator
                               :      rend() const _GLIBCXX_NOEXCEPT
                               :      { return _M_t.rend(); }
                               :
                               :#if __cplusplus >= 201103L
                               :      /**
                               :       *  Returns a read-only (constant) iterator that points to the first
                               :       *  element in the %set.  Iteration is done in ascending order according
                               :       *  to the keys.
                               :       */
                               :      iterator
                               :      cbegin() const noexcept
                               :      { return _M_t.begin(); }
                               :
                               :      /**
                               :       *  Returns a read-only (constant) iterator that points one past the last
                               :       *  element in the %set.  Iteration is done in ascending order according
                               :       *  to the keys.
                               :       */
                               :      iterator
                               :      cend() const noexcept
                               :      { return _M_t.end(); }
                               :
                               :      /**
                               :       *  Returns a read-only (constant) iterator that points to the last
                               :       *  element in the %set.  Iteration is done in descending order according
                               :       *  to the keys.
                               :       */
                               :      reverse_iterator
                               :      crbegin() const noexcept
                               :      { return _M_t.rbegin(); }
                               :
                               :      /**
                               :       *  Returns a read-only (constant) reverse iterator that points to the
                               :       *  last pair in the %set.  Iteration is done in descending order
                               :       *  according to the keys.
                               :       */
                               :      reverse_iterator
                               :      crend() const noexcept
                               :      { return _M_t.rend(); }
                               :#endif
                               :
                               :      ///  Returns true if the %set is empty.
                               :      bool
                               :      empty() const _GLIBCXX_NOEXCEPT
                               :      { return _M_t.empty(); }
                               :
                               :      ///  Returns the size of the %set.
                               :      size_type
                               :      size() const _GLIBCXX_NOEXCEPT
                               :      { return _M_t.size(); }
                               :
                               :      ///  Returns the maximum size of the %set.
                               :      size_type
                               :      max_size() const _GLIBCXX_NOEXCEPT
                               :      { return _M_t.max_size(); }
                               :
                               :      /**
                               :       *  @brief  Swaps data with another %set.
                               :       *  @param  __x  A %set of the same element and allocator types.
                               :       *
                               :       *  This exchanges the elements between two sets in constant
                               :       *  time.  (It is only swapping a pointer, an integer, and an
                               :       *  instance of the @c Compare type (which itself is often
                               :       *  stateless and empty), so it should be quite fast.)  Note
                               :       *  that the global std::swap() function is specialized such
                               :       *  that std::swap(s1,s2) will feed to this function.
                               :       */
                               :      void
                               :      swap(set& __x)
                               :      { _M_t.swap(__x._M_t); }
                               :
                               :      // insert/erase
                               :#if __cplusplus >= 201103L
                               :      /**
                               :       *  @brief Attempts to build and insert an element into the %set.
                               :       *  @param __args  Arguments used to generate an element.
                               :       *  @return  A pair, of which the first element is an iterator that points
                               :       *           to the possibly inserted element, and the second is a bool
                               :       *           that is true if the element was actually inserted.
                               :       *
                               :       *  This function attempts to build and insert an element into the %set.
                               :       *  A %set relies on unique keys and thus an element is only inserted if
                               :       *  it is not already present in the %set.
                               :       *
                               :       *  Insertion requires logarithmic time.
                               :       */
                               :      template<typename... _Args>
                               :	std::pair<iterator, bool>
                               :	emplace(_Args&&... __args)
                               :	{ return _M_t._M_emplace_unique(std::forward<_Args>(__args)...); }
                               :
                               :      /**
                               :       *  @brief Attempts to insert an element into the %set.
                               :       *  @param  __pos  An iterator that serves as a hint as to where the
                               :       *                element should be inserted.
                               :       *  @param  __args  Arguments used to generate the element to be
                               :       *                 inserted.
                               :       *  @return An iterator that points to the element with key equivalent to
                               :       *          the one generated from @a __args (may or may not be the
                               :       *          element itself).
                               :       *
                               :       *  This function is not concerned about whether the insertion took place,
                               :       *  and thus does not return a boolean like the single-argument emplace()
                               :       *  does.  Note that the first parameter is only a hint and can
                               :       *  potentially improve the performance of the insertion process.  A bad
                               :       *  hint would cause no gains in efficiency.
                               :       *
                               :       *  For more on @a hinting, see:
                               :       *  http://gcc.gnu.org/onlinedocs/libstdc++/manual/bk01pt07ch17.html
                               :       *
                               :       *  Insertion requires logarithmic time (if the hint is not taken).
                               :       */
                               :      template<typename... _Args>
                               :	iterator
                               :	emplace_hint(const_iterator __pos, _Args&&... __args)
                               :	{
                               :	  return _M_t._M_emplace_hint_unique(__pos,
                               :					     std::forward<_Args>(__args)...);
                               :	}
                               :#endif
                               :
                               :      /**
                               :       *  @brief Attempts to insert an element into the %set.
                               :       *  @param  __x  Element to be inserted.
                               :       *  @return  A pair, of which the first element is an iterator that points
                               :       *           to the possibly inserted element, and the second is a bool
                               :       *           that is true if the element was actually inserted.
                               :       *
                               :       *  This function attempts to insert an element into the %set.  A %set
                               :       *  relies on unique keys and thus an element is only inserted if it is
                               :       *  not already present in the %set.
                               :       *
                               :       *  Insertion requires logarithmic time.
                               :       */
                               :      std::pair<iterator, bool>
                               :      insert(const value_type& __x)
                               :      {
                               :	std::pair<typename _Rep_type::iterator, bool> __p =
     7  0.0060     0       0   :	  _M_t._M_insert_unique(__x);
                               :	return std::pair<iterator, bool>(__p.first, __p.second);
                               :      }
                               :
                               :#if __cplusplus >= 201103L
                               :      std::pair<iterator, bool>
                               :      insert(value_type&& __x)
                               :      {
                               :	std::pair<typename _Rep_type::iterator, bool> __p =
                               :	  _M_t._M_insert_unique(std::move(__x));
                               :	return std::pair<iterator, bool>(__p.first, __p.second);
                               :      }
                               :#endif
                               :
                               :      /**
                               :       *  @brief Attempts to insert an element into the %set.
                               :       *  @param  __position  An iterator that serves as a hint as to where the
                               :       *                    element should be inserted.
                               :       *  @param  __x  Element to be inserted.
                               :       *  @return An iterator that points to the element with key of
                               :       *           @a __x (may or may not be the element passed in).
                               :       *
                               :       *  This function is not concerned about whether the insertion took place,
                               :       *  and thus does not return a boolean like the single-argument insert()
                               :       *  does.  Note that the first parameter is only a hint and can
                               :       *  potentially improve the performance of the insertion process.  A bad
                               :       *  hint would cause no gains in efficiency.
                               :       *
                               :       *  For more on @a hinting, see:
                               :       *  http://gcc.gnu.org/onlinedocs/libstdc++/manual/bk01pt07ch17.html
                               :       *
                               :       *  Insertion requires logarithmic time (if the hint is not taken).
                               :       */
                               :      iterator
                               :      insert(const_iterator __position, const value_type& __x)
                               :      { return _M_t._M_insert_unique_(__position, __x); }
                               :
                               :#if __cplusplus >= 201103L
                               :      iterator
                               :      insert(const_iterator __position, value_type&& __x)
                               :      { return _M_t._M_insert_unique_(__position, std::move(__x)); }
                               :#endif
                               :
                               :      /**
                               :       *  @brief A template function that attempts to insert a range
                               :       *  of elements.
                               :       *  @param  __first  Iterator pointing to the start of the range to be
                               :       *                   inserted.
                               :       *  @param  __last  Iterator pointing to the end of the range.
                               :       *
                               :       *  Complexity similar to that of the range constructor.
                               :       */
                               :      template<typename _InputIterator>
                               :	void
                               :	insert(_InputIterator __first, _InputIterator __last)
                               :	{ _M_t._M_insert_unique(__first, __last); }
                               :
                               :#if __cplusplus >= 201103L
                               :      /**
                               :       *  @brief Attempts to insert a list of elements into the %set.
                               :       *  @param  __l  A std::initializer_list<value_type> of elements
                               :       *               to be inserted.
                               :       *
                               :       *  Complexity similar to that of the range constructor.
                               :       */
                               :      void
                               :      insert(initializer_list<value_type> __l)
                               :      { this->insert(__l.begin(), __l.end()); }
                               :#endif
                               :
                               :#if __cplusplus >= 201103L
                               :      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                               :      // DR 130. Associative erase should return an iterator.
                               :      /**
                               :       *  @brief Erases an element from a %set.
                               :       *  @param  __position  An iterator pointing to the element to be erased.
                               :       *  @return An iterator pointing to the element immediately following
                               :       *          @a __position prior to the element being erased. If no such
                               :       *          element exists, end() is returned.
                               :       *
                               :       *  This function erases an element, pointed to by the given iterator,
                               :       *  from a %set.  Note that this function only erases the element, and
                               :       *  that if the element is itself a pointer, the pointed-to memory is not
                               :       *  touched in any way.  Managing the pointer is the user's
                               :       *  responsibility.
                               :       */
                               :      _GLIBCXX_ABI_TAG_CXX11
                               :      iterator
                               :      erase(const_iterator __position)
                               :      { return _M_t.erase(__position); }
                               :#else
                               :      /**
                               :       *  @brief Erases an element from a %set.
                               :       *  @param  position  An iterator pointing to the element to be erased.
                               :       *
                               :       *  This function erases an element, pointed to by the given iterator,
                               :       *  from a %set.  Note that this function only erases the element, and
                               :       *  that if the element is itself a pointer, the pointed-to memory is not
                               :       *  touched in any way.  Managing the pointer is the user's
                               :       *  responsibility.
                               :       */
                               :      void
                               :      erase(iterator __position)
                               :      { _M_t.erase(__position); }
                               :#endif
                               :
                               :      /**
                               :       *  @brief Erases elements according to the provided key.
                               :       *  @param  __x  Key of element to be erased.
                               :       *  @return  The number of elements erased.
                               :       *
                               :       *  This function erases all the elements located by the given key from
                               :       *  a %set.
                               :       *  Note that this function only erases the element, and that if
                               :       *  the element is itself a pointer, the pointed-to memory is not touched
                               :       *  in any way.  Managing the pointer is the user's responsibility.
                               :       */
                               :      size_type
                               :      erase(const key_type& __x)
                               :      { return _M_t.erase(__x); }
                               :
                               :#if __cplusplus >= 201103L
                               :      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                               :      // DR 130. Associative erase should return an iterator.
                               :      /**
                               :       *  @brief Erases a [__first,__last) range of elements from a %set.
                               :       *  @param  __first  Iterator pointing to the start of the range to be
                               :       *                 erased.
                               :
                               :       *  @param __last Iterator pointing to the end of the range to
                               :       *  be erased.
                               :       *  @return The iterator @a __last.
                               :       *
                               :       *  This function erases a sequence of elements from a %set.
                               :       *  Note that this function only erases the element, and that if
                               :       *  the element is itself a pointer, the pointed-to memory is not touched
                               :       *  in any way.  Managing the pointer is the user's responsibility.
                               :       */
                               :      _GLIBCXX_ABI_TAG_CXX11
                               :      iterator
                               :      erase(const_iterator __first, const_iterator __last)
                               :      { return _M_t.erase(__first, __last); }
                               :#else
                               :      /**
                               :       *  @brief Erases a [first,last) range of elements from a %set.
                               :       *  @param  __first  Iterator pointing to the start of the range to be
                               :       *                 erased.
                               :       *  @param __last Iterator pointing to the end of the range to
                               :       *  be erased.
                               :       *
                               :       *  This function erases a sequence of elements from a %set.
                               :       *  Note that this function only erases the element, and that if
                               :       *  the element is itself a pointer, the pointed-to memory is not touched
                               :       *  in any way.  Managing the pointer is the user's responsibility.
                               :       */
                               :      void
                               :      erase(iterator __first, iterator __last)
                               :      { _M_t.erase(__first, __last); }
                               :#endif
                               :
                               :      /**
                               :       *  Erases all elements in a %set.  Note that this function only erases
                               :       *  the elements, and that if the elements themselves are pointers, the
                               :       *  pointed-to memory is not touched in any way.  Managing the pointer is
                               :       *  the user's responsibility.
                               :       */
                               :      void
                               :      clear() _GLIBCXX_NOEXCEPT
                               :      { _M_t.clear(); }
                               :
                               :      // set operations:
                               :
                               :      /**
                               :       *  @brief  Finds the number of elements.
                               :       *  @param  __x  Element to located.
                               :       *  @return  Number of elements with specified key.
                               :       *
                               :       *  This function only makes sense for multisets; for set the result will
                               :       *  either be 0 (not present) or 1 (present).
                               :       */
                               :      size_type
                               :      count(const key_type& __x) const
                               :      { return _M_t.find(__x) == _M_t.end() ? 0 : 1; }
                               :
                               :      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                               :      // 214.  set::find() missing const overload
                               :      //@{
                               :      /**
                               :       *  @brief Tries to locate an element in a %set.
                               :       *  @param  __x  Element to be located.
                               :       *  @return  Iterator pointing to sought-after element, or end() if not
                               :       *           found.
                               :       *
                               :       *  This function takes a key and tries to locate the element with which
                               :       *  the key matches.  If successful the function returns an iterator
                               :       *  pointing to the sought after element.  If unsuccessful it returns the
                               :       *  past-the-end ( @c end() ) iterator.
                               :       */
                               :      iterator
                               :      find(const key_type& __x)
                               :      { return _M_t.find(__x); }
                               :
                               :      const_iterator
                               :      find(const key_type& __x) const
                               :      { return _M_t.find(__x); }
                               :      //@}
                               :
                               :      //@{
                               :      /**
                               :       *  @brief Finds the beginning of a subsequence matching given key.
                               :       *  @param  __x  Key to be located.
                               :       *  @return  Iterator pointing to first element equal to or greater
                               :       *           than key, or end().
                               :       *
                               :       *  This function returns the first element of a subsequence of elements
                               :       *  that matches the given key.  If unsuccessful it returns an iterator
                               :       *  pointing to the first element that has a greater value than given key
                               :       *  or end() if no such element exists.
                               :       */
                               :      iterator
                               :      lower_bound(const key_type& __x)
                               :      { return _M_t.lower_bound(__x); }
                               :
                               :      const_iterator
                               :      lower_bound(const key_type& __x) const
                               :      { return _M_t.lower_bound(__x); }
                               :      //@}
                               :
                               :      //@{
                               :      /**
                               :       *  @brief Finds the end of a subsequence matching given key.
                               :       *  @param  __x  Key to be located.
                               :       *  @return Iterator pointing to the first element
                               :       *          greater than key, or end().
                               :       */
                               :      iterator
                               :      upper_bound(const key_type& __x)
                               :      { return _M_t.upper_bound(__x); }
                               :
                               :      const_iterator
                               :      upper_bound(const key_type& __x) const
                               :      { return _M_t.upper_bound(__x); }
                               :      //@}
                               :
                               :      //@{
                               :      /**
                               :       *  @brief Finds a subsequence matching given key.
                               :       *  @param  __x  Key to be located.
                               :       *  @return  Pair of iterators that possibly points to the subsequence
                               :       *           matching given key.
                               :       *
                               :       *  This function is equivalent to
                               :       *  @code
                               :       *    std::make_pair(c.lower_bound(val),
                               :       *                   c.upper_bound(val))
                               :       *  @endcode
                               :       *  (but is faster than making the calls separately).
                               :       *
                               :       *  This function probably only makes sense for multisets.
                               :       */
                               :      std::pair<iterator, iterator>
                               :      equal_range(const key_type& __x)
                               :      { return _M_t.equal_range(__x); }
                               :
                               :      std::pair<const_iterator, const_iterator>
                               :      equal_range(const key_type& __x) const
                               :      { return _M_t.equal_range(__x); }
                               :      //@}
                               :
                               :      template<typename _K1, typename _C1, typename _A1>
                               :	friend bool
                               :	operator==(const set<_K1, _C1, _A1>&, const set<_K1, _C1, _A1>&);
                               :
                               :      template<typename _K1, typename _C1, typename _A1>
                               :	friend bool
                               :	operator<(const set<_K1, _C1, _A1>&, const set<_K1, _C1, _A1>&);
                               :    };
                               :
                               :
                               :  /**
                               :   *  @brief  Set equality comparison.
                               :   *  @param  __x  A %set.
                               :   *  @param  __y  A %set of the same type as @a x.
                               :   *  @return  True iff the size and elements of the sets are equal.
                               :   *
                               :   *  This is an equivalence relation.  It is linear in the size of the sets.
                               :   *  Sets are considered equivalent if their sizes are equal, and if
                               :   *  corresponding elements compare equal.
                               :  */
                               :  template<typename _Key, typename _Compare, typename _Alloc>
                               :    inline bool
                               :    operator==(const set<_Key, _Compare, _Alloc>& __x,
                               :	       const set<_Key, _Compare, _Alloc>& __y)
                               :    { return __x._M_t == __y._M_t; }
                               :
                               :  /**
                               :   *  @brief  Set ordering relation.
                               :   *  @param  __x  A %set.
                               :   *  @param  __y  A %set of the same type as @a x.
                               :   *  @return  True iff @a __x is lexicographically less than @a __y.
                               :   *
                               :   *  This is a total ordering relation.  It is linear in the size of the
                               :   *  maps.  The elements must be comparable with @c <.
                               :   *
                               :   *  See std::lexicographical_compare() for how the determination is made.
                               :  */
                               :  template<typename _Key, typename _Compare, typename _Alloc>
                               :    inline bool
                               :    operator<(const set<_Key, _Compare, _Alloc>& __x,
                               :	      const set<_Key, _Compare, _Alloc>& __y)
                               :    { return __x._M_t < __y._M_t; }
                               :
                               :  ///  Returns !(x == y).
                               :  template<typename _Key, typename _Compare, typename _Alloc>
                               :    inline bool
                               :    operator!=(const set<_Key, _Compare, _Alloc>& __x,
                               :	       const set<_Key, _Compare, _Alloc>& __y)
                               :    { return !(__x == __y); }
                               :
                               :  ///  Returns y < x.
                               :  template<typename _Key, typename _Compare, typename _Alloc>
                               :    inline bool
                               :    operator>(const set<_Key, _Compare, _Alloc>& __x,
                               :	      const set<_Key, _Compare, _Alloc>& __y)
                               :    { return __y < __x; }
                               :
                               :  ///  Returns !(y < x)
                               :  template<typename _Key, typename _Compare, typename _Alloc>
                               :    inline bool
                               :    operator<=(const set<_Key, _Compare, _Alloc>& __x,
                               :	       const set<_Key, _Compare, _Alloc>& __y)
                               :    { return !(__y < __x); }
                               :
                               :  ///  Returns !(x < y)
                               :  template<typename _Key, typename _Compare, typename _Alloc>
                               :    inline bool
                               :    operator>=(const set<_Key, _Compare, _Alloc>& __x,
                               :	       const set<_Key, _Compare, _Alloc>& __y)
                               :    { return !(__x < __y); }
                               :
                               :  /// See std::set::swap().
                               :  template<typename _Key, typename _Compare, typename _Alloc>
                               :    inline void
                               :    swap(set<_Key, _Compare, _Alloc>& __x, set<_Key, _Compare, _Alloc>& __y)
                               :    { __x.swap(__y); }
                               :
                               :_GLIBCXX_END_NAMESPACE_CONTAINER
                               :} //namespace std
                               :#endif /* _STL_SET_H */
/* 
 * Total samples for file : "/usr/include/c++/4.8/bits/deque.tcc"
 * 
 *      3  0.0026     0       0
 */


                               :// Deque implementation (out of line) -*- C++ -*-
                               :
                               :// Copyright (C) 2001-2013 Free Software Foundation, Inc.
                               ://
                               :// This file is part of the GNU ISO C++ Library.  This library is free
                               :// software; you can redistribute it and/or modify it under the
                               :// terms of the GNU General Public License as published by the
                               :// Free Software Foundation; either version 3, or (at your option)
                               :// any later version.
                               :
                               :// This library is distributed in the hope that it will be useful,
                               :// but WITHOUT ANY WARRANTY; without even the implied warranty of
                               :// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                               :// GNU General Public License for more details.
                               :
                               :// Under Section 7 of GPL version 3, you are granted additional
                               :// permissions described in the GCC Runtime Library Exception, version
                               :// 3.1, as published by the Free Software Foundation.
                               :
                               :// You should have received a copy of the GNU General Public License and
                               :// a copy of the GCC Runtime Library Exception along with this program;
                               :// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                               :// <http://www.gnu.org/licenses/>.
                               :
                               :/*
                               : *
                               : * Copyright (c) 1994
                               : * Hewlett-Packard Company
                               : *
                               : * Permission to use, copy, modify, distribute and sell this software
                               : * and its documentation for any purpose is hereby granted without fee,
                               : * provided that the above copyright notice appear in all copies and
                               : * that both that copyright notice and this permission notice appear
                               : * in supporting documentation.  Hewlett-Packard Company makes no
                               : * representations about the suitability of this software for any
                               : * purpose.  It is provided "as is" without express or implied warranty.
                               : *
                               : *
                               : * Copyright (c) 1997
                               : * Silicon Graphics Computer Systems, Inc.
                               : *
                               : * Permission to use, copy, modify, distribute and sell this software
                               : * and its documentation for any purpose is hereby granted without fee,
                               : * provided that the above copyright notice appear in all copies and
                               : * that both that copyright notice and this permission notice appear
                               : * in supporting documentation.  Silicon Graphics makes no
                               : * representations about the suitability of this software for any
                               : * purpose.  It is provided "as is" without express or implied warranty.
                               : */
                               :
                               :/** @file bits/deque.tcc
                               : *  This is an internal header file, included by other library headers.
                               : *  Do not attempt to use it directly. @headername{deque}
                               : */
                               :
                               :#ifndef _DEQUE_TCC
                               :#define _DEQUE_TCC 1
                               :
                               :namespace std _GLIBCXX_VISIBILITY(default)
                               :{
                               :_GLIBCXX_BEGIN_NAMESPACE_CONTAINER
                               :
                               :#if __cplusplus >= 201103L
                               :  template <typename _Tp, typename _Alloc>
                               :    void
                               :    deque<_Tp, _Alloc>::
                               :    _M_default_initialize()
                               :    {
                               :      _Map_pointer __cur;
                               :      __try
                               :        {
                               :          for (__cur = this->_M_impl._M_start._M_node;
                               :	       __cur < this->_M_impl._M_finish._M_node;
                               :	       ++__cur)
                               :            std::__uninitialized_default_a(*__cur, *__cur + _S_buffer_size(),
                               :					   _M_get_Tp_allocator());
                               :          std::__uninitialized_default_a(this->_M_impl._M_finish._M_first,
                               :					 this->_M_impl._M_finish._M_cur,
                               :					 _M_get_Tp_allocator());
                               :        }
                               :      __catch(...)
                               :        {
                               :          std::_Destroy(this->_M_impl._M_start, iterator(*__cur, __cur),
                               :			_M_get_Tp_allocator());
                               :          __throw_exception_again;
                               :        }
                               :    }
                               :#endif
                               :
                               :  template <typename _Tp, typename _Alloc>
                               :    deque<_Tp, _Alloc>&
                               :    deque<_Tp, _Alloc>::
                               :    operator=(const deque& __x)
                               :    {
                               :      const size_type __len = size();
                               :      if (&__x != this)
                               :	{
                               :	  if (__len >= __x.size())
                               :	    _M_erase_at_end(std::copy(__x.begin(), __x.end(),
                               :				      this->_M_impl._M_start));
                               :	  else
                               :	    {
                               :	      const_iterator __mid = __x.begin() + difference_type(__len);
                               :	      std::copy(__x.begin(), __mid, this->_M_impl._M_start);
                               :	      insert(this->_M_impl._M_finish, __mid, __x.end());
                               :	    }
                               :	}
                               :      return *this;
                               :    }
                               :
                               :#if __cplusplus >= 201103L
                               :  template<typename _Tp, typename _Alloc>
                               :    template<typename... _Args>
                               :      void
                               :      deque<_Tp, _Alloc>::
                               :      emplace_front(_Args&&... __args)
                               :      {
                               :	if (this->_M_impl._M_start._M_cur != this->_M_impl._M_start._M_first)
                               :	  {
                               :	    this->_M_impl.construct(this->_M_impl._M_start._M_cur - 1,
                               :				    std::forward<_Args>(__args)...);
                               :	    --this->_M_impl._M_start._M_cur;
                               :	  }
                               :	else
                               :	  _M_push_front_aux(std::forward<_Args>(__args)...);
                               :      }
                               :
                               :  template<typename _Tp, typename _Alloc>
                               :    template<typename... _Args>
                               :      void
                               :      deque<_Tp, _Alloc>::
                               :      emplace_back(_Args&&... __args)
                               :      {
                               :	if (this->_M_impl._M_finish._M_cur
                               :	    != this->_M_impl._M_finish._M_last - 1)
                               :	  {
                               :	    this->_M_impl.construct(this->_M_impl._M_finish._M_cur,
                               :				    std::forward<_Args>(__args)...);
                               :	    ++this->_M_impl._M_finish._M_cur;
                               :	  }
                               :	else
                               :	  _M_push_back_aux(std::forward<_Args>(__args)...);
                               :      }
                               :#endif
                               :
                               :  template <typename _Tp, typename _Alloc>
                               :    typename deque<_Tp, _Alloc>::iterator
                               :    deque<_Tp, _Alloc>::
                               :    insert(iterator __position, const value_type& __x)
                               :    {
                               :      if (__position._M_cur == this->_M_impl._M_start._M_cur)
                               :	{
                               :	  push_front(__x);
                               :	  return this->_M_impl._M_start;
                               :	}
                               :      else if (__position._M_cur == this->_M_impl._M_finish._M_cur)
                               :	{
                               :	  push_back(__x);
                               :	  iterator __tmp = this->_M_impl._M_finish;
                               :	  --__tmp;
                               :	  return __tmp;
                               :	}
                               :      else
                               :        return _M_insert_aux(__position, __x);
                               :    }
                               :
                               :#if __cplusplus >= 201103L
                               :  template<typename _Tp, typename _Alloc>
                               :    template<typename... _Args>
                               :      typename deque<_Tp, _Alloc>::iterator
                               :      deque<_Tp, _Alloc>::
                               :      emplace(iterator __position, _Args&&... __args)
                               :      {
                               :	if (__position._M_cur == this->_M_impl._M_start._M_cur)
                               :	  {
                               :	    emplace_front(std::forward<_Args>(__args)...);
                               :	    return this->_M_impl._M_start;
                               :	  }
                               :	else if (__position._M_cur == this->_M_impl._M_finish._M_cur)
                               :	  {
                               :	    emplace_back(std::forward<_Args>(__args)...);
                               :	    iterator __tmp = this->_M_impl._M_finish;
                               :	    --__tmp;
                               :	    return __tmp;
                               :	  }
                               :	else
                               :	  return _M_insert_aux(__position, std::forward<_Args>(__args)...);
                               :      }
                               :#endif
                               :
                               :  template <typename _Tp, typename _Alloc>
                               :    typename deque<_Tp, _Alloc>::iterator
                               :    deque<_Tp, _Alloc>::
                               :    erase(iterator __position)
                               :    {
                               :      iterator __next = __position;
                               :      ++__next;
                               :      const difference_type __index = __position - begin();
                               :      if (static_cast<size_type>(__index) < (size() >> 1))
                               :	{
                               :	  if (__position != begin())
                               :	    _GLIBCXX_MOVE_BACKWARD3(begin(), __position, __next);
                               :	  pop_front();
                               :	}
                               :      else
                               :	{
                               :	  if (__next != end())
                               :	    _GLIBCXX_MOVE3(__next, end(), __position);
                               :	  pop_back();
                               :	}
                               :      return begin() + __index;
                               :    }
                               :
                               :  template <typename _Tp, typename _Alloc>
                               :    typename deque<_Tp, _Alloc>::iterator
                               :    deque<_Tp, _Alloc>::
                               :    erase(iterator __first, iterator __last)
                               :    {
                               :      if (__first == __last)
                               :	return __first;
                               :      else if (__first == begin() && __last == end())
                               :	{
                               :	  clear();
                               :	  return end();
                               :	}
                               :      else
                               :	{
                               :	  const difference_type __n = __last - __first;
                               :	  const difference_type __elems_before = __first - begin();
                               :	  if (static_cast<size_type>(__elems_before) <= (size() - __n) / 2)
                               :	    {
                               :	      if (__first != begin())
                               :		_GLIBCXX_MOVE_BACKWARD3(begin(), __first, __last);
                               :	      _M_erase_at_begin(begin() + __n);
                               :	    }
                               :	  else
                               :	    {
                               :	      if (__last != end())
                               :		_GLIBCXX_MOVE3(__last, end(), __first);
                               :	      _M_erase_at_end(end() - __n);
                               :	    }
                               :	  return begin() + __elems_before;
                               :	}
                               :    }
                               :
                               :  template <typename _Tp, class _Alloc>
                               :    template <typename _InputIterator>
                               :      void
                               :      deque<_Tp, _Alloc>::
                               :      _M_assign_aux(_InputIterator __first, _InputIterator __last,
                               :		    std::input_iterator_tag)
                               :      {
                               :        iterator __cur = begin();
                               :        for (; __first != __last && __cur != end(); ++__cur, ++__first)
                               :          *__cur = *__first;
                               :        if (__first == __last)
                               :          _M_erase_at_end(__cur);
                               :        else
                               :          insert(end(), __first, __last);
                               :      }
                               :
                               :  template <typename _Tp, typename _Alloc>
                               :    void
                               :    deque<_Tp, _Alloc>::
                               :    _M_fill_insert(iterator __pos, size_type __n, const value_type& __x)
                               :    {
                               :      if (__pos._M_cur == this->_M_impl._M_start._M_cur)
                               :	{
                               :	  iterator __new_start = _M_reserve_elements_at_front(__n);
                               :	  __try
                               :	    {
                               :	      std::__uninitialized_fill_a(__new_start, this->_M_impl._M_start,
                               :					  __x, _M_get_Tp_allocator());
                               :	      this->_M_impl._M_start = __new_start;
                               :	    }
                               :	  __catch(...)
                               :	    {
                               :	      _M_destroy_nodes(__new_start._M_node,
                               :			       this->_M_impl._M_start._M_node);
                               :	      __throw_exception_again;
                               :	    }
                               :	}
                               :      else if (__pos._M_cur == this->_M_impl._M_finish._M_cur)
                               :	{
                               :	  iterator __new_finish = _M_reserve_elements_at_back(__n);
                               :	  __try
                               :	    {
                               :	      std::__uninitialized_fill_a(this->_M_impl._M_finish,
                               :					  __new_finish, __x,
                               :					  _M_get_Tp_allocator());
                               :	      this->_M_impl._M_finish = __new_finish;
                               :	    }
                               :	  __catch(...)
                               :	    {
                               :	      _M_destroy_nodes(this->_M_impl._M_finish._M_node + 1,
                               :			       __new_finish._M_node + 1);
                               :	      __throw_exception_again;
                               :	    }
                               :	}
                               :      else
                               :        _M_insert_aux(__pos, __n, __x);
                               :    }
                               :
                               :#if __cplusplus >= 201103L
                               :  template <typename _Tp, typename _Alloc>
                               :    void
                               :    deque<_Tp, _Alloc>::
                               :    _M_default_append(size_type __n)
                               :    {
                               :      if (__n)
                               :	{
                               :	  iterator __new_finish = _M_reserve_elements_at_back(__n);
                               :	  __try
                               :	    {
                               :	      std::__uninitialized_default_a(this->_M_impl._M_finish,
                               :					     __new_finish,
                               :					     _M_get_Tp_allocator());
                               :	      this->_M_impl._M_finish = __new_finish;
                               :	    }
                               :	  __catch(...)
                               :	    {
                               :	      _M_destroy_nodes(this->_M_impl._M_finish._M_node + 1,
                               :			       __new_finish._M_node + 1);
                               :	      __throw_exception_again;
                               :	    }
                               :	}
                               :    }
                               :
                               :  template <typename _Tp, typename _Alloc>
                               :    bool
                               :    deque<_Tp, _Alloc>::
                               :    _M_shrink_to_fit()
                               :    {
                               :      const difference_type __front_capacity
                               :	= (this->_M_impl._M_start._M_cur - this->_M_impl._M_start._M_first);
                               :      if (__front_capacity == 0)
                               :	return false;
                               :
                               :      const difference_type __back_capacity
                               :	= (this->_M_impl._M_finish._M_last - this->_M_impl._M_finish._M_cur);
                               :      if (__front_capacity + __back_capacity < _S_buffer_size())
                               :	return false;
                               :
                               :      return std::__shrink_to_fit_aux<deque>::_S_do_it(*this);
                               :    }
                               :#endif
                               :
                               :  template <typename _Tp, typename _Alloc>
                               :    void
                               :    deque<_Tp, _Alloc>::
                               :    _M_fill_initialize(const value_type& __value)
                               :    {
                               :      _Map_pointer __cur;
                               :      __try
                               :        {
                               :          for (__cur = this->_M_impl._M_start._M_node;
                               :	       __cur < this->_M_impl._M_finish._M_node;
                               :	       ++__cur)
                               :            std::__uninitialized_fill_a(*__cur, *__cur + _S_buffer_size(),
                               :					__value, _M_get_Tp_allocator());
                               :          std::__uninitialized_fill_a(this->_M_impl._M_finish._M_first,
                               :				      this->_M_impl._M_finish._M_cur,
                               :				      __value, _M_get_Tp_allocator());
                               :        }
                               :      __catch(...)
                               :        {
                               :          std::_Destroy(this->_M_impl._M_start, iterator(*__cur, __cur),
                               :			_M_get_Tp_allocator());
                               :          __throw_exception_again;
                               :        }
                               :    }
                               :
                               :  template <typename _Tp, typename _Alloc>
                               :    template <typename _InputIterator>
                               :      void
                               :      deque<_Tp, _Alloc>::
                               :      _M_range_initialize(_InputIterator __first, _InputIterator __last,
                               :                          std::input_iterator_tag)
                               :      {
                               :        this->_M_initialize_map(0);
                               :        __try
                               :          {
                               :            for (; __first != __last; ++__first)
                               :#if __cplusplus >= 201103L
                               :	      emplace_back(*__first);
                               :#else
                               :              push_back(*__first);
                               :#endif
                               :          }
                               :        __catch(...)
                               :          {
                               :            clear();
                               :            __throw_exception_again;
                               :          }
                               :      }
                               :
                               :  template <typename _Tp, typename _Alloc>
                               :    template <typename _ForwardIterator>
                               :      void
                               :      deque<_Tp, _Alloc>::
                               :      _M_range_initialize(_ForwardIterator __first, _ForwardIterator __last,
                               :                          std::forward_iterator_tag)
                               :      {
                               :        const size_type __n = std::distance(__first, __last);
                               :        this->_M_initialize_map(__n);
                               :
                               :        _Map_pointer __cur_node;
                               :        __try
                               :          {
                               :            for (__cur_node = this->_M_impl._M_start._M_node;
                               :                 __cur_node < this->_M_impl._M_finish._M_node;
                               :                 ++__cur_node)
                               :	      {
                               :		_ForwardIterator __mid = __first;
                               :		std::advance(__mid, _S_buffer_size());
                               :		std::__uninitialized_copy_a(__first, __mid, *__cur_node,
                               :					    _M_get_Tp_allocator());
                               :		__first = __mid;
                               :	      }
                               :            std::__uninitialized_copy_a(__first, __last,
                               :					this->_M_impl._M_finish._M_first,
                               :					_M_get_Tp_allocator());
                               :          }
                               :        __catch(...)
                               :          {
                               :            std::_Destroy(this->_M_impl._M_start,
                               :			  iterator(*__cur_node, __cur_node),
                               :			  _M_get_Tp_allocator());
                               :            __throw_exception_again;
                               :          }
                               :      }
                               :
                               :  // Called only if _M_impl._M_finish._M_cur == _M_impl._M_finish._M_last - 1.
                               :  template<typename _Tp, typename _Alloc>
                               :#if __cplusplus >= 201103L
                               :    template<typename... _Args>
                               :      void
                               :      deque<_Tp, _Alloc>::
                               :      _M_push_back_aux(_Args&&... __args)
                               :#else
                               :      void
                               :      deque<_Tp, _Alloc>::
                               :      _M_push_back_aux(const value_type& __t)
                               :#endif
                               :      {
                               :	_M_reserve_map_at_back();
                               :	*(this->_M_impl._M_finish._M_node + 1) = this->_M_allocate_node();
                               :	__try
                               :	  {
                               :#if __cplusplus >= 201103L
                               :	    this->_M_impl.construct(this->_M_impl._M_finish._M_cur,
                               :				    std::forward<_Args>(__args)...);
                               :#else
                               :	    this->_M_impl.construct(this->_M_impl._M_finish._M_cur, __t);
                               :#endif
                               :	    this->_M_impl._M_finish._M_set_node(this->_M_impl._M_finish._M_node
                               :						+ 1);
                               :	    this->_M_impl._M_finish._M_cur = this->_M_impl._M_finish._M_first;
                               :	  }
                               :	__catch(...)
                               :	  {
                               :	    _M_deallocate_node(*(this->_M_impl._M_finish._M_node + 1));
                               :	    __throw_exception_again;
                               :	  }
                               :      }
                               :
                               :  // Called only if _M_impl._M_start._M_cur == _M_impl._M_start._M_first.
                               :  template<typename _Tp, typename _Alloc>
                               :#if __cplusplus >= 201103L
                               :    template<typename... _Args>
                               :      void
                               :      deque<_Tp, _Alloc>::
                               :      _M_push_front_aux(_Args&&... __args)
                               :#else
                               :      void
                               :      deque<_Tp, _Alloc>::
                               :      _M_push_front_aux(const value_type& __t)
                               :#endif
                               :      {
                               :	_M_reserve_map_at_front();
                               :	*(this->_M_impl._M_start._M_node - 1) = this->_M_allocate_node();
                               :	__try
                               :	  {
                               :	    this->_M_impl._M_start._M_set_node(this->_M_impl._M_start._M_node
                               :					       - 1);
                               :	    this->_M_impl._M_start._M_cur = this->_M_impl._M_start._M_last - 1;
                               :#if __cplusplus >= 201103L
                               :	    this->_M_impl.construct(this->_M_impl._M_start._M_cur,
                               :				    std::forward<_Args>(__args)...);
                               :#else
                               :	    this->_M_impl.construct(this->_M_impl._M_start._M_cur, __t);
                               :#endif
                               :	  }
                               :	__catch(...)
                               :	  {
                               :	    ++this->_M_impl._M_start;
                               :	    _M_deallocate_node(*(this->_M_impl._M_start._M_node - 1));
                               :	    __throw_exception_again;
                               :	  }
                               :      }
                               :
                               :  // Called only if _M_impl._M_finish._M_cur == _M_impl._M_finish._M_first.
                               :  template <typename _Tp, typename _Alloc>
                               :    void deque<_Tp, _Alloc>::
                               :    _M_pop_back_aux()
                               :    {
                               :      _M_deallocate_node(this->_M_impl._M_finish._M_first);
                               :      this->_M_impl._M_finish._M_set_node(this->_M_impl._M_finish._M_node - 1);
                               :      this->_M_impl._M_finish._M_cur = this->_M_impl._M_finish._M_last - 1;
                               :      this->_M_impl.destroy(this->_M_impl._M_finish._M_cur);
                               :    }
                               :
                               :  // Called only if _M_impl._M_start._M_cur == _M_impl._M_start._M_last - 1.
                               :  // Note that if the deque has at least one element (a precondition for this
                               :  // member function), and if
                               :  //   _M_impl._M_start._M_cur == _M_impl._M_start._M_last,
                               :  // then the deque must have at least two nodes.
                               :  template <typename _Tp, typename _Alloc>
                               :    void deque<_Tp, _Alloc>::
                               :    _M_pop_front_aux()
                               :    {
                               :      this->_M_impl.destroy(this->_M_impl._M_start._M_cur);
                               :      _M_deallocate_node(this->_M_impl._M_start._M_first);
                               :      this->_M_impl._M_start._M_set_node(this->_M_impl._M_start._M_node + 1);
     1 8.5e-04     0       0   :      this->_M_impl._M_start._M_cur = this->_M_impl._M_start._M_first;
                               :    }
                               :
                               :  template <typename _Tp, typename _Alloc>
                               :    template <typename _InputIterator>
                               :      void
                               :      deque<_Tp, _Alloc>::
                               :      _M_range_insert_aux(iterator __pos,
                               :                          _InputIterator __first, _InputIterator __last,
                               :                          std::input_iterator_tag)
                               :      { std::copy(__first, __last, std::inserter(*this, __pos)); }
                               :
                               :  template <typename _Tp, typename _Alloc>
                               :    template <typename _ForwardIterator>
                               :      void
                               :      deque<_Tp, _Alloc>::
                               :      _M_range_insert_aux(iterator __pos,
                               :                          _ForwardIterator __first, _ForwardIterator __last,
                               :                          std::forward_iterator_tag)
                               :      {
                               :        const size_type __n = std::distance(__first, __last);
                               :        if (__pos._M_cur == this->_M_impl._M_start._M_cur)
                               :	  {
                               :	    iterator __new_start = _M_reserve_elements_at_front(__n);
                               :	    __try
                               :	      {
                               :		std::__uninitialized_copy_a(__first, __last, __new_start,
                               :					    _M_get_Tp_allocator());
                               :		this->_M_impl._M_start = __new_start;
                               :	      }
                               :	    __catch(...)
                               :	      {
                               :		_M_destroy_nodes(__new_start._M_node,
                               :				 this->_M_impl._M_start._M_node);
                               :		__throw_exception_again;
                               :	      }
                               :	  }
                               :        else if (__pos._M_cur == this->_M_impl._M_finish._M_cur)
                               :	  {
                               :	    iterator __new_finish = _M_reserve_elements_at_back(__n);
                               :	    __try
                               :	      {
                               :		std::__uninitialized_copy_a(__first, __last,
                               :					    this->_M_impl._M_finish,
                               :					    _M_get_Tp_allocator());
                               :		this->_M_impl._M_finish = __new_finish;
                               :	      }
                               :	    __catch(...)
                               :	      {
                               :		_M_destroy_nodes(this->_M_impl._M_finish._M_node + 1,
                               :				 __new_finish._M_node + 1);
                               :		__throw_exception_again;
                               :	      }
                               :	  }
                               :        else
                               :          _M_insert_aux(__pos, __first, __last, __n);
                               :      }
                               :
                               :  template<typename _Tp, typename _Alloc>
                               :#if __cplusplus >= 201103L
                               :    template<typename... _Args>
                               :      typename deque<_Tp, _Alloc>::iterator
                               :      deque<_Tp, _Alloc>::
                               :      _M_insert_aux(iterator __pos, _Args&&... __args)
                               :      {
                               :	value_type __x_copy(std::forward<_Args>(__args)...); // XXX copy
                               :#else
                               :    typename deque<_Tp, _Alloc>::iterator
                               :      deque<_Tp, _Alloc>::
                               :      _M_insert_aux(iterator __pos, const value_type& __x)
                               :      {
                               :	value_type __x_copy = __x; // XXX copy
                               :#endif
                               :	difference_type __index = __pos - this->_M_impl._M_start;
                               :	if (static_cast<size_type>(__index) < size() / 2)
                               :	  {
                               :	    push_front(_GLIBCXX_MOVE(front()));
                               :	    iterator __front1 = this->_M_impl._M_start;
                               :	    ++__front1;
                               :	    iterator __front2 = __front1;
                               :	    ++__front2;
                               :	    __pos = this->_M_impl._M_start + __index;
                               :	    iterator __pos1 = __pos;
                               :	    ++__pos1;
                               :	    _GLIBCXX_MOVE3(__front2, __pos1, __front1);
                               :	  }
                               :	else
                               :	  {
                               :	    push_back(_GLIBCXX_MOVE(back()));
                               :	    iterator __back1 = this->_M_impl._M_finish;
                               :	    --__back1;
                               :	    iterator __back2 = __back1;
                               :	    --__back2;
                               :	    __pos = this->_M_impl._M_start + __index;
                               :	    _GLIBCXX_MOVE_BACKWARD3(__pos, __back2, __back1);
                               :	  }
                               :	*__pos = _GLIBCXX_MOVE(__x_copy);
                               :	return __pos;
                               :      }
                               :
                               :  template <typename _Tp, typename _Alloc>
                               :    void
                               :    deque<_Tp, _Alloc>::
                               :    _M_insert_aux(iterator __pos, size_type __n, const value_type& __x)
                               :    {
                               :      const difference_type __elems_before = __pos - this->_M_impl._M_start;
                               :      const size_type __length = this->size();
                               :      value_type __x_copy = __x;
                               :      if (__elems_before < difference_type(__length / 2))
                               :	{
                               :	  iterator __new_start = _M_reserve_elements_at_front(__n);
                               :	  iterator __old_start = this->_M_impl._M_start;
                               :	  __pos = this->_M_impl._M_start + __elems_before;
                               :	  __try
                               :	    {
                               :	      if (__elems_before >= difference_type(__n))
                               :		{
                               :		  iterator __start_n = (this->_M_impl._M_start
                               :					+ difference_type(__n));
                               :		  std::__uninitialized_move_a(this->_M_impl._M_start,
                               :					      __start_n, __new_start,
                               :					      _M_get_Tp_allocator());
                               :		  this->_M_impl._M_start = __new_start;
                               :		  _GLIBCXX_MOVE3(__start_n, __pos, __old_start);
                               :		  std::fill(__pos - difference_type(__n), __pos, __x_copy);
                               :		}
                               :	      else
                               :		{
                               :		  std::__uninitialized_move_fill(this->_M_impl._M_start,
                               :						 __pos, __new_start,
                               :						 this->_M_impl._M_start,
                               :						 __x_copy,
                               :						 _M_get_Tp_allocator());
                               :		  this->_M_impl._M_start = __new_start;
                               :		  std::fill(__old_start, __pos, __x_copy);
                               :		}
                               :	    }
                               :	  __catch(...)
                               :	    {
                               :	      _M_destroy_nodes(__new_start._M_node,
                               :			       this->_M_impl._M_start._M_node);
                               :	      __throw_exception_again;
                               :	    }
                               :	}
                               :      else
                               :	{
                               :	  iterator __new_finish = _M_reserve_elements_at_back(__n);
                               :	  iterator __old_finish = this->_M_impl._M_finish;
                               :	  const difference_type __elems_after =
                               :	    difference_type(__length) - __elems_before;
                               :	  __pos = this->_M_impl._M_finish - __elems_after;
                               :	  __try
                               :	    {
                               :	      if (__elems_after > difference_type(__n))
                               :		{
                               :		  iterator __finish_n = (this->_M_impl._M_finish
                               :					 - difference_type(__n));
                               :		  std::__uninitialized_move_a(__finish_n,
                               :					      this->_M_impl._M_finish,
                               :					      this->_M_impl._M_finish,
                               :					      _M_get_Tp_allocator());
                               :		  this->_M_impl._M_finish = __new_finish;
                               :		  _GLIBCXX_MOVE_BACKWARD3(__pos, __finish_n, __old_finish);
                               :		  std::fill(__pos, __pos + difference_type(__n), __x_copy);
                               :		}
                               :	      else
                               :		{
                               :		  std::__uninitialized_fill_move(this->_M_impl._M_finish,
                               :						 __pos + difference_type(__n),
                               :						 __x_copy, __pos,
                               :						 this->_M_impl._M_finish,
                               :						 _M_get_Tp_allocator());
                               :		  this->_M_impl._M_finish = __new_finish;
                               :		  std::fill(__pos, __old_finish, __x_copy);
                               :		}
                               :	    }
                               :	  __catch(...)
                               :	    {
                               :	      _M_destroy_nodes(this->_M_impl._M_finish._M_node + 1,
                               :			       __new_finish._M_node + 1);
                               :	      __throw_exception_again;
                               :	    }
                               :	}
                               :    }
                               :
                               :  template <typename _Tp, typename _Alloc>
                               :    template <typename _ForwardIterator>
                               :      void
                               :      deque<_Tp, _Alloc>::
                               :      _M_insert_aux(iterator __pos,
                               :                    _ForwardIterator __first, _ForwardIterator __last,
                               :                    size_type __n)
                               :      {
                               :        const difference_type __elemsbefore = __pos - this->_M_impl._M_start;
                               :        const size_type __length = size();
                               :        if (static_cast<size_type>(__elemsbefore) < __length / 2)
                               :	  {
                               :	    iterator __new_start = _M_reserve_elements_at_front(__n);
                               :	    iterator __old_start = this->_M_impl._M_start;
                               :	    __pos = this->_M_impl._M_start + __elemsbefore;
                               :	    __try
                               :	      {
                               :		if (__elemsbefore >= difference_type(__n))
                               :		  {
                               :		    iterator __start_n = (this->_M_impl._M_start
                               :					  + difference_type(__n));
                               :		    std::__uninitialized_move_a(this->_M_impl._M_start,
                               :						__start_n, __new_start,
                               :						_M_get_Tp_allocator());
                               :		    this->_M_impl._M_start = __new_start;
                               :		    _GLIBCXX_MOVE3(__start_n, __pos, __old_start);
                               :		    std::copy(__first, __last, __pos - difference_type(__n));
                               :		  }
                               :		else
                               :		  {
                               :		    _ForwardIterator __mid = __first;
                               :		    std::advance(__mid, difference_type(__n) - __elemsbefore);
                               :		    std::__uninitialized_move_copy(this->_M_impl._M_start,
                               :						   __pos, __first, __mid,
                               :						   __new_start,
                               :						   _M_get_Tp_allocator());
                               :		    this->_M_impl._M_start = __new_start;
                               :		    std::copy(__mid, __last, __old_start);
                               :		  }
                               :	      }
                               :	    __catch(...)
                               :	      {
                               :		_M_destroy_nodes(__new_start._M_node,
                               :				 this->_M_impl._M_start._M_node);
                               :		__throw_exception_again;
                               :	      }
                               :	  }
                               :        else
                               :        {
                               :          iterator __new_finish = _M_reserve_elements_at_back(__n);
                               :          iterator __old_finish = this->_M_impl._M_finish;
                               :          const difference_type __elemsafter =
                               :            difference_type(__length) - __elemsbefore;
                               :          __pos = this->_M_impl._M_finish - __elemsafter;
                               :          __try
                               :            {
                               :              if (__elemsafter > difference_type(__n))
                               :		{
                               :		  iterator __finish_n = (this->_M_impl._M_finish
                               :					 - difference_type(__n));
                               :		  std::__uninitialized_move_a(__finish_n,
                               :					      this->_M_impl._M_finish,
                               :					      this->_M_impl._M_finish,
                               :					      _M_get_Tp_allocator());
                               :		  this->_M_impl._M_finish = __new_finish;
                               :		  _GLIBCXX_MOVE_BACKWARD3(__pos, __finish_n, __old_finish);
                               :		  std::copy(__first, __last, __pos);
                               :		}
                               :              else
                               :		{
                               :		  _ForwardIterator __mid = __first;
                               :		  std::advance(__mid, __elemsafter);
                               :		  std::__uninitialized_copy_move(__mid, __last, __pos,
                               :						 this->_M_impl._M_finish,
                               :						 this->_M_impl._M_finish,
                               :						 _M_get_Tp_allocator());
                               :		  this->_M_impl._M_finish = __new_finish;
                               :		  std::copy(__first, __mid, __pos);
                               :		}
                               :            }
                               :          __catch(...)
                               :            {
                               :              _M_destroy_nodes(this->_M_impl._M_finish._M_node + 1,
                               :			       __new_finish._M_node + 1);
                               :              __throw_exception_again;
                               :            }
                               :        }
                               :      }
                               :
                               :   template<typename _Tp, typename _Alloc>
                               :     void
                               :     deque<_Tp, _Alloc>::
                               :     _M_destroy_data_aux(iterator __first, iterator __last)
                               :     {
                               :       for (_Map_pointer __node = __first._M_node + 1;
                               :	    __node < __last._M_node; ++__node)
                               :	 std::_Destroy(*__node, *__node + _S_buffer_size(),
                               :		       _M_get_Tp_allocator());
                               :
                               :       if (__first._M_node != __last._M_node)
                               :	 {
                               :	   std::_Destroy(__first._M_cur, __first._M_last,
                               :			 _M_get_Tp_allocator());
                               :	   std::_Destroy(__last._M_first, __last._M_cur,
                               :			 _M_get_Tp_allocator());
                               :	 }
                               :       else
                               :	 std::_Destroy(__first._M_cur, __last._M_cur,
                               :		       _M_get_Tp_allocator());
                               :     }
                               :
                               :  template <typename _Tp, typename _Alloc>
                               :    void
                               :    deque<_Tp, _Alloc>::
                               :    _M_new_elements_at_front(size_type __new_elems)
                               :    {
                               :      if (this->max_size() - this->size() < __new_elems)
                               :	__throw_length_error(__N("deque::_M_new_elements_at_front"));
                               :
                               :      const size_type __new_nodes = ((__new_elems + _S_buffer_size() - 1)
                               :				     / _S_buffer_size());
                               :      _M_reserve_map_at_front(__new_nodes);
                               :      size_type __i;
                               :      __try
                               :        {
                               :          for (__i = 1; __i <= __new_nodes; ++__i)
                               :            *(this->_M_impl._M_start._M_node - __i) = this->_M_allocate_node();
                               :        }
                               :      __catch(...)
                               :        {
                               :          for (size_type __j = 1; __j < __i; ++__j)
                               :            _M_deallocate_node(*(this->_M_impl._M_start._M_node - __j));
                               :          __throw_exception_again;
                               :        }
                               :    }
                               :
                               :  template <typename _Tp, typename _Alloc>
                               :    void
                               :    deque<_Tp, _Alloc>::
                               :    _M_new_elements_at_back(size_type __new_elems)
                               :    {
                               :      if (this->max_size() - this->size() < __new_elems)
                               :	__throw_length_error(__N("deque::_M_new_elements_at_back"));
                               :
                               :      const size_type __new_nodes = ((__new_elems + _S_buffer_size() - 1)
                               :				     / _S_buffer_size());
                               :      _M_reserve_map_at_back(__new_nodes);
                               :      size_type __i;
                               :      __try
                               :        {
                               :          for (__i = 1; __i <= __new_nodes; ++__i)
                               :            *(this->_M_impl._M_finish._M_node + __i) = this->_M_allocate_node();
                               :        }
                               :      __catch(...)
                               :        {
                               :          for (size_type __j = 1; __j < __i; ++__j)
                               :            _M_deallocate_node(*(this->_M_impl._M_finish._M_node + __j));
                               :          __throw_exception_again;
                               :        }
                               :    }
                               :
                               :  template <typename _Tp, typename _Alloc>
                               :    void
                               :    deque<_Tp, _Alloc>:: /* std::deque<int, std::allocator<int> >::_M_reallocate_map(unsigned int, bool) total:      2  0.0017     0       0 */
                               :    _M_reallocate_map(size_type __nodes_to_add, bool __add_at_front)
                               :    {
                               :      const size_type __old_num_nodes
                               :	= this->_M_impl._M_finish._M_node - this->_M_impl._M_start._M_node + 1;
                               :      const size_type __new_num_nodes = __old_num_nodes + __nodes_to_add;
                               :
                               :      _Map_pointer __new_nstart;
     1 8.5e-04     0       0   :      if (this->_M_impl._M_map_size > 2 * __new_num_nodes)
                               :	{
                               :	  __new_nstart = this->_M_impl._M_map + (this->_M_impl._M_map_size
                               :					 - __new_num_nodes) / 2
                               :	                 + (__add_at_front ? __nodes_to_add : 0);
                               :	  if (__new_nstart < this->_M_impl._M_start._M_node)
                               :	    std::copy(this->_M_impl._M_start._M_node,
                               :		      this->_M_impl._M_finish._M_node + 1,
                               :		      __new_nstart);
                               :	  else
                               :	    std::copy_backward(this->_M_impl._M_start._M_node,
                               :			       this->_M_impl._M_finish._M_node + 1,
                               :			       __new_nstart + __old_num_nodes);
                               :	}
                               :      else
                               :	{
                               :	  size_type __new_map_size = this->_M_impl._M_map_size
                               :	                             + std::max(this->_M_impl._M_map_size,
                               :						__nodes_to_add) + 2;
                               :
                               :	  _Map_pointer __new_map = this->_M_allocate_map(__new_map_size);
                               :	  __new_nstart = __new_map + (__new_map_size - __new_num_nodes) / 2
                               :	                 + (__add_at_front ? __nodes_to_add : 0);
                               :	  std::copy(this->_M_impl._M_start._M_node,
                               :		    this->_M_impl._M_finish._M_node + 1,
                               :		    __new_nstart);
                               :	  _M_deallocate_map(this->_M_impl._M_map, this->_M_impl._M_map_size);
                               :
                               :	  this->_M_impl._M_map = __new_map;
     1 8.5e-04     0       0   :	  this->_M_impl._M_map_size = __new_map_size;
                               :	}
                               :
                               :      this->_M_impl._M_start._M_set_node(__new_nstart);
                               :      this->_M_impl._M_finish._M_set_node(__new_nstart + __old_num_nodes - 1);
                               :    }
                               :
                               :  // Overload for deque::iterators, exploiting the "segmented-iterator
                               :  // optimization".
                               :  template<typename _Tp>
                               :    void
                               :    fill(const _Deque_iterator<_Tp, _Tp&, _Tp*>& __first,
                               :	 const _Deque_iterator<_Tp, _Tp&, _Tp*>& __last, const _Tp& __value)
                               :    {
                               :      typedef typename _Deque_iterator<_Tp, _Tp&, _Tp*>::_Self _Self;
                               :
                               :      for (typename _Self::_Map_pointer __node = __first._M_node + 1;
                               :           __node < __last._M_node; ++__node)
                               :	std::fill(*__node, *__node + _Self::_S_buffer_size(), __value);
                               :
                               :      if (__first._M_node != __last._M_node)
                               :	{
                               :	  std::fill(__first._M_cur, __first._M_last, __value);
                               :	  std::fill(__last._M_first, __last._M_cur, __value);
                               :	}
                               :      else
                               :	std::fill(__first._M_cur, __last._M_cur, __value);
                               :    }
                               :
                               :  template<typename _Tp>
                               :    _Deque_iterator<_Tp, _Tp&, _Tp*>
                               :    copy(_Deque_iterator<_Tp, const _Tp&, const _Tp*> __first,
                               :	 _Deque_iterator<_Tp, const _Tp&, const _Tp*> __last,
                               :	 _Deque_iterator<_Tp, _Tp&, _Tp*> __result)
                               :    {
                               :      typedef typename _Deque_iterator<_Tp, _Tp&, _Tp*>::_Self _Self;
                               :      typedef typename _Self::difference_type difference_type;
                               :
                               :      difference_type __len = __last - __first;
                               :      while (__len > 0)
                               :	{
                               :	  const difference_type __clen
                               :	    = std::min(__len, std::min(__first._M_last - __first._M_cur,
                               :				       __result._M_last - __result._M_cur));
                               :	  std::copy(__first._M_cur, __first._M_cur + __clen, __result._M_cur);
                               :	  __first += __clen;
                               :	  __result += __clen;
                               :	  __len -= __clen;
                               :	}
                               :      return __result;
                               :    }
                               :
                               :  template<typename _Tp>
                               :    _Deque_iterator<_Tp, _Tp&, _Tp*>
                               :    copy_backward(_Deque_iterator<_Tp, const _Tp&, const _Tp*> __first,
                               :		  _Deque_iterator<_Tp, const _Tp&, const _Tp*> __last,
                               :		  _Deque_iterator<_Tp, _Tp&, _Tp*> __result)
                               :    {
                               :      typedef typename _Deque_iterator<_Tp, _Tp&, _Tp*>::_Self _Self;
                               :      typedef typename _Self::difference_type difference_type;
                               :
                               :      difference_type __len = __last - __first;
                               :      while (__len > 0)
                               :	{
                               :	  difference_type __llen = __last._M_cur - __last._M_first;
                               :	  _Tp* __lend = __last._M_cur;
                               :
                               :	  difference_type __rlen = __result._M_cur - __result._M_first;
                               :	  _Tp* __rend = __result._M_cur;
                               :
                               :	  if (!__llen)
                               :	    {
                               :	      __llen = _Self::_S_buffer_size();
                               :	      __lend = *(__last._M_node - 1) + __llen;
                               :	    }
                               :	  if (!__rlen)
                               :	    {
                               :	      __rlen = _Self::_S_buffer_size();
                               :	      __rend = *(__result._M_node - 1) + __rlen;
                               :	    }
                               :
                               :	  const difference_type __clen = std::min(__len,
                               :						  std::min(__llen, __rlen));
                               :	  std::copy_backward(__lend - __clen, __lend, __rend);
                               :	  __last -= __clen;
                               :	  __result -= __clen;
                               :	  __len -= __clen;
                               :	}
                               :      return __result;
                               :    }
                               :
                               :#if __cplusplus >= 201103L
                               :  template<typename _Tp>
                               :    _Deque_iterator<_Tp, _Tp&, _Tp*>
                               :    move(_Deque_iterator<_Tp, const _Tp&, const _Tp*> __first,
                               :	 _Deque_iterator<_Tp, const _Tp&, const _Tp*> __last,
                               :	 _Deque_iterator<_Tp, _Tp&, _Tp*> __result)
                               :    {
                               :      typedef typename _Deque_iterator<_Tp, _Tp&, _Tp*>::_Self _Self;
                               :      typedef typename _Self::difference_type difference_type;
                               :
                               :      difference_type __len = __last - __first;
                               :      while (__len > 0)
                               :	{
                               :	  const difference_type __clen
                               :	    = std::min(__len, std::min(__first._M_last - __first._M_cur,
                               :				       __result._M_last - __result._M_cur));
                               :	  std::move(__first._M_cur, __first._M_cur + __clen, __result._M_cur);
                               :	  __first += __clen;
                               :	  __result += __clen;
                               :	  __len -= __clen;
                               :	}
                               :      return __result;
                               :    }
                               :
                               :  template<typename _Tp>
                               :    _Deque_iterator<_Tp, _Tp&, _Tp*>
                               :    move_backward(_Deque_iterator<_Tp, const _Tp&, const _Tp*> __first,
                               :		  _Deque_iterator<_Tp, const _Tp&, const _Tp*> __last,
                               :		  _Deque_iterator<_Tp, _Tp&, _Tp*> __result)
                               :    {
                               :      typedef typename _Deque_iterator<_Tp, _Tp&, _Tp*>::_Self _Self;
                               :      typedef typename _Self::difference_type difference_type;
                               :
                               :      difference_type __len = __last - __first;
                               :      while (__len > 0)
                               :	{
                               :	  difference_type __llen = __last._M_cur - __last._M_first;
                               :	  _Tp* __lend = __last._M_cur;
                               :
                               :	  difference_type __rlen = __result._M_cur - __result._M_first;
                               :	  _Tp* __rend = __result._M_cur;
                               :
                               :	  if (!__llen)
                               :	    {
                               :	      __llen = _Self::_S_buffer_size();
                               :	      __lend = *(__last._M_node - 1) + __llen;
                               :	    }
                               :	  if (!__rlen)
                               :	    {
                               :	      __rlen = _Self::_S_buffer_size();
                               :	      __rend = *(__result._M_node - 1) + __rlen;
                               :	    }
                               :
                               :	  const difference_type __clen = std::min(__len,
                               :						  std::min(__llen, __rlen));
                               :	  std::move_backward(__lend - __clen, __lend, __rend);
                               :	  __last -= __clen;
                               :	  __result -= __clen;
                               :	  __len -= __clen;
                               :	}
                               :      return __result;
                               :    }
                               :#endif
                               :
                               :_GLIBCXX_END_NAMESPACE_CONTAINER
                               :} // namespace std
                               :
                               :#endif
/* 
 * Total samples for file : "/usr/include/i386-linux-gnu/bits/stdio2.h"
 * 
 *      1 8.5e-04     0       0
 */


                               :/* Checking macros for stdio functions.
                               :   Copyright (C) 2004-2014 Free Software Foundation, Inc.
                               :   This file is part of the GNU C Library.
                               :
                               :   The GNU C Library is free software; you can redistribute it and/or
                               :   modify it under the terms of the GNU Lesser General Public
                               :   License as published by the Free Software Foundation; either
                               :   version 2.1 of the License, or (at your option) any later version.
                               :
                               :   The GNU C Library is distributed in the hope that it will be useful,
                               :   but WITHOUT ANY WARRANTY; without even the implied warranty of
                               :   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
                               :   Lesser General Public License for more details.
                               :
                               :   You should have received a copy of the GNU Lesser General Public
                               :   License along with the GNU C Library; if not, see
                               :   <http://www.gnu.org/licenses/>.  */
                               :
                               :#ifndef _STDIO_H
                               :# error "Never include <bits/stdio2.h> directly; use <stdio.h> instead."
                               :#endif
                               :
                               :extern int __sprintf_chk (char *__restrict __s, int __flag, size_t __slen,
                               :			  const char *__restrict __format, ...) __THROW;
                               :extern int __vsprintf_chk (char *__restrict __s, int __flag, size_t __slen,
                               :			   const char *__restrict __format,
                               :			   _G_va_list __ap) __THROW;
                               :
                               :#ifdef __va_arg_pack
                               :__fortify_function int
                               :__NTH (sprintf (char *__restrict __s, const char *__restrict __fmt, ...))
                               :{
                               :  return __builtin___sprintf_chk (__s, __USE_FORTIFY_LEVEL - 1,
                               :				  __bos (__s), __fmt, __va_arg_pack ());
                               :}
                               :#elif !defined __cplusplus
                               :# define sprintf(str, ...) \
                               :  __builtin___sprintf_chk (str, __USE_FORTIFY_LEVEL - 1, __bos (str), \
                               :			   __VA_ARGS__)
                               :#endif
                               :
                               :__fortify_function int
                               :__NTH (vsprintf (char *__restrict __s, const char *__restrict __fmt,
                               :		 _G_va_list __ap))
                               :{
                               :  return __builtin___vsprintf_chk (__s, __USE_FORTIFY_LEVEL - 1,
                               :				   __bos (__s), __fmt, __ap);
                               :}
                               :
                               :#if defined __USE_BSD || defined __USE_ISOC99 || defined __USE_UNIX98
                               :
                               :extern int __snprintf_chk (char *__restrict __s, size_t __n, int __flag,
                               :			   size_t __slen, const char *__restrict __format,
                               :			   ...) __THROW;
                               :extern int __vsnprintf_chk (char *__restrict __s, size_t __n, int __flag,
                               :			    size_t __slen, const char *__restrict __format,
                               :			    _G_va_list __ap) __THROW;
                               :
                               :# ifdef __va_arg_pack
                               :__fortify_function int
                               :__NTH (snprintf (char *__restrict __s, size_t __n,
                               :		 const char *__restrict __fmt, ...))
                               :{
                               :  return __builtin___snprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
                               :				   __bos (__s), __fmt, __va_arg_pack ());
                               :}
                               :# elif !defined __cplusplus
                               :#  define snprintf(str, len, ...) \
                               :  __builtin___snprintf_chk (str, len, __USE_FORTIFY_LEVEL - 1, __bos (str), \
                               :			    __VA_ARGS__)
                               :# endif
                               :
                               :__fortify_function int
                               :__NTH (vsnprintf (char *__restrict __s, size_t __n,
                               :		  const char *__restrict __fmt, _G_va_list __ap))
                               :{
                               :  return __builtin___vsnprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
                               :				    __bos (__s), __fmt, __ap);
                               :}
                               :
                               :#endif
                               :
                               :#if __USE_FORTIFY_LEVEL > 1
                               :
                               :extern int __fprintf_chk (FILE *__restrict __stream, int __flag,
                               :			  const char *__restrict __format, ...);
                               :extern int __printf_chk (int __flag, const char *__restrict __format, ...);
                               :extern int __vfprintf_chk (FILE *__restrict __stream, int __flag,
                               :			   const char *__restrict __format, _G_va_list __ap);
                               :extern int __vprintf_chk (int __flag, const char *__restrict __format,
                               :			  _G_va_list __ap);
                               :
                               :# ifdef __va_arg_pack
                               :__fortify_function int
                               :fprintf (FILE *__restrict __stream, const char *__restrict __fmt, ...)
                               :{
                               :  return __fprintf_chk (__stream, __USE_FORTIFY_LEVEL - 1, __fmt,
                               :			__va_arg_pack ());
                               :}
                               :
                               :__fortify_function int
                               :printf (const char *__restrict __fmt, ...)
                               :{
                               :  return __printf_chk (__USE_FORTIFY_LEVEL - 1, __fmt, __va_arg_pack ());
                               :}
                               :# elif !defined __cplusplus
                               :#  define printf(...) \
                               :  __printf_chk (__USE_FORTIFY_LEVEL - 1, __VA_ARGS__)
                               :#  define fprintf(stream, ...) \
                               :  __fprintf_chk (stream, __USE_FORTIFY_LEVEL - 1, __VA_ARGS__)
                               :# endif
                               :
                               :__fortify_function int
                               :vprintf (const char *__restrict __fmt, _G_va_list __ap)
                               :{
                               :#ifdef __USE_EXTERN_INLINES
                               :  return __vfprintf_chk (stdout, __USE_FORTIFY_LEVEL - 1, __fmt, __ap);
                               :#else
                               :  return __vprintf_chk (__USE_FORTIFY_LEVEL - 1, __fmt, __ap);
                               :#endif
                               :}
                               :
                               :__fortify_function int
                               :vfprintf (FILE *__restrict __stream,
                               :	  const char *__restrict __fmt, _G_va_list __ap)
                               :{
                               :  return __vfprintf_chk (__stream, __USE_FORTIFY_LEVEL - 1, __fmt, __ap);
                               :}
                               :
                               :# ifdef __USE_XOPEN2K8
                               :extern int __dprintf_chk (int __fd, int __flag, const char *__restrict __fmt,
                               :			  ...) __attribute__ ((__format__ (__printf__, 3, 4)));
                               :extern int __vdprintf_chk (int __fd, int __flag,
                               :			   const char *__restrict __fmt, _G_va_list __arg)
                               :     __attribute__ ((__format__ (__printf__, 3, 0)));
                               :
                               :#  ifdef __va_arg_pack
                               :__fortify_function int
                               :dprintf (int __fd, const char *__restrict __fmt, ...)
                               :{
                               :  return __dprintf_chk (__fd, __USE_FORTIFY_LEVEL - 1, __fmt,
                               :			__va_arg_pack ());
                               :}
                               :#  elif !defined __cplusplus
                               :#   define dprintf(fd, ...) \
                               :  __dprintf_chk (fd, __USE_FORTIFY_LEVEL - 1, __VA_ARGS__)
                               :#  endif
                               :
                               :__fortify_function int
                               :vdprintf (int __fd, const char *__restrict __fmt, _G_va_list __ap)
                               :{
                               :  return __vdprintf_chk (__fd, __USE_FORTIFY_LEVEL - 1, __fmt, __ap);
                               :}
                               :# endif
                               :
                               :# ifdef __USE_GNU
                               :
                               :extern int __asprintf_chk (char **__restrict __ptr, int __flag,
                               :			   const char *__restrict __fmt, ...)
                               :     __THROW __attribute__ ((__format__ (__printf__, 3, 4))) __wur;
                               :extern int __vasprintf_chk (char **__restrict __ptr, int __flag,
                               :			    const char *__restrict __fmt, _G_va_list __arg)
                               :     __THROW __attribute__ ((__format__ (__printf__, 3, 0))) __wur;
                               :extern int __obstack_printf_chk (struct obstack *__restrict __obstack,
                               :				 int __flag, const char *__restrict __format,
                               :				 ...)
                               :     __THROW __attribute__ ((__format__ (__printf__, 3, 4)));
                               :extern int __obstack_vprintf_chk (struct obstack *__restrict __obstack,
                               :				  int __flag,
                               :				  const char *__restrict __format,
                               :				  _G_va_list __args)
                               :     __THROW __attribute__ ((__format__ (__printf__, 3, 0)));
                               :
                               :#  ifdef __va_arg_pack
                               :__fortify_function int
                               :__NTH (asprintf (char **__restrict __ptr, const char *__restrict __fmt, ...))
                               :{
                               :  return __asprintf_chk (__ptr, __USE_FORTIFY_LEVEL - 1, __fmt,
                               :			 __va_arg_pack ());
                               :}
                               :
                               :__fortify_function int
                               :__NTH (__asprintf (char **__restrict __ptr, const char *__restrict __fmt,
                               :		   ...))
                               :{
                               :  return __asprintf_chk (__ptr, __USE_FORTIFY_LEVEL - 1, __fmt,
                               :			 __va_arg_pack ());
                               :}
                               :
                               :__fortify_function int
                               :__NTH (obstack_printf (struct obstack *__restrict __obstack,
                               :		       const char *__restrict __fmt, ...))
                               :{
                               :  return __obstack_printf_chk (__obstack, __USE_FORTIFY_LEVEL - 1, __fmt,
                               :			       __va_arg_pack ());
                               :}
                               :#  elif !defined __cplusplus
                               :#   define asprintf(ptr, ...) \
                               :  __asprintf_chk (ptr, __USE_FORTIFY_LEVEL - 1, __VA_ARGS__)
                               :#   define __asprintf(ptr, ...) \
                               :  __asprintf_chk (ptr, __USE_FORTIFY_LEVEL - 1, __VA_ARGS__)
                               :#   define obstack_printf(obstack, ...) \
                               :  __obstack_printf_chk (obstack, __USE_FORTIFY_LEVEL - 1, __VA_ARGS__)
                               :#  endif
                               :
                               :__fortify_function int
                               :__NTH (vasprintf (char **__restrict __ptr, const char *__restrict __fmt,
                               :		  _G_va_list __ap))
                               :{
                               :  return __vasprintf_chk (__ptr, __USE_FORTIFY_LEVEL - 1, __fmt, __ap);
                               :}
                               :
                               :__fortify_function int
                               :__NTH (obstack_vprintf (struct obstack *__restrict __obstack,
                               :			const char *__restrict __fmt, _G_va_list __ap))
                               :{
                               :  return __obstack_vprintf_chk (__obstack, __USE_FORTIFY_LEVEL - 1, __fmt,
                               :				__ap);
                               :}
                               :
                               :# endif
                               :
                               :#endif
                               :
                               :#if !defined __USE_ISOC11 \
                               :    || (defined __cplusplus && __cplusplus <= 201103L && !defined __USE_GNU)
                               :extern char *__gets_chk (char *__str, size_t) __wur;
                               :extern char *__REDIRECT (__gets_warn, (char *__str), gets)
                               :     __wur __warnattr ("please use fgets or getline instead, gets can't "
                               :		       "specify buffer size");
                               :
                               :__fortify_function __wur char *
                               :gets (char *__str)
                               :{
                               :  if (__bos (__str) != (size_t) -1)
                               :    return __gets_chk (__str, __bos (__str));
                               :  return __gets_warn (__str);
                               :}
                               :#endif
                               :
                               :extern char *__fgets_chk (char *__restrict __s, size_t __size, int __n,
                               :			  FILE *__restrict __stream) __wur;
                               :extern char *__REDIRECT (__fgets_alias,
                               :			 (char *__restrict __s, int __n,
                               :			  FILE *__restrict __stream), fgets) __wur;
                               :extern char *__REDIRECT (__fgets_chk_warn,
                               :			 (char *__restrict __s, size_t __size, int __n,
                               :			  FILE *__restrict __stream), __fgets_chk)
                               :     __wur __warnattr ("fgets called with bigger size than length "
                               :		       "of destination buffer");
                               :
                               :__fortify_function __wur char *
                               :fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
                               :{
                               :  if (__bos (__s) != (size_t) -1)
                               :    {
                               :      if (!__builtin_constant_p (__n) || __n <= 0)
                               :	return __fgets_chk (__s, __bos (__s), __n, __stream);
                               :
                               :      if ((size_t) __n > __bos (__s))
                               :	return __fgets_chk_warn (__s, __bos (__s), __n, __stream);
                               :    }
     1 8.5e-04     0       0   :  return __fgets_alias (__s, __n, __stream);
                               :}
                               :
                               :extern size_t __fread_chk (void *__restrict __ptr, size_t __ptrlen,
                               :			   size_t __size, size_t __n,
                               :			   FILE *__restrict __stream) __wur;
                               :extern size_t __REDIRECT (__fread_alias,
                               :			  (void *__restrict __ptr, size_t __size,
                               :			   size_t __n, FILE *__restrict __stream),
                               :			  fread) __wur;
                               :extern size_t __REDIRECT (__fread_chk_warn,
                               :			  (void *__restrict __ptr, size_t __ptrlen,
                               :			   size_t __size, size_t __n,
                               :			   FILE *__restrict __stream),
                               :			  __fread_chk)
                               :     __wur __warnattr ("fread called with bigger size * nmemb than length "
                               :		       "of destination buffer");
                               :
                               :__fortify_function __wur size_t
                               :fread (void *__restrict __ptr, size_t __size, size_t __n,
                               :       FILE *__restrict __stream)
                               :{
                               :  if (__bos0 (__ptr) != (size_t) -1)
                               :    {
                               :      if (!__builtin_constant_p (__size)
                               :	  || !__builtin_constant_p (__n)
                               :	  || (__size | __n) >= (((size_t) 1) << (8 * sizeof (size_t) / 2)))
                               :	return __fread_chk (__ptr, __bos0 (__ptr), __size, __n, __stream);
                               :
                               :      if (__size * __n > __bos0 (__ptr))
                               :	return __fread_chk_warn (__ptr, __bos0 (__ptr), __size, __n, __stream);
                               :    }
                               :  return __fread_alias (__ptr, __size, __n, __stream);
                               :}
                               :
                               :#ifdef __USE_GNU
                               :extern char *__fgets_unlocked_chk (char *__restrict __s, size_t __size,
                               :				   int __n, FILE *__restrict __stream) __wur;
                               :extern char *__REDIRECT (__fgets_unlocked_alias,
                               :			 (char *__restrict __s, int __n,
                               :			  FILE *__restrict __stream), fgets_unlocked) __wur;
                               :extern char *__REDIRECT (__fgets_unlocked_chk_warn,
                               :			 (char *__restrict __s, size_t __size, int __n,
                               :			  FILE *__restrict __stream), __fgets_unlocked_chk)
                               :     __wur __warnattr ("fgets_unlocked called with bigger size than length "
                               :		       "of destination buffer");
                               :
                               :__fortify_function __wur char *
                               :fgets_unlocked (char *__restrict __s, int __n, FILE *__restrict __stream)
                               :{
                               :  if (__bos (__s) != (size_t) -1)
                               :    {
                               :      if (!__builtin_constant_p (__n) || __n <= 0)
                               :	return __fgets_unlocked_chk (__s, __bos (__s), __n, __stream);
                               :
                               :      if ((size_t) __n > __bos (__s))
                               :	return __fgets_unlocked_chk_warn (__s, __bos (__s), __n, __stream);
                               :    }
                               :  return __fgets_unlocked_alias (__s, __n, __stream);
                               :}
                               :#endif
                               :
                               :#ifdef __USE_MISC
                               :# undef fread_unlocked
                               :extern size_t __fread_unlocked_chk (void *__restrict __ptr, size_t __ptrlen,
                               :				    size_t __size, size_t __n,
                               :				    FILE *__restrict __stream) __wur;
                               :extern size_t __REDIRECT (__fread_unlocked_alias,
                               :			  (void *__restrict __ptr, size_t __size,
                               :			   size_t __n, FILE *__restrict __stream),
                               :			  fread_unlocked) __wur;
                               :extern size_t __REDIRECT (__fread_unlocked_chk_warn,
                               :			  (void *__restrict __ptr, size_t __ptrlen,
                               :			   size_t __size, size_t __n,
                               :			   FILE *__restrict __stream),
                               :			  __fread_unlocked_chk)
                               :     __wur __warnattr ("fread_unlocked called with bigger size * nmemb than "
                               :		       "length of destination buffer");
                               :
                               :__fortify_function __wur size_t
                               :fread_unlocked (void *__restrict __ptr, size_t __size, size_t __n,
                               :		FILE *__restrict __stream)
                               :{
                               :  if (__bos0 (__ptr) != (size_t) -1)
                               :    {
                               :      if (!__builtin_constant_p (__size)
                               :	  || !__builtin_constant_p (__n)
                               :	  || (__size | __n) >= (((size_t) 1) << (8 * sizeof (size_t) / 2)))
                               :	return __fread_unlocked_chk (__ptr, __bos0 (__ptr), __size, __n,
                               :				     __stream);
                               :
                               :      if (__size * __n > __bos0 (__ptr))
                               :	return __fread_unlocked_chk_warn (__ptr, __bos0 (__ptr), __size, __n,
                               :					  __stream);
                               :    }
                               :
                               :# ifdef __USE_EXTERN_INLINES
                               :  if (__builtin_constant_p (__size)
                               :      && __builtin_constant_p (__n)
                               :      && (__size | __n) < (((size_t) 1) << (8 * sizeof (size_t) / 2))
                               :      && __size * __n <= 8)
                               :    {
                               :      size_t __cnt = __size * __n;
                               :      char *__cptr = (char *) __ptr;
                               :      if (__cnt == 0)
                               :	return 0;
                               :
                               :      for (; __cnt > 0; --__cnt)
                               :	{
                               :	  int __c = _IO_getc_unlocked (__stream);
                               :	  if (__c == EOF)
                               :	    break;
                               :	  *__cptr++ = __c;
                               :	}
                               :      return (__cptr - (char *) __ptr) / __size;
                               :    }
                               :# endif
                               :  return __fread_unlocked_alias (__ptr, __size, __n, __stream);
                               :}
                               :#endif
/* 
 * Total samples for file : "/usr/include/c++/4.8/tuple"
 * 
 *      1 8.5e-04     0       0
 */


                               :// <tuple> -*- C++ -*-
                               :
                               :// Copyright (C) 2007-2013 Free Software Foundation, Inc.
                               ://
                               :// This file is part of the GNU ISO C++ Library.  This library is free
                               :// software; you can redistribute it and/or modify it under the
                               :// terms of the GNU General Public License as published by the
                               :// Free Software Foundation; either version 3, or (at your option)
                               :// any later version.
                               :
                               :// This library is distributed in the hope that it will be useful,
                               :// but WITHOUT ANY WARRANTY; without even the implied warranty of
                               :// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                               :// GNU General Public License for more details.
                               :
                               :// Under Section 7 of GPL version 3, you are granted additional
                               :// permissions described in the GCC Runtime Library Exception, version
                               :// 3.1, as published by the Free Software Foundation.
                               :
                               :// You should have received a copy of the GNU General Public License and
                               :// a copy of the GCC Runtime Library Exception along with this program;
                               :// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                               :// <http://www.gnu.org/licenses/>.
                               :
                               :/** @file include/tuple
                               : *  This is a Standard C++ Library header.
                               : */
                               :
                               :#ifndef _GLIBCXX_TUPLE
                               :#define _GLIBCXX_TUPLE 1
                               :
                               :#pragma GCC system_header
                               :
                               :#if __cplusplus < 201103L
                               :# include <bits/c++0x_warning.h>
                               :#else
                               :
                               :#include <utility>
                               :#include <array>
                               :#include <bits/uses_allocator.h>
                               :
                               :namespace std _GLIBCXX_VISIBILITY(default)
                               :{
                               :_GLIBCXX_BEGIN_NAMESPACE_VERSION
                               :
                               :  /**
                               :   *  @addtogroup utilities
                               :   *  @{
                               :   */
                               :
                               :  // Adds a const reference to a non-reference type.
                               :  template<typename _Tp>
                               :    struct __add_c_ref
                               :    { typedef const _Tp& type; };
                               :
                               :  template<typename _Tp>
                               :    struct __add_c_ref<_Tp&>
                               :    { typedef _Tp& type; };
                               :
                               :  // Adds a reference to a non-reference type.
                               :  template<typename _Tp>
                               :    struct __add_ref
                               :    { typedef _Tp& type; };
                               :
                               :  template<typename _Tp>
                               :    struct __add_ref<_Tp&>
                               :    { typedef _Tp& type; };
                               :
                               :  // Adds an rvalue reference to a non-reference type.
                               :  template<typename _Tp>
                               :    struct __add_r_ref
                               :    { typedef _Tp&& type; };
                               :
                               :  template<typename _Tp>
                               :    struct __add_r_ref<_Tp&>
                               :    { typedef _Tp& type; };
                               :
                               :  template<std::size_t _Idx, typename _Head, bool _IsEmptyNotFinal>
                               :    struct _Head_base;
                               :
                               :  template<std::size_t _Idx, typename _Head>
                               :    struct _Head_base<_Idx, _Head, true>
                               :    : public _Head
                               :    {
                               :      constexpr _Head_base()
                               :      : _Head() { }
                               :
                               :      constexpr _Head_base(const _Head& __h)
                               :      : _Head(__h) { }
                               :
                               :      template<typename _UHead, typename = typename
                               :	       enable_if<!is_convertible<_UHead,
                               :	                                 __uses_alloc_base>::value>::type>
                               :        constexpr _Head_base(_UHead&& __h)
                               :	: _Head(std::forward<_UHead>(__h)) { }
                               :
                               :      _Head_base(__uses_alloc0)
                               :      : _Head() { }
                               :
                               :      template<typename _Alloc>
                               :	_Head_base(__uses_alloc1<_Alloc> __a)
                               :	: _Head(allocator_arg, *__a._M_a) { }
                               :
                               :      template<typename _Alloc>
                               :	_Head_base(__uses_alloc2<_Alloc> __a)
                               :	: _Head(*__a._M_a) { }
                               :
                               :      template<typename _UHead>
                               :	_Head_base(__uses_alloc0, _UHead&& __uhead)
                               :	: _Head(std::forward<_UHead>(__uhead)) { }
                               :
                               :      template<typename _Alloc, typename _UHead>
                               :	_Head_base(__uses_alloc1<_Alloc> __a, _UHead&& __uhead)
                               :	: _Head(allocator_arg, *__a._M_a, std::forward<_UHead>(__uhead)) { }
                               :
                               :      template<typename _Alloc, typename _UHead>
                               :	_Head_base(__uses_alloc2<_Alloc> __a, _UHead&& __uhead)
                               :	: _Head(std::forward<_UHead>(__uhead), *__a._M_a) { }
                               :
                               :      static constexpr _Head&
                               :      _M_head(_Head_base& __b) noexcept { return __b; }
                               :
                               :      static constexpr const _Head&
                               :      _M_head(const _Head_base& __b) noexcept { return __b; }
                               :    };
                               :
                               :  template<std::size_t _Idx, typename _Head>
                               :    struct _Head_base<_Idx, _Head, false>
                               :    {
                               :      constexpr _Head_base()
                               :      : _M_head_impl() { }
                               :
                               :      constexpr _Head_base(const _Head& __h)
                               :      : _M_head_impl(__h) { }
                               :
                               :      template<typename _UHead, typename = typename
                               :	       enable_if<!is_convertible<_UHead,
                               :	                                 __uses_alloc_base>::value>::type>
                               :        constexpr _Head_base(_UHead&& __h)
                               :	: _M_head_impl(std::forward<_UHead>(__h)) { }
                               :
                               :      _Head_base(__uses_alloc0)
                               :      : _M_head_impl() { }
                               :
                               :      template<typename _Alloc>
                               :	_Head_base(__uses_alloc1<_Alloc> __a)
                               :	: _M_head_impl(allocator_arg, *__a._M_a) { }
                               :
                               :      template<typename _Alloc>
                               :	_Head_base(__uses_alloc2<_Alloc> __a)
                               :	: _M_head_impl(*__a._M_a) { }
                               :
                               :      template<typename _UHead>
                               :	_Head_base(__uses_alloc0, _UHead&& __uhead)
                               :	: _M_head_impl(std::forward<_UHead>(__uhead)) { }
                               :
                               :      template<typename _Alloc, typename _UHead>
                               :	_Head_base(__uses_alloc1<_Alloc> __a, _UHead&& __uhead)
                               :	: _M_head_impl(allocator_arg, *__a._M_a, std::forward<_UHead>(__uhead))
                               :	{ }
                               :
                               :      template<typename _Alloc, typename _UHead>
                               :	_Head_base(__uses_alloc2<_Alloc> __a, _UHead&& __uhead)
                               :	: _M_head_impl(std::forward<_UHead>(__uhead), *__a._M_a) { }
                               :
                               :      static constexpr _Head&
                               :      _M_head(_Head_base& __b) noexcept { return __b._M_head_impl; }
                               :
                               :      static constexpr const _Head&
                               :      _M_head(const _Head_base& __b) noexcept { return __b._M_head_impl; }
                               :
                               :      _Head _M_head_impl;
                               :    };
                               :
                               :  /**
                               :   * Contains the actual implementation of the @c tuple template, stored
                               :   * as a recursive inheritance hierarchy from the first element (most
                               :   * derived class) to the last (least derived class). The @c Idx
                               :   * parameter gives the 0-based index of the element stored at this
                               :   * point in the hierarchy; we use it to implement a constant-time
                               :   * get() operation.
                               :   */
                               :  template<std::size_t _Idx, typename... _Elements>
                               :    struct _Tuple_impl; 
                               :
                               :  /**
                               :   * Zero-element tuple implementation. This is the basis case for the 
                               :   * inheritance recursion.
                               :   */
                               :  template<std::size_t _Idx>
                               :    struct _Tuple_impl<_Idx>
                               :    {
                               :      template<std::size_t, typename...> friend class _Tuple_impl;
                               :
                               :      _Tuple_impl() = default;
                               :
                               :      template<typename _Alloc>
                               :        _Tuple_impl(allocator_arg_t, const _Alloc&) { }
                               :
                               :      template<typename _Alloc>
                               :        _Tuple_impl(allocator_arg_t, const _Alloc&, const _Tuple_impl&) { }
                               :
                               :      template<typename _Alloc>
                               :        _Tuple_impl(allocator_arg_t, const _Alloc&, _Tuple_impl&&) { }
                               :
                               :    protected:
                               :      void _M_swap(_Tuple_impl&) noexcept { /* no-op */ }
                               :    };
                               :
                               :  template<typename _Tp>
                               :    struct __is_empty_non_tuple : is_empty<_Tp> { };
                               :
                               :  // Using EBO for elements that are tuples causes ambiguous base errors.
                               :  template<typename _El0, typename... _El>
                               :    struct __is_empty_non_tuple<tuple<_El0, _El...>> : false_type { };
                               :
                               :  // Use the Empty Base-class Optimization for empty, non-final types.
                               :  template<typename _Tp>
                               :    using __empty_not_final
                               :    = typename conditional<__is_final(_Tp), false_type,
                               :			   __is_empty_non_tuple<_Tp>>::type;
                               :
                               :  /**
                               :   * Recursive tuple implementation. Here we store the @c Head element
                               :   * and derive from a @c Tuple_impl containing the remaining elements
                               :   * (which contains the @c Tail).
                               :   */
                               :  template<std::size_t _Idx, typename _Head, typename... _Tail>
                               :    struct _Tuple_impl<_Idx, _Head, _Tail...>
                               :    : public _Tuple_impl<_Idx + 1, _Tail...>,
                               :      private _Head_base<_Idx, _Head, __empty_not_final<_Head>::value>
                               :    {
                               :      template<std::size_t, typename...> friend class _Tuple_impl;
                               :
                               :      typedef _Tuple_impl<_Idx + 1, _Tail...> _Inherited;
                               :      typedef _Head_base<_Idx, _Head, __empty_not_final<_Head>::value> _Base;
                               :
                               :      static constexpr _Head&  
                               :      _M_head(_Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }
                               :
                               :      static constexpr const _Head&
                               :      _M_head(const _Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }
                               :
                               :      static constexpr _Inherited&
                               :      _M_tail(_Tuple_impl& __t) noexcept { return __t; }
                               :
                               :      static constexpr const _Inherited&
                               :      _M_tail(const _Tuple_impl& __t) noexcept { return __t; }
                               :
                               :      constexpr _Tuple_impl()
                               :      : _Inherited(), _Base() { }
                               :
                               :      explicit 
                               :      constexpr _Tuple_impl(const _Head& __head, const _Tail&... __tail)
                               :      : _Inherited(__tail...), _Base(__head) { }
                               :
                               :      template<typename _UHead, typename... _UTail, typename = typename
                               :               enable_if<sizeof...(_Tail) == sizeof...(_UTail)>::type> 
                               :        explicit
                               :        constexpr _Tuple_impl(_UHead&& __head, _UTail&&... __tail)
                               :	: _Inherited(std::forward<_UTail>(__tail)...),
                               :	  _Base(std::forward<_UHead>(__head)) { }
                               :
                               :      constexpr _Tuple_impl(const _Tuple_impl&) = default;
                               :
                               :      constexpr
                               :      _Tuple_impl(_Tuple_impl&& __in)
                               :      noexcept(__and_<is_nothrow_move_constructible<_Head>,
                               :	              is_nothrow_move_constructible<_Inherited>>::value)
                               :      : _Inherited(std::move(_M_tail(__in))), 
                               :	_Base(std::forward<_Head>(_M_head(__in))) { }
                               :
                               :      template<typename... _UElements>
                               :        constexpr _Tuple_impl(const _Tuple_impl<_Idx, _UElements...>& __in)
                               :	: _Inherited(_Tuple_impl<_Idx, _UElements...>::_M_tail(__in)),
                               :	  _Base(_Tuple_impl<_Idx, _UElements...>::_M_head(__in)) { }
                               :
                               :      template<typename _UHead, typename... _UTails>
                               :        constexpr _Tuple_impl(_Tuple_impl<_Idx, _UHead, _UTails...>&& __in)
                               :	: _Inherited(std::move
                               :		     (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in))),
                               :	  _Base(std::forward<_UHead>
                               :		(_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in))) { }
                               :
                               :      template<typename _Alloc>
                               :	_Tuple_impl(allocator_arg_t __tag, const _Alloc& __a)
                               :	: _Inherited(__tag, __a),
                               :          _Base(__use_alloc<_Head>(__a)) { }
                               :
                               :      template<typename _Alloc>
                               :	_Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
                               :		    const _Head& __head, const _Tail&... __tail)
                               :	: _Inherited(__tag, __a, __tail...),
                               :          _Base(__use_alloc<_Head, _Alloc, _Head>(__a), __head) { }
                               :
                               :      template<typename _Alloc, typename _UHead, typename... _UTail,
                               :               typename = typename enable_if<sizeof...(_Tail)
                               :					     == sizeof...(_UTail)>::type>
                               :	_Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
                               :	            _UHead&& __head, _UTail&&... __tail)
                               :	: _Inherited(__tag, __a, std::forward<_UTail>(__tail)...),
                               :          _Base(__use_alloc<_Head, _Alloc, _UHead>(__a),
                               :	        std::forward<_UHead>(__head)) { }
                               :
                               :      template<typename _Alloc>
                               :        _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
                               :	            const _Tuple_impl& __in)
                               :	: _Inherited(__tag, __a, _M_tail(__in)), 
                               :          _Base(__use_alloc<_Head, _Alloc, _Head>(__a), _M_head(__in)) { }
                               :
                               :      template<typename _Alloc>
                               :	_Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
                               :	            _Tuple_impl&& __in)
                               :	: _Inherited(__tag, __a, std::move(_M_tail(__in))), 
                               :	  _Base(__use_alloc<_Head, _Alloc, _Head>(__a),
                               :	        std::forward<_Head>(_M_head(__in))) { }
                               :
                               :      template<typename _Alloc, typename... _UElements>
                               :	_Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
                               :	            const _Tuple_impl<_Idx, _UElements...>& __in)
                               :	: _Inherited(__tag, __a,
                               :		     _Tuple_impl<_Idx, _UElements...>::_M_tail(__in)),
                               :	  _Base(__use_alloc<_Head, _Alloc, _Head>(__a),
                               :		_Tuple_impl<_Idx, _UElements...>::_M_head(__in)) { }
                               :
                               :      template<typename _Alloc, typename _UHead, typename... _UTails>
                               :	_Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
                               :	            _Tuple_impl<_Idx, _UHead, _UTails...>&& __in)
                               :	: _Inherited(__tag, __a, std::move
                               :		     (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in))),
                               :	  _Base(__use_alloc<_Head, _Alloc, _UHead>(__a),
                               :                std::forward<_UHead>
                               :		(_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in))) { }
                               :
                               :      _Tuple_impl&
                               :      operator=(const _Tuple_impl& __in)
                               :      {
                               :	_M_head(*this) = _M_head(__in);
                               :	_M_tail(*this) = _M_tail(__in);
                               :	return *this;
                               :      }
                               :
                               :      _Tuple_impl&
                               :      operator=(_Tuple_impl&& __in)
                               :      noexcept(__and_<is_nothrow_move_assignable<_Head>,
                               :	              is_nothrow_move_assignable<_Inherited>>::value)
                               :      {
                               :	_M_head(*this) = std::forward<_Head>(_M_head(__in));
                               :	_M_tail(*this) = std::move(_M_tail(__in));
                               :	return *this;
                               :      }
                               :
                               :      template<typename... _UElements>
                               :        _Tuple_impl&
                               :        operator=(const _Tuple_impl<_Idx, _UElements...>& __in)
                               :        {
                               :	  _M_head(*this) = _Tuple_impl<_Idx, _UElements...>::_M_head(__in);
                               :	  _M_tail(*this) = _Tuple_impl<_Idx, _UElements...>::_M_tail(__in);
                               :	  return *this;
                               :	}
                               :
                               :      template<typename _UHead, typename... _UTails>
                               :        _Tuple_impl&
                               :        operator=(_Tuple_impl<_Idx, _UHead, _UTails...>&& __in)
                               :        {
                               :	  _M_head(*this) = std::forward<_UHead>
                               :	    (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in));
                               :	  _M_tail(*this) = std::move
                               :	    (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in));
                               :	  return *this;
                               :	}
                               :
                               :    protected:
                               :      void
                               :      _M_swap(_Tuple_impl& __in)
                               :      noexcept(noexcept(swap(std::declval<_Head&>(),
                               :			     std::declval<_Head&>()))
                               :	       && noexcept(_M_tail(__in)._M_swap(_M_tail(__in))))
                               :      {
                               :	using std::swap;
                               :	swap(_M_head(*this), _M_head(__in));
                               :	_Inherited::_M_swap(_M_tail(__in));
                               :      }
                               :    };
                               :
                               :  /// Primary class template, tuple
                               :  template<typename... _Elements> 
                               :    class tuple : public _Tuple_impl<0, _Elements...>
                               :    {
                               :      typedef _Tuple_impl<0, _Elements...> _Inherited;
                               :
                               :    public:
                               :      constexpr tuple()
                               :      : _Inherited() { }
                               :
                               :      explicit
                               :      constexpr tuple(const _Elements&... __elements)
                               :      : _Inherited(__elements...) { }
                               :
                               :      template<typename... _UElements, typename = typename
                               :        enable_if<__and_<is_convertible<_UElements,
                               :					_Elements>...>::value>::type>
                               :	explicit
                               :        constexpr tuple(_UElements&&... __elements)
                               :	: _Inherited(std::forward<_UElements>(__elements)...) {	}
                               :
                               :      constexpr tuple(const tuple&) = default;
                               :
                               :      constexpr tuple(tuple&&) = default; 
                               :
                               :      template<typename... _UElements, typename = typename
                               :        enable_if<__and_<is_convertible<const _UElements&,
                               :					_Elements>...>::value>::type>
                               :        constexpr tuple(const tuple<_UElements...>& __in)
                               :        : _Inherited(static_cast<const _Tuple_impl<0, _UElements...>&>(__in))
                               :        { }
                               :
                               :      template<typename... _UElements, typename = typename
                               :        enable_if<__and_<is_convertible<_UElements,
                               :					_Elements>...>::value>::type>
                               :        constexpr tuple(tuple<_UElements...>&& __in)
                               :        : _Inherited(static_cast<_Tuple_impl<0, _UElements...>&&>(__in)) { }
                               :
                               :      // Allocator-extended constructors.
                               :
                               :      template<typename _Alloc>
                               :	tuple(allocator_arg_t __tag, const _Alloc& __a)
                               :	: _Inherited(__tag, __a) { }
                               :
                               :      template<typename _Alloc>
                               :	tuple(allocator_arg_t __tag, const _Alloc& __a,
                               :	      const _Elements&... __elements)
                               :	: _Inherited(__tag, __a, __elements...) { }
                               :
                               :      template<typename _Alloc, typename... _UElements, typename = typename
                               :	       enable_if<sizeof...(_UElements)
                               :			 == sizeof...(_Elements)>::type>
                               :	tuple(allocator_arg_t __tag, const _Alloc& __a,
                               :	      _UElements&&... __elements)
                               :	: _Inherited(__tag, __a, std::forward<_UElements>(__elements)...)
                               :       	{ }
                               :
                               :      template<typename _Alloc>
                               :	tuple(allocator_arg_t __tag, const _Alloc& __a, const tuple& __in)
                               :	: _Inherited(__tag, __a, static_cast<const _Inherited&>(__in)) { }
                               :
                               :      template<typename _Alloc>
                               :	tuple(allocator_arg_t __tag, const _Alloc& __a, tuple&& __in)
                               :	: _Inherited(__tag, __a, static_cast<_Inherited&&>(__in)) { }
                               :
                               :      template<typename _Alloc, typename... _UElements, typename = typename
                               :	       enable_if<sizeof...(_UElements)
                               :			 == sizeof...(_Elements)>::type>
                               :	tuple(allocator_arg_t __tag, const _Alloc& __a,
                               :	      const tuple<_UElements...>& __in)
                               :	: _Inherited(__tag, __a,
                               :	             static_cast<const _Tuple_impl<0, _UElements...>&>(__in))
                               :	{ }
                               :
                               :      template<typename _Alloc, typename... _UElements, typename = typename
                               :	       enable_if<sizeof...(_UElements)
                               :			 == sizeof...(_Elements)>::type>
                               :	tuple(allocator_arg_t __tag, const _Alloc& __a,
                               :	      tuple<_UElements...>&& __in)
                               :	: _Inherited(__tag, __a,
                               :	             static_cast<_Tuple_impl<0, _UElements...>&&>(__in))
                               :	{ }
                               :
                               :      tuple&
                               :      operator=(const tuple& __in)
                               :      {
                               :	static_cast<_Inherited&>(*this) = __in;
                               :	return *this;
                               :      }
                               :
                               :      tuple&
                               :      operator=(tuple&& __in)
                               :      noexcept(is_nothrow_move_assignable<_Inherited>::value)
                               :      {
                               :	static_cast<_Inherited&>(*this) = std::move(__in);
                               :	return *this;
                               :      }
                               :
                               :      template<typename... _UElements, typename = typename
                               :	       enable_if<sizeof...(_UElements)
                               :			 == sizeof...(_Elements)>::type>
                               :        tuple&
                               :        operator=(const tuple<_UElements...>& __in)
                               :        {
                               :	  static_cast<_Inherited&>(*this) = __in;
                               :	  return *this;
                               :	}
                               :
                               :      template<typename... _UElements, typename = typename
                               :	       enable_if<sizeof...(_UElements)
                               :			 == sizeof...(_Elements)>::type>
                               :        tuple&
                               :        operator=(tuple<_UElements...>&& __in)
                               :        {
                               :	  static_cast<_Inherited&>(*this) = std::move(__in);
                               :	  return *this;
                               :	}
                               :
                               :      void
                               :      swap(tuple& __in)
                               :      noexcept(noexcept(__in._M_swap(__in)))
                               :      { _Inherited::_M_swap(__in); }
                               :    };
                               :
                               :  // Explicit specialization, zero-element tuple.
                               :  template<>  
                               :    class tuple<>
                               :    {
                               :    public:
                               :      void swap(tuple&) noexcept { /* no-op */ }
                               :    };
                               :
                               :  /// Partial specialization, 2-element tuple.
                               :  /// Includes construction and assignment from a pair.
                               :  template<typename _T1, typename _T2>
                               :    class tuple<_T1, _T2> : public _Tuple_impl<0, _T1, _T2>
                               :    {
                               :      typedef _Tuple_impl<0, _T1, _T2> _Inherited;
                               :
                               :    public:
                               :      constexpr tuple()
                               :      : _Inherited() { }
                               :
                               :      explicit
                               :      constexpr tuple(const _T1& __a1, const _T2& __a2)
                               :      : _Inherited(__a1, __a2) { }
                               :
                               :      template<typename _U1, typename _U2, typename = typename
                               :	       enable_if<__and_<is_convertible<_U1, _T1>,
                               :				is_convertible<_U2, _T2>>::value>::type>
                               :        explicit
                               :        constexpr tuple(_U1&& __a1, _U2&& __a2)
                               :	: _Inherited(std::forward<_U1>(__a1), std::forward<_U2>(__a2)) { }
                               :
                               :      constexpr tuple(const tuple&) = default;
                               :
                               :      constexpr tuple(tuple&&) = default;
                               :
                               :      template<typename _U1, typename _U2, typename = typename
                               :	enable_if<__and_<is_convertible<const _U1&, _T1>,
                               :			 is_convertible<const _U2&, _T2>>::value>::type>
                               :        constexpr tuple(const tuple<_U1, _U2>& __in)
                               :	: _Inherited(static_cast<const _Tuple_impl<0, _U1, _U2>&>(__in)) { }
                               :
                               :      template<typename _U1, typename _U2, typename = typename
                               :	       enable_if<__and_<is_convertible<_U1, _T1>,
                               :				is_convertible<_U2, _T2>>::value>::type>
                               :        constexpr tuple(tuple<_U1, _U2>&& __in)
                               :	: _Inherited(static_cast<_Tuple_impl<0, _U1, _U2>&&>(__in)) { }
                               :
                               :      template<typename _U1, typename _U2, typename = typename
                               :	enable_if<__and_<is_convertible<const _U1&, _T1>,
                               :			 is_convertible<const _U2&, _T2>>::value>::type>
                               :        constexpr tuple(const pair<_U1, _U2>& __in)
                               :	: _Inherited(__in.first, __in.second) { }
                               :
                               :      template<typename _U1, typename _U2, typename = typename
                               :	       enable_if<__and_<is_convertible<_U1, _T1>,
                               :				is_convertible<_U2, _T2>>::value>::type>
                               :        constexpr tuple(pair<_U1, _U2>&& __in)
                               :	: _Inherited(std::forward<_U1>(__in.first),
                               :		     std::forward<_U2>(__in.second)) { }
                               :
                               :      // Allocator-extended constructors.
                               :
                               :      template<typename _Alloc>
                               :	tuple(allocator_arg_t __tag, const _Alloc& __a)
                               :	: _Inherited(__tag, __a) { }
                               :
                               :      template<typename _Alloc>
                               :	tuple(allocator_arg_t __tag, const _Alloc& __a,
                               :	      const _T1& __a1, const _T2& __a2)
                               :	: _Inherited(__tag, __a, __a1, __a2) { }
                               :
                               :      template<typename _Alloc, typename _U1, typename _U2>
                               :	tuple(allocator_arg_t __tag, const _Alloc& __a, _U1&& __a1, _U2&& __a2)
                               :	: _Inherited(__tag, __a, std::forward<_U1>(__a1),
                               :	             std::forward<_U2>(__a2)) { }
                               :
                               :      template<typename _Alloc>
                               :	tuple(allocator_arg_t __tag, const _Alloc& __a, const tuple& __in)
                               :	: _Inherited(__tag, __a, static_cast<const _Inherited&>(__in)) { }
                               :
                               :      template<typename _Alloc>
                               :	tuple(allocator_arg_t __tag, const _Alloc& __a, tuple&& __in)
                               :	: _Inherited(__tag, __a, static_cast<_Inherited&&>(__in)) { }
                               :
                               :      template<typename _Alloc, typename _U1, typename _U2>
                               :	tuple(allocator_arg_t __tag, const _Alloc& __a,
                               :	      const tuple<_U1, _U2>& __in)
                               :	: _Inherited(__tag, __a,
                               :	             static_cast<const _Tuple_impl<0, _U1, _U2>&>(__in))
                               :	{ }
                               :
                               :      template<typename _Alloc, typename _U1, typename _U2>
                               :	tuple(allocator_arg_t __tag, const _Alloc& __a, tuple<_U1, _U2>&& __in)
                               :	: _Inherited(__tag, __a, static_cast<_Tuple_impl<0, _U1, _U2>&&>(__in))
                               :	{ }
                               :
                               :      template<typename _Alloc, typename _U1, typename _U2>
                               :        tuple(allocator_arg_t __tag, const _Alloc& __a,
                               :	      const pair<_U1, _U2>& __in)
                               :	: _Inherited(__tag, __a, __in.first, __in.second) { }
                               :
                               :      template<typename _Alloc, typename _U1, typename _U2>
                               :        tuple(allocator_arg_t __tag, const _Alloc& __a, pair<_U1, _U2>&& __in)
                               :	: _Inherited(__tag, __a, std::forward<_U1>(__in.first),
                               :		     std::forward<_U2>(__in.second)) { }
                               :
                               :      tuple&
                               :      operator=(const tuple& __in)
                               :      {
                               :	static_cast<_Inherited&>(*this) = __in;
                               :	return *this;
                               :      }
                               :
                               :      tuple&
                               :      operator=(tuple&& __in)
                               :      noexcept(is_nothrow_move_assignable<_Inherited>::value)
                               :      {
                               :	static_cast<_Inherited&>(*this) = std::move(__in);
                               :	return *this;
                               :      }
                               :
                               :      template<typename _U1, typename _U2>
                               :        tuple&
                               :        operator=(const tuple<_U1, _U2>& __in)
                               :        {
                               :	  static_cast<_Inherited&>(*this) = __in;
                               :	  return *this;
                               :	}
                               :
                               :      template<typename _U1, typename _U2>
                               :        tuple&
                               :        operator=(tuple<_U1, _U2>&& __in)
                               :        {
                               :	  static_cast<_Inherited&>(*this) = std::move(__in);
                               :	  return *this;
                               :	}
                               :
                               :      template<typename _U1, typename _U2>
                               :        tuple&
                               :        operator=(const pair<_U1, _U2>& __in)
                               :        {
                               :	  this->_M_head(*this) = __in.first;
                               :	  this->_M_tail(*this)._M_head(*this) = __in.second;
                               :	  return *this;
                               :	}
                               :
                               :      template<typename _U1, typename _U2>
                               :        tuple&
                               :        operator=(pair<_U1, _U2>&& __in)
                               :        {
                               :	  this->_M_head(*this) = std::forward<_U1>(__in.first);
                               :	  this->_M_tail(*this)._M_head(*this) = std::forward<_U2>(__in.second);
                               :	  return *this;
                               :	}
                               :
                               :      void
                               :      swap(tuple& __in)
                               :      noexcept(noexcept(__in._M_swap(__in)))
                               :      { _Inherited::_M_swap(__in); }
                               :    };
                               :
                               :
                               :  /// Gives the type of the ith element of a given tuple type.
                               :  template<std::size_t __i, typename _Tp>
                               :    struct tuple_element;
                               :
                               :  /**
                               :   * Recursive case for tuple_element: strip off the first element in
                               :   * the tuple and retrieve the (i-1)th element of the remaining tuple.
                               :   */
                               :  template<std::size_t __i, typename _Head, typename... _Tail>
                               :    struct tuple_element<__i, tuple<_Head, _Tail...> >
                               :    : tuple_element<__i - 1, tuple<_Tail...> > { };
                               :
                               :  /**
                               :   * Basis case for tuple_element: The first element is the one we're seeking.
                               :   */
                               :  template<typename _Head, typename... _Tail>
                               :    struct tuple_element<0, tuple<_Head, _Tail...> >
                               :    {
                               :      typedef _Head type;
                               :    };
                               :
                               :  template<std::size_t __i, typename _Tp>
                               :    struct tuple_element<__i, const _Tp>
                               :    {
                               :      typedef typename
                               :      add_const<typename tuple_element<__i, _Tp>::type>::type type;
                               :    };
                               :
                               :  template<std::size_t __i, typename _Tp>
                               :    struct tuple_element<__i, volatile _Tp>
                               :    {
                               :      typedef typename
                               :      add_volatile<typename tuple_element<__i, _Tp>::type>::type type;
                               :    };
                               :
                               :  template<std::size_t __i, typename _Tp>
                               :    struct tuple_element<__i, const volatile _Tp>
                               :    {
                               :      typedef typename
                               :      add_cv<typename tuple_element<__i, _Tp>::type>::type type;
                               :    };
                               :
                               :  /// Finds the size of a given tuple type.
                               :  template<typename _Tp>
                               :    struct tuple_size;
                               :
                               :  template<typename _Tp>
                               :    struct tuple_size<const _Tp>
                               :    : public integral_constant<
                               :             typename remove_cv<decltype(tuple_size<_Tp>::value)>::type,
                               :             tuple_size<_Tp>::value> { };
                               :
                               :  template<typename _Tp>
                               :    struct tuple_size<volatile _Tp>
                               :    : public integral_constant<
                               :             typename remove_cv<decltype(tuple_size<_Tp>::value)>::type,
                               :             tuple_size<_Tp>::value> { };
                               :
                               :  template<typename _Tp>
                               :    struct tuple_size<const volatile _Tp>
                               :    : public integral_constant<
                               :             typename remove_cv<decltype(tuple_size<_Tp>::value)>::type,
                               :             tuple_size<_Tp>::value> { };
                               :
                               :  /// class tuple_size
                               :  template<typename... _Elements>
                               :    struct tuple_size<tuple<_Elements...>>
                               :    : public integral_constant<std::size_t, sizeof...(_Elements)> { };
                               :
                               :  template<std::size_t __i, typename _Head, typename... _Tail>
                               :    constexpr typename __add_ref<_Head>::type
                               :    __get_helper(_Tuple_impl<__i, _Head, _Tail...>& __t) noexcept
                               :    { return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t); }
                               :
                               :  template<std::size_t __i, typename _Head, typename... _Tail>
                               :    constexpr typename __add_c_ref<_Head>::type
                               :    __get_helper(const _Tuple_impl<__i, _Head, _Tail...>& __t) noexcept
                               :    { return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t); }
                               :
                               :  // Return a reference (const reference, rvalue reference) to the ith element
                               :  // of a tuple.  Any const or non-const ref elements are returned with their
                               :  // original type.
                               :  template<std::size_t __i, typename... _Elements>
                               :    constexpr typename __add_ref<
                               :                      typename tuple_element<__i, tuple<_Elements...>>::type
                               :                    >::type
                               :    get(tuple<_Elements...>& __t) noexcept
                               :    { return __get_helper<__i>(__t); }
                               :
                               :  template<std::size_t __i, typename... _Elements>
                               :    constexpr typename __add_c_ref<
                               :                      typename tuple_element<__i, tuple<_Elements...>>::type
                               :                    >::type
                               :    get(const tuple<_Elements...>& __t) noexcept
                               :    { return __get_helper<__i>(__t); }
                               :
                               :  template<std::size_t __i, typename... _Elements>
                               :    constexpr typename __add_r_ref<
                               :                      typename tuple_element<__i, tuple<_Elements...>>::type
                               :                    >::type
                               :    get(tuple<_Elements...>&& __t) noexcept
                               :    { return std::forward<typename tuple_element<__i,
                               :	tuple<_Elements...>>::type&&>(get<__i>(__t)); }
                               :
                               :  // This class helps construct the various comparison operations on tuples
                               :  template<std::size_t __check_equal_size, std::size_t __i, std::size_t __j,
                               :	   typename _Tp, typename _Up>
                               :    struct __tuple_compare;
                               :
                               :  template<std::size_t __i, std::size_t __j, typename _Tp, typename _Up>
                               :    struct __tuple_compare<0, __i, __j, _Tp, _Up>
                               :    {
                               :      static constexpr bool 
                               :      __eq(const _Tp& __t, const _Up& __u)
                               :      {
                               :	return (get<__i>(__t) == get<__i>(__u) &&
                               :		__tuple_compare<0, __i + 1, __j, _Tp, _Up>::__eq(__t, __u));
                               :      }
                               :     
                               :      static constexpr bool 
                               :      __less(const _Tp& __t, const _Up& __u)
                               :      {
                               :	return ((get<__i>(__t) < get<__i>(__u))
                               :		|| !(get<__i>(__u) < get<__i>(__t)) &&
                               :		__tuple_compare<0, __i + 1, __j, _Tp, _Up>::__less(__t, __u));
                               :      }
                               :    };
                               :
                               :  template<std::size_t __i, typename _Tp, typename _Up>
                               :    struct __tuple_compare<0, __i, __i, _Tp, _Up>
                               :    {
                               :      static constexpr bool 
                               :      __eq(const _Tp&, const _Up&) { return true; }
                               :     
                               :      static constexpr bool 
                               :      __less(const _Tp&, const _Up&) { return false; }
                               :    };
                               :
                               :  template<typename... _TElements, typename... _UElements>
                               :    constexpr bool
                               :    operator==(const tuple<_TElements...>& __t,
                               :	       const tuple<_UElements...>& __u)
                               :    {
                               :      typedef tuple<_TElements...> _Tp;
                               :      typedef tuple<_UElements...> _Up;
                               :      return bool(__tuple_compare<tuple_size<_Tp>::value - tuple_size<_Up>::value,
                               :	      0, tuple_size<_Tp>::value, _Tp, _Up>::__eq(__t, __u));
                               :    }
                               :
                               :  template<typename... _TElements, typename... _UElements>
                               :    constexpr bool
                               :    operator<(const tuple<_TElements...>& __t,
                               :	      const tuple<_UElements...>& __u)
                               :    {
                               :      typedef tuple<_TElements...> _Tp;
                               :      typedef tuple<_UElements...> _Up;
                               :      return bool(__tuple_compare<tuple_size<_Tp>::value - tuple_size<_Up>::value,
                               :	      0, tuple_size<_Tp>::value, _Tp, _Up>::__less(__t, __u));
                               :    }
                               :
                               :  template<typename... _TElements, typename... _UElements>
                               :    inline constexpr bool
                               :    operator!=(const tuple<_TElements...>& __t,
                               :	       const tuple<_UElements...>& __u)
                               :    { return !(__t == __u); }
                               :
                               :  template<typename... _TElements, typename... _UElements>
                               :    inline constexpr bool
                               :    operator>(const tuple<_TElements...>& __t,
                               :	      const tuple<_UElements...>& __u)
                               :    { return __u < __t; }
                               :
                               :  template<typename... _TElements, typename... _UElements>
                               :    inline constexpr bool
                               :    operator<=(const tuple<_TElements...>& __t,
                               :	       const tuple<_UElements...>& __u)
                               :    { return !(__u < __t); }
                               :
                               :  template<typename... _TElements, typename... _UElements>
                               :    inline constexpr bool
                               :    operator>=(const tuple<_TElements...>& __t,
                               :	       const tuple<_UElements...>& __u)
                               :    { return !(__t < __u); }
                               :
                               :  // NB: DR 705.
                               :  template<typename... _Elements>
                               :    constexpr tuple<typename __decay_and_strip<_Elements>::__type...>
                               :    make_tuple(_Elements&&... __args)
                               :    {
                               :      typedef tuple<typename __decay_and_strip<_Elements>::__type...>
                               :	__result_type;
                               :      return __result_type(std::forward<_Elements>(__args)...);
                               :    }
                               :
                               :  template<typename... _Elements>
                               :    tuple<_Elements&&...>
                               :    forward_as_tuple(_Elements&&... __args) noexcept
                               :    { return tuple<_Elements&&...>(std::forward<_Elements>(__args)...); }
                               :
                               :  template<typename>
                               :    struct __is_tuple_like_impl : false_type
                               :    { };
                               :
                               :  template<typename... _Tps>
                               :    struct __is_tuple_like_impl<tuple<_Tps...>> : true_type
                               :    { };
                               :
                               :  template<typename _T1, typename _T2>
                               :    struct __is_tuple_like_impl<pair<_T1, _T2>> : true_type
                               :    { };
                               :
                               :  template<typename _Tp, std::size_t _Nm>
                               :    struct __is_tuple_like_impl<array<_Tp, _Nm>> : true_type
                               :    { };
                               :
                               :  // Internal type trait that allows us to sfinae-protect tuple_cat.
                               :  template<typename _Tp>
                               :    struct __is_tuple_like
                               :    : public __is_tuple_like_impl<typename std::remove_cv
                               :            <typename std::remove_reference<_Tp>::type>::type>::type
                               :    { };
                               :
                               :  // Stores a tuple of indices.  Also used by bind() to extract the elements
                               :  // in a tuple. 
                               :  template<std::size_t... _Indexes>
                               :    struct _Index_tuple
                               :    {
                               :      typedef _Index_tuple<_Indexes..., sizeof...(_Indexes)> __next;
                               :    };
                               :
                               :  // Builds an _Index_tuple<0, 1, 2, ..., _Num-1>.
                               :  template<std::size_t _Num>
                               :    struct _Build_index_tuple
                               :    {
                               :      typedef typename _Build_index_tuple<_Num - 1>::__type::__next __type;
                               :    };
                               :
                               :  template<>
                               :    struct _Build_index_tuple<0>
                               :    {
                               :      typedef _Index_tuple<> __type;
                               :    };
                               :
                               :  template<std::size_t, typename, typename, std::size_t>
                               :    struct __make_tuple_impl;
                               :
                               :  template<std::size_t _Idx, typename _Tuple, typename... _Tp,
                               :           std::size_t _Nm>
                               :    struct __make_tuple_impl<_Idx, tuple<_Tp...>, _Tuple, _Nm>
                               :    {
                               :      typedef typename __make_tuple_impl<_Idx + 1, tuple<_Tp...,
                               :	typename std::tuple_element<_Idx, _Tuple>::type>, _Tuple, _Nm>::__type
                               :      __type;
                               :    };
                               :
                               :  template<std::size_t _Nm, typename _Tuple, typename... _Tp>
                               :    struct __make_tuple_impl<_Nm, tuple<_Tp...>, _Tuple, _Nm>
                               :    {
                               :      typedef tuple<_Tp...> __type;
                               :    };
                               :
                               :  template<typename _Tuple>
                               :    struct __do_make_tuple
                               :    : public __make_tuple_impl<0, tuple<>, _Tuple,
                               :                               std::tuple_size<_Tuple>::value>
                               :    { };
                               :
                               :  // Returns the std::tuple equivalent of a tuple-like type.
                               :  template<typename _Tuple>
                               :    struct __make_tuple
                               :    : public __do_make_tuple<typename std::remove_cv
                               :            <typename std::remove_reference<_Tuple>::type>::type>
                               :    { };
                               :
                               :  // Combines several std::tuple's into a single one.
                               :  template<typename...>
                               :    struct __combine_tuples;
                               :
                               :  template<>
                               :    struct __combine_tuples<>
                               :    {
                               :      typedef tuple<> __type;
                               :    };
                               :
                               :  template<typename... _Ts>
                               :    struct __combine_tuples<tuple<_Ts...>>
                               :    {
                               :      typedef tuple<_Ts...> __type;
                               :    };
                               :
                               :  template<typename... _T1s, typename... _T2s, typename... _Rem>
                               :    struct __combine_tuples<tuple<_T1s...>, tuple<_T2s...>, _Rem...>
                               :    {
                               :      typedef typename __combine_tuples<tuple<_T1s..., _T2s...>,
                               :					_Rem...>::__type __type;
                               :    };
                               :
                               :  // Computes the result type of tuple_cat given a set of tuple-like types.
                               :  template<typename... _Tpls>
                               :    struct __tuple_cat_result
                               :    {
                               :      typedef typename __combine_tuples
                               :        <typename __make_tuple<_Tpls>::__type...>::__type __type;
                               :    };
                               :
                               :  // Helper to determine the index set for the first tuple-like
                               :  // type of a given set.
                               :  template<typename...>
                               :    struct __make_1st_indices;
                               :
                               :  template<>
                               :    struct __make_1st_indices<>
                               :    {
                               :      typedef std::_Index_tuple<> __type;
                               :    };
                               :
                               :  template<typename _Tp, typename... _Tpls>
                               :    struct __make_1st_indices<_Tp, _Tpls...>
                               :    {
                               :      typedef typename std::_Build_index_tuple<std::tuple_size<
                               :	typename std::remove_reference<_Tp>::type>::value>::__type __type;
                               :    };
                               :
                               :  // Performs the actual concatenation by step-wise expanding tuple-like
                               :  // objects into the elements,  which are finally forwarded into the
                               :  // result tuple.
                               :  template<typename _Ret, typename _Indices, typename... _Tpls>
                               :    struct __tuple_concater;
                               :
                               :  template<typename _Ret, std::size_t... _Is, typename _Tp, typename... _Tpls>
                               :    struct __tuple_concater<_Ret, std::_Index_tuple<_Is...>, _Tp, _Tpls...>
                               :    {
                               :      template<typename... _Us>
                               :        static constexpr _Ret
                               :        _S_do(_Tp&& __tp, _Tpls&&... __tps, _Us&&... __us)
                               :        {
                               :	  typedef typename __make_1st_indices<_Tpls...>::__type __idx;
                               :	  typedef __tuple_concater<_Ret, __idx, _Tpls...>      __next;
                               :	  return __next::_S_do(std::forward<_Tpls>(__tps)...,
                               :			       std::forward<_Us>(__us)...,
                               :			       std::get<_Is>(std::forward<_Tp>(__tp))...);
                               :	}
                               :    };
                               :
                               :  template<typename _Ret>
                               :    struct __tuple_concater<_Ret, std::_Index_tuple<>>
                               :    {
                               :      template<typename... _Us>
                               :	static constexpr _Ret
                               :	_S_do(_Us&&... __us)
                               :        {
                               :	  return _Ret(std::forward<_Us>(__us)...);
                               :	}
                               :    };
                               :
                               :  /// tuple_cat
                               :  template<typename... _Tpls, typename = typename
                               :           enable_if<__and_<__is_tuple_like<_Tpls>...>::value>::type>
                               :    constexpr auto
                               :    tuple_cat(_Tpls&&... __tpls)
                               :    -> typename __tuple_cat_result<_Tpls...>::__type
                               :    {
                               :      typedef typename __tuple_cat_result<_Tpls...>::__type __ret;
                               :      typedef typename __make_1st_indices<_Tpls...>::__type __idx;
                               :      typedef __tuple_concater<__ret, __idx, _Tpls...> __concater;
                               :      return __concater::_S_do(std::forward<_Tpls>(__tpls)...);
                               :    }
                               :
                               :  /// tie
                               :  template<typename... _Elements>
                               :    inline tuple<_Elements&...>
                               :    tie(_Elements&... __args) noexcept
                               :    { return tuple<_Elements&...>(__args...); }
                               :
                               :  /// swap
                               :  template<typename... _Elements>
                               :    inline void 
                               :    swap(tuple<_Elements...>& __x, tuple<_Elements...>& __y)
                               :    noexcept(noexcept(__x.swap(__y)))
                               :    { __x.swap(__y); }
                               :
                               :  // A class (and instance) which can be used in 'tie' when an element
                               :  // of a tuple is not required
                               :  struct _Swallow_assign
                               :  {
                               :    template<class _Tp>
                               :      const _Swallow_assign&
                               :      operator=(const _Tp&) const
                               :      { return *this; }
                               :  };
                               :
                               :  const _Swallow_assign ignore{};
                               :
                               :  /// Partial specialization for tuples
                               :  template<typename... _Types, typename _Alloc>
                               :    struct uses_allocator<tuple<_Types...>, _Alloc> : true_type { };
                               :
                               :  // See stl_pair.h...
                               :  template<class _T1, class _T2>
                               :    template<typename... _Args1, typename... _Args2>
                               :      inline
                               :      pair<_T1, _T2>::
                               :      pair(piecewise_construct_t,
                               :	   tuple<_Args1...> __first, tuple<_Args2...> __second)
                               :      : pair(__first, __second,
                               :	     typename _Build_index_tuple<sizeof...(_Args1)>::__type(),
                               :	     typename _Build_index_tuple<sizeof...(_Args2)>::__type())
                               :      { }
                               :
                               :  template<class _T1, class _T2>
                               :    template<typename... _Args1, std::size_t... _Indexes1,
                               :             typename... _Args2, std::size_t... _Indexes2>
                               :      inline
                               :      pair<_T1, _T2>::
                               :      pair(tuple<_Args1...>& __tuple1, tuple<_Args2...>& __tuple2,
                               :	   _Index_tuple<_Indexes1...>, _Index_tuple<_Indexes2...>)
                               :      : first(std::forward<_Args1>(std::get<_Indexes1>(__tuple1))...),
     1 8.5e-04     0       0   :        second(std::forward<_Args2>(std::get<_Indexes2>(__tuple2))...)
                               :      { }
                               :
                               :  /// @}
                               :
                               :_GLIBCXX_END_NAMESPACE_VERSION
                               :} // namespace std
                               :
                               :#endif // C++11
                               :
                               :#endif // _GLIBCXX_TUPLE
